Help on package numpy.ma in numpy:

NNAAMMEE
    numpy.ma

DDEESSCCRRIIPPTTIIOONN
    =============
    Masked Arrays
    =============
    
    Arrays sometimes contain invalid or missing data.  When doing operations
    on such arrays, we wish to suppress invalid values, which is the purpose masked
    arrays fulfill (an example of typical use is given below).
    
    For example, examine the following array:
    
    >>> x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])
    
    When we try to calculate the mean of the data, the result is undetermined:
    
    >>> np.mean(x)
    nan
    
    The mean is calculated using roughly ``np.sum(x)/len(x)``, but since
    any number added to ``NaN`` [1]_ produces ``NaN``, this doesn't work.  Enter
    masked arrays:
    
    >>> m = np.ma.masked_array(x, np.isnan(x))
    >>> m
    masked_array(data = [2.0 1.0 3.0 -- 5.0 2.0 3.0 --],
          mask = [False False False  True False False False  True],
          fill_value=1e+20)
    
    Here, we construct a masked array that suppress all ``NaN`` values.  We
    may now proceed to calculate the mean of the other values:
    
    >>> np.mean(m)
    2.6666666666666665
    
    .. [1] Not-a-Number, a floating point value that is the result of an
           invalid operation.
    
    .. moduleauthor:: Pierre Gerard-Marchant
    .. moduleauthor:: Jarrod Millman

PPAACCKKAAGGEE  CCOONNTTEENNTTSS
    bench
    core
    extras
    mrecords
    setup
    testutils
    timer_comparison
    version

CCLLAASSSSEESS
    builtins.Exception(builtins.BaseException)
        numpy.ma.core.MAError
            numpy.ma.core.MaskError
    numpy.generic(builtins.object)
        numpy.bool_
    numpy.ndarray(builtins.object)
        numpy.ma.core.MaskedArray
            numpy.ma.core.mvoid
    
    class MMAAEErrrroorr(builtins.Exception)
     |  Class for masked array related errors.
     |  
     |  Method resolution order:
     |      MAError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  ____iinniitt____(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ____nneeww____(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  ____ddeellaattttrr____(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrriibbuuttee____(self, name, /)
     |      Return getattr(self, name).
     |  
     |  ____rreedduuccee____(...)
     |      helper for pickle
     |  
     |  ____rreepprr____(self, /)
     |      Return repr(self).
     |  
     |  ____sseettaattttrr____(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(...)
     |  
     |  ____ssttrr____(self, /)
     |      Return str(self).
     |  
     |  wwiitthh__ttrraacceebbaacckk(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  ____ccaauussee____
     |      exception cause
     |  
     |  ____ccoonntteexxtt____
     |      exception context
     |  
     |  ____ddiicctt____
     |  
     |  ____ssuupppprreessss__ccoonntteexxtt____
     |  
     |  ____ttrraacceebbaacckk____
     |  
     |  aarrggss
    
    class MMaasskkEErrrroorr(MAError)
     |  Class for mask related errors.
     |  
     |  Method resolution order:
     |      MaskError
     |      MAError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors inherited from MAError:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  ____iinniitt____(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ____nneeww____(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  ____ddeellaattttrr____(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrriibbuuttee____(self, name, /)
     |      Return getattr(self, name).
     |  
     |  ____rreedduuccee____(...)
     |      helper for pickle
     |  
     |  ____rreepprr____(self, /)
     |      Return repr(self).
     |  
     |  ____sseettaattttrr____(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(...)
     |  
     |  ____ssttrr____(self, /)
     |      Return str(self).
     |  
     |  wwiitthh__ttrraacceebbaacckk(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  ____ccaauussee____
     |      exception cause
     |  
     |  ____ccoonntteexxtt____
     |      exception context
     |  
     |  ____ddiicctt____
     |  
     |  ____ssuupppprreessss__ccoonntteexxtt____
     |  
     |  ____ttrraacceebbaacckk____
     |  
     |  aarrggss
    
    MMaasskkTTyyppee = class bool_(generic)
     |  NumPy's Boolean type.  Character code: ``?``.  Alias: bool8
     |  
     |  Method resolution order:
     |      bool_
     |      generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____aanndd____(self, value, /)
     |      Return self&value.
     |  
     |  ____bbooooll____(self, /)
     |      self != 0
     |  
     |  ____eeqq____(self, value, /)
     |      Return self==value.
     |  
     |  ____ggee____(self, value, /)
     |      Return self>=value.
     |  
     |  ____ggtt____(self, value, /)
     |      Return self>value.
     |  
     |  ____hhaasshh____(self, /)
     |      Return hash(self).
     |  
     |  ____iinnddeexx____(self, /)
     |      Return self converted to an integer, if self is suitable for use as an index into a list.
     |  
     |  ____llee____(self, value, /)
     |      Return self<=value.
     |  
     |  ____lltt____(self, value, /)
     |      Return self<value.
     |  
     |  ____nnee____(self, value, /)
     |      Return self!=value.
     |  
     |  ____nneeww____(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ____oorr____(self, value, /)
     |      Return self|value.
     |  
     |  ____rraanndd____(self, value, /)
     |      Return value&self.
     |  
     |  ____rroorr____(self, value, /)
     |      Return value|self.
     |  
     |  ____rrxxoorr____(self, value, /)
     |      Return value^self.
     |  
     |  ____xxoorr____(self, value, /)
     |      Return self^value.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from generic:
     |  
     |  ____aabbss____(self, /)
     |      abs(self)
     |  
     |  ____aadddd____(self, value, /)
     |      Return self+value.
     |  
     |  ____aarrrraayy____(...)
     |      sc.__array__(|type) return 0-dim array
     |  
     |  ____aarrrraayy__wwrraapp____(...)
     |      sc.__array_wrap__(obj) return scalar from array
     |  
     |  ____ccooppyy____(...)
     |  
     |  ____ddeeeeppccooppyy____(...)
     |  
     |  ____ddiivvmmoodd____(self, value, /)
     |      Return divmod(self, value).
     |  
     |  ____ffllooaatt____(self, /)
     |      float(self)
     |  
     |  ____fflloooorrddiivv____(self, value, /)
     |      Return self//value.
     |  
     |  ____ffoorrmmaatt____(...)
     |      NumPy array scalar formatter
     |  
     |  ____ggeettiitteemm____(self, key, /)
     |      Return self[key].
     |  
     |  ____iinntt____(self, /)
     |      int(self)
     |  
     |  ____iinnvveerrtt____(self, /)
     |      ~self
     |  
     |  ____llsshhiifftt____(self, value, /)
     |      Return self<<value.
     |  
     |  ____mmoodd____(self, value, /)
     |      Return self%value.
     |  
     |  ____mmuull____(self, value, /)
     |      Return self*value.
     |  
     |  ____nneegg____(self, /)
     |      -self
     |  
     |  ____ppooss____(self, /)
     |      +self
     |  
     |  ____ppooww____(self, value, mod=None, /)
     |      Return pow(self, value, mod).
     |  
     |  ____rraadddd____(self, value, /)
     |      Return value+self.
     |  
     |  ____rrddiivvmmoodd____(self, value, /)
     |      Return divmod(value, self).
     |  
     |  ____rreedduuccee____(...)
     |      helper for pickle
     |  
     |  ____rreepprr____(self, /)
     |      Return repr(self).
     |  
     |  ____rrfflloooorrddiivv____(self, value, /)
     |      Return value//self.
     |  
     |  ____rrllsshhiifftt____(self, value, /)
     |      Return value<<self.
     |  
     |  ____rrmmoodd____(self, value, /)
     |      Return value%self.
     |  
     |  ____rrmmuull____(self, value, /)
     |      Return value*self.
     |  
     |  ____rroouunndd____(...)
     |  
     |  ____rrppooww____(self, value, mod=None, /)
     |      Return pow(value, self, mod).
     |  
     |  ____rrrrsshhiifftt____(self, value, /)
     |      Return value>>self.
     |  
     |  ____rrsshhiifftt____(self, value, /)
     |      Return self>>value.
     |  
     |  ____rrssuubb____(self, value, /)
     |      Return value-self.
     |  
     |  ____rrttrruueeddiivv____(self, value, /)
     |      Return value/self.
     |  
     |  ____sseettssttaattee____(...)
     |  
     |  ____ssiizzeeooff____(...)
     |      __sizeof__() -> int
     |      size of object in memory, in bytes
     |  
     |  ____ssttrr____(self, /)
     |      Return str(self).
     |  
     |  ____ssuubb____(self, value, /)
     |      Return self-value.
     |  
     |  ____ttrruueeddiivv____(self, value, /)
     |      Return self/value.
     |  
     |  aallll(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aannyy(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aarrggmmaaxx(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aarrggmmiinn(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aarrggssoorrtt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aassttyyppee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  bbyytteesswwaapp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class so as to
     |      provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  cchhoooossee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  cclliipp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccoommpprreessss(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccoonnjj(...)
     |  
     |  ccoonnjjuuggaattee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccooppyy(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccuummpprroodd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccuummssuumm(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ddiiaaggoonnaall(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  dduummpp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  dduummppss(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ffiillll(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ffllaatttteenn(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ggeettffiieelldd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  iitteemm(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  iitteemmsseett(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  mmaaxx(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  mmeeaann(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  mmiinn(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  nneewwbbyytteeoorrddeerr(...)
     |      newbyteorder(new_order='S')
     |      
     |      Return a new `dtype` with a different byte order.
     |      
     |      Changes are also made in all fields and sub-arrays of the data type.
     |      
     |      The `new_order` code can be any from the following:
     |      
     |      * 'S' - swap dtype from current to opposite endian
     |      * {'<', 'L'} - little endian
     |      * {'>', 'B'} - big endian
     |      * {'=', 'N'} - native order
     |      * {'|', 'I'} - ignore (no change to byte order)
     |      
     |      Parameters
     |      ----------
     |      new_order : str, optional
     |          Byte order to force; a value from the byte order specifications
     |          above.  The default value ('S') results in swapping the current
     |          byte order. The code does a case-insensitive check on the first
     |          letter of `new_order` for the alternatives above.  For example,
     |          any of 'B' or 'b' or 'biggish' are valid to specify big-endian.
     |      
     |      
     |      Returns
     |      -------
     |      new_dtype : dtype
     |          New `dtype` object with the given change to the byte order.
     |  
     |  nnoonnzzeerroo(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  pprroodd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ppttpp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ppuutt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rraavveell(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rreeppeeaatt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rreesshhaappee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rreessiizzee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rroouunndd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sseeaarrcchhssoorrtteedd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sseettffiieelldd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sseettffllaaggss(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class so as to
     |      provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssoorrtt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssqquueeeezzee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssttdd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssuumm(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sswwaappaaxxeess(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttaakkee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttoobbyytteess(...)
     |  
     |  ttooffiillee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttoolliisstt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttoossttrriinngg(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttrraaccee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttrraannssppoossee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  vvaarr(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  vviieeww(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from generic:
     |  
     |  TT
     |      transpose
     |  
     |  ____aarrrraayy__iinntteerrffaaccee____
     |      Array protocol: Python side
     |  
     |  ____aarrrraayy__pprriioorriittyy____
     |      Array priority.
     |  
     |  ____aarrrraayy__ssttrruucctt____
     |      Array protocol: struct
     |  
     |  bbaassee
     |      base object
     |  
     |  ddaattaa
     |      pointer to start of data
     |  
     |  ddttyyppee
     |      get array data-descriptor
     |  
     |  ffllaaggss
     |      integer value of flags
     |  
     |  ffllaatt
     |      a 1-d view of scalar
     |  
     |  iimmaagg
     |      imaginary part of scalar
     |  
     |  iitteemmssiizzee
     |      length of one element in bytes
     |  
     |  nnbbyytteess
     |      length of item in bytes
     |  
     |  nnddiimm
     |      number of array dimensions
     |  
     |  rreeaall
     |      real part of scalar
     |  
     |  sshhaappee
     |      tuple of array dimensions
     |  
     |  ssiizzee
     |      number of elements in the gentype
     |  
     |  ssttrriiddeess
     |      tuple of bytes steps in each dimension
    
    class MMaasskkeeddAArrrraayy(numpy.ndarray)
     |  An array class with possibly masked values.
     |  
     |  Masked values of True exclude the corresponding element from any
     |  computation.
     |  
     |  Construction::
     |  
     |    x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
     |                    ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
     |                    shrink=True, order=None)
     |  
     |  Parameters
     |  ----------
     |  data : array_like
     |      Input data.
     |  mask : sequence, optional
     |      Mask. Must be convertible to an array of booleans with the same
     |      shape as `data`. True indicates a masked (i.e. invalid) data.
     |  dtype : dtype, optional
     |      Data type of the output.
     |      If `dtype` is None, the type of the data argument (``data.dtype``)
     |      is used. If `dtype` is not None and different from ``data.dtype``,
     |      a copy is performed.
     |  copy : bool, optional
     |      Whether to copy the input data (True), or to use a reference instead.
     |      Default is False.
     |  subok : bool, optional
     |      Whether to return a subclass of `MaskedArray` if possible (True) or a
     |      plain `MaskedArray`. Default is True.
     |  ndmin : int, optional
     |      Minimum number of dimensions. Default is 0.
     |  fill_value : scalar, optional
     |      Value used to fill in the masked values when necessary.
     |      If None, a default based on the data-type is used.
     |  keep_mask : bool, optional
     |      Whether to combine `mask` with the mask of the input data, if any
     |      (True), or to use only `mask` for the output (False). Default is True.
     |  hard_mask : bool, optional
     |      Whether to use a hard mask or not. With a hard mask, masked values
     |      cannot be unmasked. Default is False.
     |  shrink : bool, optional
     |      Whether to force compression of an empty mask. Default is True.
     |  order : {'C', 'F', 'A'}, optional
     |      Specify the order of the array.  If order is 'C', then the array
     |      will be in C-contiguous order (last-index varies the fastest).
     |      If order is 'F', then the returned array will be in
     |      Fortran-contiguous order (first-index varies the fastest).
     |      If order is 'A' (default), then the returned array may be
     |      in any order (either C-, Fortran-contiguous, or even discontiguous),
     |      unless a copy is required, in which case it will be C-contiguous.
     |  
     |  Method resolution order:
     |      MaskedArray
     |      numpy.ndarray
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____aadddd____(self, other)
     |      Add self to other, and return a new masked array.
     |  
     |  ____aarrrraayy__ffiinnaalliizzee____(self, obj)
     |      Finalizes the masked array.
     |  
     |  ____aarrrraayy__wwrraapp____(self, obj, context=None)
     |      Special hook for ufuncs.
     |      
     |      Wraps the numpy array and sets the mask according to context.
     |  
     |  ____ddeeeeppccooppyy____(self, memo=None)
     |      a.__deepcopy__() -> Deep copy of array.
     |      
     |      Used if copy.deepcopy is called on an array.
     |  
     |  ____ddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  ____eeqq____(self, other)
     |      Check whether other equals self elementwise.
     |      
     |      When either of the elements is masked, the result is masked as well,
     |      but the underlying boolean data are still set, with self and other
     |      considered equal if both are masked, and unequal otherwise.
     |      
     |      For structured arrays, all fields are combined, with masked values
     |      ignored. The result is masked if all fields were masked, with self
     |      and other considered equal only if both were fully masked.
     |  
     |  ____ffllooaatt____(self)
     |      Convert to float.
     |  
     |  ____fflloooorrddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  ____ggeettiitteemm____(self, indx)
     |      x.__getitem__(y) <==> x[y]
     |      
     |      Return the item described by i, as a masked array.
     |  
     |  ____ggeettssttaattee____(self)
     |      Return the internal state of the masked array, for pickling
     |      purposes.
     |  
     |  ____iiaadddd____(self, other)
     |      Add other to self in-place.
     |  
     |  ____iiddiivv____(self, other)
     |      Divide self by other in-place.
     |  
     |  ____iifflloooorrddiivv____(self, other)
     |      Floor divide self by other in-place.
     |  
     |  ____iimmuull____(self, other)
     |      Multiply self by other in-place.
     |  
     |  ____iinntt____(self)
     |      Convert to int.
     |  
     |  ____iippooww____(self, other)
     |      Raise self to the power other, in place.
     |  
     |  ____iissuubb____(self, other)
     |      Subtract other from self in-place.
     |  
     |  ____iittrruueeddiivv____(self, other)
     |      True divide self by other in-place.
     |  
     |  ____mmuull____(self, other)
     |      Multiply self by other, and return a new masked array.
     |  
     |  ____nnee____(self, other)
     |      Check whether other does not equal self elementwise.
     |      
     |      When either of the elements is masked, the result is masked as well,
     |      but the underlying boolean data are still set, with self and other
     |      considered equal if both are masked, and unequal otherwise.
     |      
     |      For structured arrays, all fields are combined, with masked values
     |      ignored. The result is masked if all fields were masked, with self
     |      and other considered equal only if both were fully masked.
     |  
     |  ____ppooww____(self, other)
     |      Raise self to the power other, masking the potential NaNs/Infs
     |  
     |  ____rraadddd____(self, other)
     |      Add other to self, and return a new masked array.
     |  
     |  ____rreedduuccee____(self)
     |      Return a 3-tuple for pickling a MaskedArray.
     |  
     |  ____rreepprr____(self)
     |      Literal string representation.
     |  
     |  ____rrfflloooorrddiivv____(self, other)
     |      Divide self into other, and return a new masked array.
     |  
     |  ____rrmmuull____(self, other)
     |      Multiply other by self, and return a new masked array.
     |  
     |  ____rrppooww____(self, other)
     |      Raise other to the power self, masking the potential NaNs/Infs
     |  
     |  ____rrssuubb____(self, other)
     |      Subtract self from other, and return a new masked array.
     |  
     |  ____rrttrruueeddiivv____(self, other)
     |      Divide self into other, and return a new masked array.
     |  
     |  ____sseettaattttrr____(self, attr, value)
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettiitteemm____(self, indx, value)
     |      x.__setitem__(i, y) <==> x[i]=y
     |      
     |      Set item described by index. If value is masked, masks those
     |      locations.
     |  
     |  ____sseettmmaasskk____(self, mask, copy=False)
     |      Set the mask.
     |  
     |  ____sseettssttaattee____(self, state)
     |      Restore the internal state of the masked array, for
     |      pickling purposes.  ``state`` is typically the output of the
     |      ``__getstate__`` output, and is a 5-tuple:
     |      
     |      - class name
     |      - a tuple giving the shape of the data
     |      - a typecode for the data
     |      - a binary string for the data
     |      - a binary string for the mask.
     |  
     |  ____ssttrr____(self)
     |      String representation.
     |  
     |  ____ssuubb____(self, other)
     |      Subtract other from self, and return a new masked array.
     |  
     |  ____ttrruueeddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  aallll(self, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns True if all elements evaluate to True.
     |      
     |      The output array is masked where all the values along the given axis
     |      are masked: if the output would have been a scalar and that all the
     |      values are masked, then the output is `masked`.
     |      
     |      Refer to `numpy.all` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.all : corresponding function for ndarrays
     |      numpy.all : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> np.ma.array([1,2,3]).all()
     |      True
     |      >>> a = np.ma.array([1,2,3], mask=True)
     |      >>> (a.all() is np.ma.masked)
     |      True
     |  
     |  aannoomm(self, axis=None, dtype=None)
     |      Compute the anomalies (deviations from the arithmetic mean)
     |      along the given axis.
     |      
     |      Returns an array of anomalies, with the same shape as the input and
     |      where the arithmetic mean is computed along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis over which the anomalies are taken.
     |          The default is to use the mean of the flattened array as reference.
     |      dtype : dtype, optional
     |          Type to use in computing the variance. For arrays of integer type
     |           the default is float32; for arrays of float types it is the same as
     |           the array type.
     |      
     |      See Also
     |      --------
     |      mean : Compute the mean of the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([1,2,3])
     |      >>> a.anom()
     |      masked_array(data = [-1.  0.  1.],
     |                   mask = False,
     |             fill_value = 1e+20)
     |  
     |  aannyy(self, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns True if any of the elements of `a` evaluate to True.
     |      
     |      Masked values are considered as False during computation.
     |      
     |      Refer to `numpy.any` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.any : corresponding function for ndarrays
     |      numpy.any : equivalent function
     |  
     |  aarrggmmaaxx(self, axis=None, fill_value=None, out=None)
     |      Returns array of indices of the maximum values along the given axis.
     |      Masked values are treated as if they had the value fill_value.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, integer}
     |          If None, the index is into the flattened array, otherwise along
     |          the specified axis
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.  If None, the output of
     |          maximum_fill_value(self._data) is used instead.
     |      out : {None, array}, optional
     |          Array into which the result can be placed. Its type is preserved
     |          and it must be of the right shape to hold the output.
     |      
     |      Returns
     |      -------
     |      index_array : {integer_array}
     |      
     |      Examples
     |      --------
     |      >>> a = np.arange(6).reshape(2,3)
     |      >>> a.argmax()
     |      5
     |      >>> a.argmax(0)
     |      array([1, 1, 1])
     |      >>> a.argmax(1)
     |      array([2, 2])
     |  
     |  aarrggmmiinn(self, axis=None, fill_value=None, out=None)
     |      Return array of indices to the minimum values along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, integer}
     |          If None, the index is into the flattened array, otherwise along
     |          the specified axis
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.  If None, the output of
     |          minimum_fill_value(self._data) is used instead.
     |      out : {None, array}, optional
     |          Array into which the result can be placed. Its type is preserved
     |          and it must be of the right shape to hold the output.
     |      
     |      Returns
     |      -------
     |      ndarray or scalar
     |          If multi-dimension input, returns a new ndarray of indices to the
     |          minimum values along the given axis.  Otherwise, returns a scalar
     |          of index to the minimum values along the given axis.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(arange(4), mask=[1,1,0,0])
     |      >>> x.shape = (2,2)
     |      >>> print(x)
     |      [[-- --]
     |       [2 3]]
     |      >>> print(x.argmin(axis=0, fill_value=-1))
     |      [0 0]
     |      >>> print(x.argmin(axis=0, fill_value=9))
     |      [1 1]
     |  
     |  aarrggppaarrttiittiioonn(self, *args, **kwargs)
     |      a.argpartition(kth, axis=-1, kind='introselect', order=None)
     |      
     |      Returns the indices that would partition this array.
     |      
     |      Refer to `numpy.argpartition` for full documentation.
     |      
     |      .. versionadded:: 1.8.0
     |      
     |      See Also
     |      --------
     |      numpy.argpartition : equivalent function
     |  
     |  aarrggssoorrtt(self, axis=<class 'numpy._globals._NoValue'>, kind='quicksort', order=None, endwith=True, fill_value=None)
     |      Return an ndarray of indices that sort the array along the
     |      specified axis.  Masked values are filled beforehand to
     |      `fill_value`.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis along which to sort. If None, the default, the flattened array
     |          is used.
     |      
     |          ..  versionchanged:: 1.13.0
     |              Previously, the default was documented to be -1, but that was
     |              in error. At some future date, the default will change to -1, as
     |              originally intended.
     |              Until then, the axis should be given explicitly when
     |              ``arr.ndim > 1``, to avoid a FutureWarning.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm.
     |      order : list, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  Not all fields need be
     |          specified.
     |      endwith : {True, False}, optional
     |          Whether missing values (if any) should be treated as the largest values
     |          (True) or the smallest values (False)
     |          When the array contains unmasked values at the same extremes of the
     |          datatype, the ordering of these values and the masked values is
     |          undefined.
     |      fill_value : {var}, optional
     |          Value used internally for the masked values.
     |          If ``fill_value`` is not None, it supersedes ``endwith``.
     |      
     |      Returns
     |      -------
     |      index_array : ndarray, int
     |          Array of indices that sort `a` along the specified axis.
     |          In other words, ``a[index_array]`` yields a sorted `a`.
     |      
     |      See Also
     |      --------
     |      MaskedArray.sort : Describes sorting algorithms used.
     |      lexsort : Indirect stable sort with multiple keys.
     |      ndarray.sort : Inplace sort.
     |      
     |      Notes
     |      -----
     |      See `sort` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([3,2,1], mask=[False, False, True])
     |      >>> a
     |      masked_array(data = [3 2 --],
     |                   mask = [False False  True],
     |             fill_value = 999999)
     |      >>> a.argsort()
     |      array([1, 0, 2])
     |  
     |  aassttyyppee(self, newtype)
     |      Returns a copy of the MaskedArray cast to given newtype.
     |      
     |      Returns
     |      -------
     |      output : MaskedArray
     |          A copy of self cast to input newtype.
     |          The returned record shape matches self.shape.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1.0 -- 3.1]
     |       [-- 5.0 --]
     |       [7.0 -- 9.0]]
     |      >>> print(x.astype(int32))
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |  
     |  cclliipp(self, *args, **params)
     |      a.clip(min=None, max=None, out=None)
     |      
     |      Return an array whose values are limited to ``[min, max]``.
     |      One of max or min must be given.
     |      
     |      Refer to `numpy.clip` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.clip : equivalent function
     |  
     |  ccoommpprreessss(self, condition, axis=None, out=None)
     |      Return `a` where condition is ``True``.
     |      
     |      If condition is a `MaskedArray`, missing values are considered
     |      as ``False``.
     |      
     |      Parameters
     |      ----------
     |      condition : var
     |          Boolean 1-d array selecting which entries to return. If len(condition)
     |          is less than the size of a along the axis, then output is truncated
     |          to length of condition array.
     |      axis : {None, int}, optional
     |          Axis along which the operation must be performed.
     |      out : {None, ndarray}, optional
     |          Alternative output array in which to place the result. It must have
     |          the same shape as the expected output but the type will be cast if
     |          necessary.
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          A :class:`MaskedArray` object.
     |      
     |      Notes
     |      -----
     |      Please note the difference with :meth:`compressed` !
     |      The output of :meth:`compress` has a mask, the output of
     |      :meth:`compressed` does not.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> x.compress([1, 0, 1])
     |      masked_array(data = [1 3],
     |            mask = [False False],
     |            fill_value=999999)
     |      
     |      >>> x.compress([1, 0, 1], axis=1)
     |      masked_array(data =
     |       [[1 3]
     |       [-- --]
     |       [7 9]],
     |            mask =
     |       [[False False]
     |       [ True  True]
     |       [False False]],
     |            fill_value=999999)
     |  
     |  ccoommpprreesssseedd(self)
     |      Return all the non-masked data as a 1-D array.
     |      
     |      Returns
     |      -------
     |      data : ndarray
     |          A new `ndarray` holding the non-masked data is returned.
     |      
     |      Notes
     |      -----
     |      The result is **not** a MaskedArray!
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
     |      >>> x.compressed()
     |      array([0, 1])
     |      >>> type(x.compressed())
     |      <type 'numpy.ndarray'>
     |  
     |  ccooppyy(self, *args, **params)
     |      a.copy(order='C')
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          Controls the memory layout of the copy. 'C' means C-order,
     |          'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
     |          'C' otherwise. 'K' means match the layout of `a` as closely
     |          as possible. (Note that this function and :func:numpy.copy are very
     |          similar, but have different default values for their order=
     |          arguments.)
     |      
     |      See also
     |      --------
     |      numpy.copy
     |      numpy.copyto
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([[1,2,3],[4,5,6]], order='F')
     |      
     |      >>> y = x.copy()
     |      
     |      >>> x.fill(0)
     |      
     |      >>> x
     |      array([[0, 0, 0],
     |             [0, 0, 0]])
     |      
     |      >>> y
     |      array([[1, 2, 3],
     |             [4, 5, 6]])
     |      
     |      >>> y.flags['C_CONTIGUOUS']
     |      True
     |  
     |  ccoouunntt(self, axis=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Count the non-masked elements of the array along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : None or int or tuple of ints, optional
     |          Axis or axes along which the count is performed.
     |          The default (`axis` = `None`) performs the count over all
     |          the dimensions of the input array. `axis` may be negative, in
     |          which case it counts from the last to the first axis.
     |      
     |          .. versionadded:: 1.10.0
     |      
     |          If this is a tuple of ints, the count is performed on multiple
     |          axes, instead of a single axis or all the axes as before.
     |      keepdims : bool, optional
     |          If this is set to True, the axes which are reduced are left
     |          in the result as dimensions with size one. With this option,
     |          the result will broadcast correctly against the array.
     |      
     |      Returns
     |      -------
     |      result : ndarray or scalar
     |          An array with the same shape as the input array, with the specified
     |          axis removed. If the array is a 0-d array, or if `axis` is None, a
     |          scalar is returned.
     |      
     |      See Also
     |      --------
     |      count_masked : Count masked elements in array or along a given axis.
     |      
     |      Examples
     |      --------
     |      >>> import numpy.ma as ma
     |      >>> a = ma.arange(6).reshape((2, 3))
     |      >>> a[1, :] = ma.masked
     |      >>> a
     |      masked_array(data =
     |       [[0 1 2]
     |       [-- -- --]],
     |                   mask =
     |       [[False False False]
     |       [ True  True  True]],
     |             fill_value = 999999)
     |      >>> a.count()
     |      3
     |      
     |      When the `axis` keyword is specified an array of appropriate size is
     |      returned.
     |      
     |      >>> a.count(axis=0)
     |      array([1, 1, 1])
     |      >>> a.count(axis=1)
     |      array([3, 0])
     |  
     |  ccuummpprroodd(self, axis=None, dtype=None, out=None)
     |      Return the cumulative product of the array elements over the given axis.
     |      
     |      Masked values are set to 1 internally during the computation.
     |      However, their position is saved, and the result will be masked at
     |      the same locations.
     |      
     |      Refer to `numpy.cumprod` for full documentation.
     |      
     |      Notes
     |      -----
     |      The mask is lost if `out` is not a valid MaskedArray !
     |      
     |      Arithmetic is modular when using integer types, and no error is
     |      raised on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.cumprod : corresponding function for ndarrays
     |      numpy.cumprod : equivalent function
     |  
     |  ccuummssuumm(self, axis=None, dtype=None, out=None)
     |      Return the cumulative sum of the array elements over the given axis.
     |      
     |      Masked values are set to 0 internally during the computation.
     |      However, their position is saved, and the result will be masked at
     |      the same locations.
     |      
     |      Refer to `numpy.cumsum` for full documentation.
     |      
     |      Notes
     |      -----
     |      The mask is lost if `out` is not a valid :class:`MaskedArray` !
     |      
     |      Arithmetic is modular when using integer types, and no error is
     |      raised on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.cumsum : corresponding function for ndarrays
     |      numpy.cumsum : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
     |      >>> print(marr.cumsum())
     |      [0 1 3 -- -- -- 9 16 24 33]
     |  
     |  ddiiaaggoonnaall(self, *args, **params)
     |      a.diagonal(offset=0, axis1=0, axis2=1)
     |      
     |      Return specified diagonals. In NumPy 1.9 the returned array is a
     |      read-only view instead of a copy as in previous NumPy versions.  In
     |      a future version the read-only restriction will be removed.
     |      
     |      Refer to :func:`numpy.diagonal` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.diagonal : equivalent function
     |  
     |  ddoott(self, b, out=None, strict=False)
     |      a.dot(b, out=None)
     |      
     |      Masked dot product of two arrays. Note that `out` and `strict` are
     |      located in different positions than in `ma.dot`. In order to
     |      maintain compatibility with the functional version, it is
     |      recommended that the optional arguments be treated as keyword only.
     |      At some point that may be mandatory.
     |      
     |      .. versionadded:: 1.10.0
     |      
     |      Parameters
     |      ----------
     |      b : masked_array_like
     |          Inputs array.
     |      out : masked_array, optional
     |          Output argument. This must have the exact kind that would be
     |          returned if it was not used. In particular, it must have the
     |          right type, must be C-contiguous, and its dtype must be the
     |          dtype that would be returned for `ma.dot(a,b)`. This is a
     |          performance feature. Therefore, if these conditions are not
     |          met, an exception is raised, instead of attempting to be
     |          flexible.
     |      strict : bool, optional
     |          Whether masked data are propagated (True) or set to 0 (False)
     |          for the computation. Default is False.  Propagating the mask
     |          means that if a masked value appears in a row or column, the
     |          whole row or column is considered masked.
     |      
     |          .. versionadded:: 1.10.2
     |      
     |      See Also
     |      --------
     |      numpy.ma.dot : equivalent function
     |  
     |  ffiilllleedd(self, fill_value=None)
     |      Return a copy of self, with masked values filled with a given value.
     |      **However**, if there are no masked values to fill, self will be
     |      returned instead as an ndarray.
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          The value to use for invalid entries (None by default).
     |          If None, the `fill_value` attribute of the array is used instead.
     |      
     |      Returns
     |      -------
     |      filled_array : ndarray
     |          A copy of ``self`` with invalid entries replaced by *fill_value*
     |          (be it the function argument or the attribute of ``self``), or
     |          ``self`` itself as an ndarray if there are no invalid entries to
     |          be replaced.
     |      
     |      Notes
     |      -----
     |      The result is **not** a MaskedArray!
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
     |      >>> x.filled()
     |      array([1, 2, -999, 4, -999])
     |      >>> type(x.filled())
     |      <type 'numpy.ndarray'>
     |      
     |      Subclassing is preserved. This means that if the data part of the masked
     |      array is a matrix, `filled` returns a matrix:
     |      
     |      >>> x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
     |      >>> x.filled()
     |      matrix([[     1, 999999],
     |              [999999,      4]])
     |  
     |  ffllaatttteenn(self, *args, **params)
     |      a.flatten(order='C')
     |      
     |      Return a copy of the array collapsed into one dimension.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          'C' means to flatten in row-major (C-style) order.
     |          'F' means to flatten in column-major (Fortran-
     |          style) order. 'A' means to flatten in column-major
     |          order if `a` is Fortran *contiguous* in memory,
     |          row-major order otherwise. 'K' means to flatten
     |          `a` in the order the elements occur in memory.
     |          The default is 'C'.
     |      
     |      Returns
     |      -------
     |      y : ndarray
     |          A copy of the input array, flattened to one dimension.
     |      
     |      See Also
     |      --------
     |      ravel : Return a flattened array.
     |      flat : A 1-D flat iterator over the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1,2], [3,4]])
     |      >>> a.flatten()
     |      array([1, 2, 3, 4])
     |      >>> a.flatten('F')
     |      array([1, 3, 2, 4])
     |  
     |  ggeett__ffiillll__vvaalluuee(self)
     |      Return the filling value of the masked array.
     |      
     |      Returns
     |      -------
     |      fill_value : scalar
     |          The filling value.
     |      
     |      Examples
     |      --------
     |      >>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
     |      ...     np.ma.array([0, 1], dtype=dt).get_fill_value()
     |      ...
     |      999999
     |      999999
     |      1e+20
     |      (1e+20+0j)
     |      
     |      >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
     |      >>> x.get_fill_value()
     |      -inf
     |  
     |  ggeett__iimmaagg(self)
     |      Return the imaginary part of the masked array.
     |      
     |      The returned array is a view on the imaginary part of the `MaskedArray`
     |      whose `get_imag` method is called.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          The imaginary part of the masked array.
     |      
     |      See Also
     |      --------
     |      get_real, real, imag
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
     |      >>> x.get_imag()
     |      masked_array(data = [1.0 -- 1.6],
     |                   mask = [False  True False],
     |             fill_value = 1e+20)
     |  
     |  ggeett__rreeaall(self)
     |      Return the real part of the masked array.
     |      
     |      The returned array is a view on the real part of the `MaskedArray`
     |      whose `get_real` method is called.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          The real part of the masked array.
     |      
     |      See Also
     |      --------
     |      get_imag, real, imag
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
     |      >>> x.get_real()
     |      masked_array(data = [1.0 -- 3.45],
     |                   mask = [False  True False],
     |             fill_value = 1e+20)
     |  
     |  hhaarrddeenn__mmaasskk(self)
     |      Force the mask to hard.
     |      
     |      Whether the mask of a masked array is hard or soft is determined by
     |      its `hardmask` property. `harden_mask` sets `hardmask` to True.
     |      
     |      See Also
     |      --------
     |      hardmask
     |  
     |  iiddss(self)
     |      Return the addresses of the data and mask areas.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
     |      >>> x.ids()
     |      (166670640, 166659832)
     |      
     |      If the array has no mask, the address of `nomask` is returned. This address
     |      is typically not close to the data in memory:
     |      
     |      >>> x = np.ma.array([1, 2, 3])
     |      >>> x.ids()
     |      (166691080, 3083169284L)
     |  
     |  iissccoonnttiigguuoouuss(self)
     |      Return a boolean indicating whether the data is contiguous.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1, 2, 3])
     |      >>> x.iscontiguous()
     |      True
     |      
     |      `iscontiguous` returns one of the flags of the masked array:
     |      
     |      >>> x.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : True
     |        OWNDATA : False
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |  
     |  mmaaxx(self, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the maximum along a given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to operate.  By default, ``axis`` is None and the
     |          flattened input is used.
     |      out : array_like, optional
     |          Alternative output array in which to place the result.  Must
     |          be of the same shape and buffer length as the expected output.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |          If None, use the output of maximum_fill_value().
     |      
     |      Returns
     |      -------
     |      amax : array_like
     |          New array holding the result.
     |          If ``out`` was specified, ``out`` is returned.
     |      
     |      See Also
     |      --------
     |      maximum_fill_value
     |          Returns the maximum filling value for a given datatype.
     |  
     |  mmeeaann(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns the average of the array elements along given axis.
     |      
     |      Masked entries are ignored, and result elements which are not
     |      finite will be masked.
     |      
     |      Refer to `numpy.mean` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.mean : corresponding function for ndarrays
     |      numpy.mean : Equivalent function
     |      numpy.ma.average: Weighted average.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([1,2,3], mask=[False, False, True])
     |      >>> a
     |      masked_array(data = [1 2 --],
     |                   mask = [False False  True],
     |             fill_value = 999999)
     |      >>> a.mean()
     |      1.5
     |  
     |  mmiinn(self, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the minimum along a given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to operate.  By default, ``axis`` is None and the
     |          flattened input is used.
     |      out : array_like, optional
     |          Alternative output array in which to place the result.  Must be of
     |          the same shape and buffer length as the expected output.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |          If None, use the output of `minimum_fill_value`.
     |      
     |      Returns
     |      -------
     |      amin : array_like
     |          New array holding the result.
     |          If ``out`` was specified, ``out`` is returned.
     |      
     |      See Also
     |      --------
     |      minimum_fill_value
     |          Returns the minimum filling value for a given datatype.
     |  
     |  mmiinnii(self, axis=None)
     |      Return the array minimum along the specified axis.
     |      
     |      .. deprecated:: 1.13.0
     |         This function is identical to both:
     |      
     |          * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
     |          * ``np.ma.minimum.reduce(self, axis=axis)``
     |      
     |         Typically though, ``self.min(axis=axis)`` is sufficient.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          The axis along which to find the minima. Default is None, in which case
     |          the minimum value in the whole array is returned.
     |      
     |      Returns
     |      -------
     |      min : scalar or MaskedArray
     |          If `axis` is None, the result is a scalar. Otherwise, if `axis` is
     |          given and the array is at least 2-D, the result is a masked array with
     |          dimension one smaller than the array on which `mini` is called.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
     |      >>> print(x)
     |      [[0 --]
     |       [2 3]
     |       [4 --]]
     |      >>> x.mini()
     |      0
     |      >>> x.mini(axis=0)
     |      masked_array(data = [0 3],
     |                   mask = [False False],
     |             fill_value = 999999)
     |      >>> print(x.mini(axis=1))
     |      [0 2 4]
     |      
     |      There is a small difference between `mini` and `min`:
     |      
     |      >>> x[:,1].mini(axis=0)
     |      masked_array(data = --,
     |                   mask = True,
     |             fill_value = 999999)
     |      >>> x[:,1].min(axis=0)
     |      masked
     |  
     |  nnoonnzzeerroo(self)
     |      Return the indices of unmasked elements that are not zero.
     |      
     |      Returns a tuple of arrays, one for each dimension, containing the
     |      indices of the non-zero elements in that dimension. The corresponding
     |      non-zero values can be obtained with::
     |      
     |          a[a.nonzero()]
     |      
     |      To group the indices by element, rather than dimension, use
     |      instead::
     |      
     |          np.transpose(a.nonzero())
     |      
     |      The result of this is always a 2d array, with a row for each non-zero
     |      element.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      tuple_of_arrays : tuple
     |          Indices of elements that are non-zero.
     |      
     |      See Also
     |      --------
     |      numpy.nonzero :
     |          Function operating on ndarrays.
     |      flatnonzero :
     |          Return indices that are non-zero in the flattened version of the input
     |          array.
     |      ndarray.nonzero :
     |          Equivalent ndarray method.
     |      count_nonzero :
     |          Counts the number of non-zero elements in the input array.
     |      
     |      Examples
     |      --------
     |      >>> import numpy.ma as ma
     |      >>> x = ma.array(np.eye(3))
     |      >>> x
     |      masked_array(data =
     |       [[ 1.  0.  0.]
     |       [ 0.  1.  0.]
     |       [ 0.  0.  1.]],
     |            mask =
     |       False,
     |            fill_value=1e+20)
     |      >>> x.nonzero()
     |      (array([0, 1, 2]), array([0, 1, 2]))
     |      
     |      Masked elements are ignored.
     |      
     |      >>> x[1, 1] = ma.masked
     |      >>> x
     |      masked_array(data =
     |       [[1.0 0.0 0.0]
     |       [0.0 -- 0.0]
     |       [0.0 0.0 1.0]],
     |            mask =
     |       [[False False False]
     |       [False  True False]
     |       [False False False]],
     |            fill_value=1e+20)
     |      >>> x.nonzero()
     |      (array([0, 2]), array([0, 2]))
     |      
     |      Indices can also be grouped by element.
     |      
     |      >>> np.transpose(x.nonzero())
     |      array([[0, 0],
     |             [2, 2]])
     |      
     |      A common use for ``nonzero`` is to find the indices of an array, where
     |      a condition is True.  Given an array `a`, the condition `a` > 3 is a
     |      boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
     |      yields the indices of the `a` where the condition is true.
     |      
     |      >>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
     |      >>> a > 3
     |      masked_array(data =
     |       [[False False False]
     |       [ True  True  True]
     |       [ True  True  True]],
     |            mask =
     |       False,
     |            fill_value=999999)
     |      >>> ma.nonzero(a > 3)
     |      (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
     |      
     |      The ``nonzero`` method of the condition array can also be called.
     |      
     |      >>> (a > 3).nonzero()
     |      (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
     |  
     |  ppaarrttiittiioonn(self, *args, **kwargs)
     |      a.partition(kth, axis=-1, kind='introselect', order=None)
     |      
     |      Rearranges the elements in the array in such a way that value of the
     |      element in kth position is in the position it would be in a sorted array.
     |      All elements smaller than the kth element are moved before this element and
     |      all equal or greater are moved behind it. The ordering of the elements in
     |      the two partitions is undefined.
     |      
     |      .. versionadded:: 1.8.0
     |      
     |      Parameters
     |      ----------
     |      kth : int or sequence of ints
     |          Element index to partition by. The kth element value will be in its
     |          final sorted position and all smaller elements will be moved before it
     |          and all equal or greater elements behind it.
     |          The order all elements in the partitions is undefined.
     |          If provided with a sequence of kth it will partition all elements
     |          indexed by kth of them into their sorted position at once.
     |      axis : int, optional
     |          Axis along which to sort. Default is -1, which means sort along the
     |          last axis.
     |      kind : {'introselect'}, optional
     |          Selection algorithm. Default is 'introselect'.
     |      order : str or list of str, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  A single field can
     |          be specified as a string, and not all fields need be specified,
     |          but unspecified fields will still be used, in the order in which
     |          they come up in the dtype, to break ties.
     |      
     |      See Also
     |      --------
     |      numpy.partition : Return a parititioned copy of an array.
     |      argpartition : Indirect partition.
     |      sort : Full sort.
     |      
     |      Notes
     |      -----
     |      See ``np.partition`` for notes on the different algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([3, 4, 2, 1])
     |      >>> a.partition(3)
     |      >>> a
     |      array([2, 1, 3, 4])
     |      
     |      >>> a.partition((1, 3))
     |      array([1, 2, 3, 4])
     |  
     |  pprroodd(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the product of the array elements over the given axis.
     |      
     |      Masked elements are set to 1 internally for computation.
     |      
     |      Refer to `numpy.prod` for full documentation.
     |      
     |      Notes
     |      -----
     |      Arithmetic is modular when using integer types, and no error is raised
     |      on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.prod : corresponding function for ndarrays
     |      numpy.prod : equivalent function
     |  
     |  pprroodduucctt = prod(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |  
     |  ppttpp(self, axis=None, out=None, fill_value=None)
     |      Return (maximum - minimum) along the given dimension
     |      (i.e. peak-to-peak value).
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to find the peaks.  If None (default) the
     |          flattened array is used.
     |      out : {None, array_like}, optional
     |          Alternative output array in which to place the result. It must
     |          have the same shape and buffer length as the expected output
     |          but the type will be cast if necessary.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |      
     |      Returns
     |      -------
     |      ptp : ndarray.
     |          A new array holding the result, unless ``out`` was
     |          specified, in which case a reference to ``out`` is returned.
     |  
     |  ppuutt(self, indices, values, mode='raise')
     |      Set storage-indexed locations to corresponding values.
     |      
     |      Sets self._data.flat[n] = values[n] for each n in indices.
     |      If `values` is shorter than `indices` then it will repeat.
     |      If `values` has some masked values, the initial mask is updated
     |      in consequence, else the corresponding values are unmasked.
     |      
     |      Parameters
     |      ----------
     |      indices : 1-D array_like
     |          Target indices, interpreted as integers.
     |      values : array_like
     |          Values to place in self._data copy at target indices.
     |      mode : {'raise', 'wrap', 'clip'}, optional
     |          Specifies how out-of-bounds indices will behave.
     |          'raise' : raise an error.
     |          'wrap' : wrap around.
     |          'clip' : clip to the range.
     |      
     |      Notes
     |      -----
     |      `values` can be a scalar or length 1 array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> x.put([0,4,8],[10,20,30])
     |      >>> print(x)
     |      [[10 -- 3]
     |       [-- 20 --]
     |       [7 -- 30]]
     |      
     |      >>> x.put(4,999)
     |      >>> print(x)
     |      [[10 -- 3]
     |       [-- 999 --]
     |       [7 -- 30]]
     |  
     |  rraavveell(self, order='C')
     |      Returns a 1D version of self, as a view.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          The elements of `a` are read using this index order. 'C' means to
     |          index the elements in C-like order, with the last axis index
     |          changing fastest, back to the first axis index changing slowest.
     |          'F' means to index the elements in Fortran-like index order, with
     |          the first index changing fastest, and the last index changing
     |          slowest. Note that the 'C' and 'F' options take no account of the
     |          memory layout of the underlying array, and only refer to the order
     |          of axis indexing.  'A' means to read the elements in Fortran-like
     |          index order if `m` is Fortran *contiguous* in memory, C-like order
     |          otherwise.  'K' means to read the elements in the order they occur
     |          in memory, except for reversing the data when strides are negative.
     |          By default, 'C' index order is used.
     |      
     |      Returns
     |      -------
     |      MaskedArray
     |          Output view is of shape ``(self.size,)`` (or
     |          ``(np.ma.product(self.shape),)``).
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.ravel())
     |      [1 -- 3 -- 5 -- 7 -- 9]
     |  
     |  rreeppeeaatt(self, *args, **params)
     |      a.repeat(repeats, axis=None)
     |      
     |      Repeat elements of an array.
     |      
     |      Refer to `numpy.repeat` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.repeat : equivalent function
     |  
     |  rreesshhaappee(self, *s, **kwargs)
     |      Give a new shape to the array without changing its data.
     |      
     |      Returns a masked array containing the same data, but with a new shape.
     |      The result is a view on the original array; if this is not possible, a
     |      ValueError is raised.
     |      
     |      Parameters
     |      ----------
     |      shape : int or tuple of ints
     |          The new shape should be compatible with the original shape. If an
     |          integer is supplied, then the result will be a 1-D array of that
     |          length.
     |      order : {'C', 'F'}, optional
     |          Determines whether the array data should be viewed as in C
     |          (row-major) or FORTRAN (column-major) order.
     |      
     |      Returns
     |      -------
     |      reshaped_array : array
     |          A new view on the array.
     |      
     |      See Also
     |      --------
     |      reshape : Equivalent function in the masked array module.
     |      numpy.ndarray.reshape : Equivalent method on ndarray object.
     |      numpy.reshape : Equivalent function in the NumPy module.
     |      
     |      Notes
     |      -----
     |      The reshaping operation cannot guarantee that a copy will not be made,
     |      to modify the shape in place, use ``a.shape = s``
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
     |      >>> print(x)
     |      [[-- 2]
     |       [3 --]]
     |      >>> x = x.reshape((4,1))
     |      >>> print(x)
     |      [[--]
     |       [2]
     |       [3]
     |       [--]]
     |  
     |  rreessiizzee(self, newshape, refcheck=True, order=False)
     |      .. warning::
     |      
     |          This method does nothing, except raise a ValueError exception. A
     |          masked array does not own its data and therefore cannot safely be
     |          resized in place. Use the `numpy.ma.resize` function instead.
     |      
     |      This method is difficult to implement safely and may be deprecated in
     |      future releases of NumPy.
     |  
     |  rroouunndd(self, decimals=0, out=None)
     |      Return each element rounded to the given number of decimals.
     |      
     |      Refer to `numpy.around` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.around : corresponding function for ndarrays
     |      numpy.around : equivalent function
     |  
     |  sseett__ffiillll__vvaalluuee(self, value=None)
     |      Set the filling value of the masked array.
     |      
     |      Parameters
     |      ----------
     |      value : scalar, optional
     |          The new filling value. Default is None, in which case a default
     |          based on the data type is used.
     |      
     |      See Also
     |      --------
     |      ma.set_fill_value : Equivalent function.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
     |      >>> x.fill_value
     |      -inf
     |      >>> x.set_fill_value(np.pi)
     |      >>> x.fill_value
     |      3.1415926535897931
     |      
     |      Reset to default:
     |      
     |      >>> x.set_fill_value()
     |      >>> x.fill_value
     |      1e+20
     |  
     |  sshhrriinnkk__mmaasskk(self)
     |      Reduce a mask to nomask when possible.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
     |      >>> x.mask
     |      array([[False, False],
     |             [False, False]], dtype=bool)
     |      >>> x.shrink_mask()
     |      >>> x.mask
     |      False
     |  
     |  ssoofftteenn__mmaasskk(self)
     |      Force the mask to soft.
     |      
     |      Whether the mask of a masked array is hard or soft is determined by
     |      its `hardmask` property. `soften_mask` sets `hardmask` to False.
     |      
     |      See Also
     |      --------
     |      hardmask
     |  
     |  ssoorrtt(self, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)
     |      Sort the array, in-place
     |      
     |      Parameters
     |      ----------
     |      a : array_like
     |          Array to be sorted.
     |      axis : int, optional
     |          Axis along which to sort. If None, the array is flattened before
     |          sorting. The default is -1, which sorts along the last axis.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm. Default is 'quicksort'.
     |      order : list, optional
     |          When `a` is a structured array, this argument specifies which fields
     |          to compare first, second, and so on.  This list does not need to
     |          include all of the fields.
     |      endwith : {True, False}, optional
     |          Whether missing values (if any) should be treated as the largest values
     |          (True) or the smallest values (False)
     |          When the array contains unmasked values at the same extremes of the
     |          datatype, the ordering of these values and the masked values is
     |          undefined.
     |      fill_value : {var}, optional
     |          Value used internally for the masked values.
     |          If ``fill_value`` is not None, it supersedes ``endwith``.
     |      
     |      Returns
     |      -------
     |      sorted_array : ndarray
     |          Array of the same type and shape as `a`.
     |      
     |      See Also
     |      --------
     |      ndarray.sort : Method to sort an array in-place.
     |      argsort : Indirect sort.
     |      lexsort : Indirect stable sort on multiple keys.
     |      searchsorted : Find elements in a sorted array.
     |      
     |      Notes
     |      -----
     |      See ``sort`` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # Default
     |      >>> a.sort()
     |      >>> print(a)
     |      [1 3 5 -- --]
     |      
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # Put missing values in the front
     |      >>> a.sort(endwith=False)
     |      >>> print(a)
     |      [-- -- 1 3 5]
     |      
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # fill_value takes over endwith
     |      >>> a.sort(endwith=False, fill_value=3)
     |      >>> print(a)
     |      [1 -- -- 3 5]
     |  
     |  ssqquueeeezzee(self, *args, **params)
     |      a.squeeze(axis=None)
     |      
     |      Remove single-dimensional entries from the shape of `a`.
     |      
     |      Refer to `numpy.squeeze` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.squeeze : equivalent function
     |  
     |  ssttdd(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns the standard deviation of the array elements along given axis.
     |      
     |      Masked entries are ignored.
     |      
     |      Refer to `numpy.std` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.std : corresponding function for ndarrays
     |      numpy.std : Equivalent function
     |  
     |  ssuumm(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the sum of the array elements over the given axis.
     |      
     |      Masked elements are set to 0 internally.
     |      
     |      Refer to `numpy.sum` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.sum : corresponding function for ndarrays
     |      numpy.sum : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.sum())
     |      25
     |      >>> print(x.sum(axis=1))
     |      [4 5 16]
     |      >>> print(x.sum(axis=0))
     |      [8 5 12]
     |      >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
     |      <type 'numpy.int64'>
     |  
     |  sswwaappaaxxeess(self, *args, **params)
     |      a.swapaxes(axis1, axis2)
     |      
     |      Return a view of the array with `axis1` and `axis2` interchanged.
     |      
     |      Refer to `numpy.swapaxes` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.swapaxes : equivalent function
     |  
     |  ttaakkee(self, indices, axis=None, out=None, mode='raise')
     |  
     |  ttoobbyytteess(self, fill_value=None, order='C')
     |      Return the array data as a string containing the raw bytes in the array.
     |      
     |      The array is filled with a fill value before the string conversion.
     |      
     |      .. versionadded:: 1.9.0
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          Value used to fill in the masked values. Default is None, in which
     |          case `MaskedArray.fill_value` is used.
     |      order : {'C','F','A'}, optional
     |          Order of the data item in the copy. Default is 'C'.
     |      
     |          - 'C'   -- C order (row major).
     |          - 'F'   -- Fortran order (column major).
     |          - 'A'   -- Any, current order of array.
     |          - None  -- Same as 'A'.
     |      
     |      See Also
     |      --------
     |      ndarray.tobytes
     |      tolist, tofile
     |      
     |      Notes
     |      -----
     |      As for `ndarray.tobytes`, information about the shape, dtype, etc.,
     |      but also about `fill_value`, will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
     |      >>> x.tobytes()
     |      '\x01\x00\x00\x00?B\x0f\x00?B\x0f\x00\x04\x00\x00\x00'
     |  
     |  ttooffiillee(self, fid, sep='', format='%s')
     |      Save a masked array to a file in binary format.
     |      
     |      .. warning::
     |        This function is not implemented yet.
     |      
     |      Raises
     |      ------
     |      NotImplementedError
     |          When `tofile` is called.
     |  
     |  ttoofflleexx(self)
     |      Transforms a masked array into a flexible-type array.
     |      
     |      The flexible type array that is returned will have two fields:
     |      
     |      * the ``_data`` field stores the ``_data`` part of the array.
     |      * the ``_mask`` field stores the ``_mask`` part of the array.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      record : ndarray
     |          A new flexible-type `ndarray` with two fields: the first element
     |          containing a value, the second element containing the corresponding
     |          mask boolean. The returned record shape matches self.shape.
     |      
     |      Notes
     |      -----
     |      A side-effect of transforming a masked array into a flexible `ndarray` is
     |      that meta information (``fill_value``, ...) will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.toflex())
     |      [[(1, False) (2, True) (3, False)]
     |       [(4, True) (5, False) (6, True)]
     |       [(7, False) (8, True) (9, False)]]
     |  
     |  ttoolliisstt(self, fill_value=None)
     |      Return the data portion of the masked array as a hierarchical Python list.
     |      
     |      Data items are converted to the nearest compatible Python type.
     |      Masked values are converted to `fill_value`. If `fill_value` is None,
     |      the corresponding entries in the output list will be ``None``.
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          The value to use for invalid entries. Default is None.
     |      
     |      Returns
     |      -------
     |      result : list
     |          The Python list representation of the masked array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
     |      >>> x.tolist()
     |      [[1, None, 3], [None, 5, None], [7, None, 9]]
     |      >>> x.tolist(-999)
     |      [[1, -999, 3], [-999, 5, -999], [7, -999, 9]]
     |  
     |  ttoorreeccoorrddss = toflex(self)
     |  
     |  ttoossttrriinngg(self, fill_value=None, order='C')
     |      This function is a compatibility alias for tobytes. Despite its name it
     |      returns bytes not strings.
     |  
     |  ttrraaccee(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      
     |      Return the sum along diagonals of the array.
     |      
     |      Refer to `numpy.trace` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.trace : equivalent function
     |  
     |  ttrraannssppoossee(self, *args, **params)
     |      a.transpose(*axes)
     |      
     |      Returns a view of the array with axes transposed.
     |      
     |      For a 1-D array, this has no effect. (To change between column and
     |      row vectors, first cast the 1-D array into a matrix object.)
     |      For a 2-D array, this is the usual matrix transpose.
     |      For an n-D array, if axes are given, their order indicates how the
     |      axes are permuted (see Examples). If axes are not provided and
     |      ``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
     |      ``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.
     |      
     |      Parameters
     |      ----------
     |      axes : None, tuple of ints, or `n` ints
     |      
     |       * None or no argument: reverses the order of the axes.
     |      
     |       * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
     |         `i`-th axis becomes `a.transpose()`'s `j`-th axis.
     |      
     |       * `n` ints: same as an n-tuple of the same ints (this form is
     |         intended simply as a "convenience" alternative to the tuple form)
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          View of `a`, with axes suitably permuted.
     |      
     |      See Also
     |      --------
     |      ndarray.T : Array property returning the array transposed.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> a
     |      array([[1, 2],
     |             [3, 4]])
     |      >>> a.transpose()
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose((1, 0))
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose(1, 0)
     |      array([[1, 3],
     |             [2, 4]])
     |  
     |  uunnsshhaarree__mmaasskk(self)
     |      Copy the mask and set the sharedmask flag to False.
     |      
     |      Whether the mask is shared between masked arrays can be seen from
     |      the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
     |      A copy of the mask is only made if it was shared.
     |      
     |      See Also
     |      --------
     |      sharedmask
     |  
     |  vvaarr(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class 'numpy._globals._NoValue'>)
     |      Compute the variance along the specified axis.
     |      
     |      Returns the variance of the array elements, a measure of the spread of a
     |      distribution.  The variance is computed for the flattened array by
     |      default, otherwise over the specified axis.
     |      
     |      Parameters
     |      ----------
     |      a : array_like
     |          Array containing numbers whose variance is desired.  If `a` is not an
     |          array, a conversion is attempted.
     |      axis : None or int or tuple of ints, optional
     |          Axis or axes along which the variance is computed.  The default is to
     |          compute the variance of the flattened array.
     |      
     |          .. versionadded:: 1.7.0
     |      
     |          If this is a tuple of ints, a variance is performed over multiple axes,
     |          instead of a single axis or all the axes as before.
     |      dtype : data-type, optional
     |          Type to use in computing the variance.  For arrays of integer type
     |          the default is `float32`; for arrays of float types it is the same as
     |          the array type.
     |      out : ndarray, optional
     |          Alternate output array in which to place the result.  It must have
     |          the same shape as the expected output, but the type is cast if
     |          necessary.
     |      ddof : int, optional
     |          "Delta Degrees of Freedom": the divisor used in the calculation is
     |          ``N - ddof``, where ``N`` represents the number of elements. By
     |          default `ddof` is zero.
     |      keepdims : bool, optional
     |          If this is set to True, the axes which are reduced are left
     |          in the result as dimensions with size one. With this option,
     |          the result will broadcast correctly against the input array.
     |      
     |          If the default value is passed, then `keepdims` will not be
     |          passed through to the `var` method of sub-classes of
     |          `ndarray`, however any non-default value will be.  If the
     |          sub-classes `sum` method does not implement `keepdims` any
     |          exceptions will be raised.
     |      
     |      Returns
     |      -------
     |      variance : ndarray, see dtype parameter above
     |          If ``out=None``, returns a new array containing the variance;
     |          otherwise, a reference to the output array is returned.
     |      
     |      See Also
     |      --------
     |      std , mean, nanmean, nanstd, nanvar
     |      numpy.doc.ufuncs : Section "Output arguments"
     |      
     |      Notes
     |      -----
     |      The variance is the average of the squared deviations from the mean,
     |      i.e.,  ``var = mean(abs(x - x.mean())**2)``.
     |      
     |      The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
     |      If, however, `ddof` is specified, the divisor ``N - ddof`` is used
     |      instead.  In standard statistical practice, ``ddof=1`` provides an
     |      unbiased estimator of the variance of a hypothetical infinite population.
     |      ``ddof=0`` provides a maximum likelihood estimate of the variance for
     |      normally distributed variables.
     |      
     |      Note that for complex numbers, the absolute value is taken before
     |      squaring, so that the result is always real and nonnegative.
     |      
     |      For floating-point input, the variance is computed using the same
     |      precision the input has.  Depending on the input data, this can cause
     |      the results to be inaccurate, especially for `float32` (see example
     |      below).  Specifying a higher-accuracy accumulator using the ``dtype``
     |      keyword can alleviate this issue.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> np.var(a)
     |      1.25
     |      >>> np.var(a, axis=0)
     |      array([ 1.,  1.])
     |      >>> np.var(a, axis=1)
     |      array([ 0.25,  0.25])
     |      
     |      In single precision, var() can be inaccurate:
     |      
     |      >>> a = np.zeros((2, 512*512), dtype=np.float32)
     |      >>> a[0, :] = 1.0
     |      >>> a[1, :] = 0.1
     |      >>> np.var(a)
     |      0.20250003
     |      
     |      Computing the variance in float64 is more accurate:
     |      
     |      >>> np.var(a, dtype=np.float64)
     |      0.20249999932944759
     |      >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
     |      0.2025
     |  
     |  vviieeww(self, dtype=None, type=None, fill_value=None)
     |      a.view(dtype=None, type=None)
     |      
     |      New view of array with the same data.
     |      
     |      Parameters
     |      ----------
     |      dtype : data-type or ndarray sub-class, optional
     |          Data-type descriptor of the returned view, e.g., float32 or int16. The
     |          default, None, results in the view having the same data-type as `a`.
     |          This argument can also be specified as an ndarray sub-class, which
     |          then specifies the type of the returned object (this is equivalent to
     |          setting the ``type`` parameter).
     |      type : Python type, optional
     |          Type of the returned view, e.g., ndarray or matrix.  Again, the
     |          default None results in type preservation.
     |      
     |      Notes
     |      -----
     |      ``a.view()`` is used two different ways:
     |      
     |      ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
     |      of the array's memory with a different data-type.  This can cause a
     |      reinterpretation of the bytes of memory.
     |      
     |      ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
     |      returns an instance of `ndarray_subclass` that looks at the same array
     |      (same shape, dtype, etc.)  This does not cause a reinterpretation of the
     |      memory.
     |      
     |      For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
     |      bytes per entry than the previous dtype (for example, converting a
     |      regular array to a structured array), then the behavior of the view
     |      cannot be predicted just from the superficial appearance of ``a`` (shown
     |      by ``print(a)``). It also depends on exactly how ``a`` is stored in
     |      memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
     |      defined as a slice or transpose, etc., the view may give different
     |      results.
     |      
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])
     |      
     |      Viewing array data using a different type and dtype:
     |      
     |      >>> y = x.view(dtype=np.int16, type=np.matrix)
     |      >>> y
     |      matrix([[513]], dtype=int16)
     |      >>> print(type(y))
     |      <class 'numpy.matrixlib.defmatrix.matrix'>
     |      
     |      Creating a view on a structured array so it can be used in calculations
     |      
     |      >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
     |      >>> xv = x.view(dtype=np.int8).reshape(-1,2)
     |      >>> xv
     |      array([[1, 2],
     |             [3, 4]], dtype=int8)
     |      >>> xv.mean(0)
     |      array([ 2.,  3.])
     |      
     |      Making changes to the view changes the underlying array
     |      
     |      >>> xv[0,1] = 20
     |      >>> print(x)
     |      [(1, 20) (3, 4)]
     |      
     |      Using a view to convert an array to a recarray:
     |      
     |      >>> z = x.view(np.recarray)
     |      >>> z.a
     |      array([1], dtype=int8)
     |      
     |      Views share data:
     |      
     |      >>> x[0] = (9, 10)
     |      >>> z[0]
     |      (9, 10)
     |      
     |      Views that change the dtype size (bytes per entry) should normally be
     |      avoided on arrays defined by slices, transposes, fortran-ordering, etc.:
     |      
     |      >>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
     |      >>> y = x[:, 0:2]
     |      >>> y
     |      array([[1, 2],
     |             [4, 5]], dtype=int16)
     |      >>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: new type not compatible with array.
     |      >>> z = y.copy()
     |      >>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
     |      array([[(1, 2)],
     |             [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  ____nneeww____(cls, data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None, **options)
     |      Create a new masked array from scratch.
     |      
     |      Notes
     |      -----
     |      A masked array can also be created by taking a .view(MaskedArray).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  TT
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  bbaasseeccllaassss
     |      Class of the underlying data (read-only).
     |  
     |  ddaattaa
     |      Return the current data, as a view of the original
     |      underlying data.
     |  
     |  ffiillll__vvaalluuee
     |      Filling value.
     |  
     |  ffllaatt
     |      Flat version of the array.
     |  
     |  hhaarrddmmaasskk
     |      Hardness of the mask
     |  
     |  iimmaagg
     |      Imaginary part.
     |  
     |  mmaasskk
     |      Mask
     |  
     |  rreeaall
     |      Real part
     |  
     |  rreeccoorrddmmaasskk
     |      Return the mask of the records.
     |      
     |      A record is masked when all the fields are masked.
     |  
     |  sshhaarreeddmmaasskk
     |      Share status of the mask (read-only).
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aarrrraayy__pprriioorriittyy____ = 15
     |  
     |  ____hhaasshh____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from numpy.ndarray:
     |  
     |  ____aabbss____(self, /)
     |      abs(self)
     |  
     |  ____aanndd____(self, value, /)
     |      Return self&value.
     |  
     |  ____aarrrraayy____(...)
     |      a.__array__(|dtype) -> reference if type unchanged, copy otherwise.
     |      
     |      Returns either a new reference to self if dtype is not given or a new array
     |      of provided data type if dtype is different from the current dtype of the
     |      array.
     |  
     |  ____aarrrraayy__pprreeppaarree____(...)
     |      a.__array_prepare__(obj) -> Object of same type as ndarray object obj.
     |  
     |  ____aarrrraayy__uuffuunncc____(...)
     |  
     |  ____bbooooll____(self, /)
     |      self != 0
     |  
     |  ____ccoommpplleexx____(...)
     |  
     |  ____ccoonnttaaiinnss____(self, key, /)
     |      Return key in self.
     |  
     |  ____ccooppyy____(...)
     |      a.__copy__([order])
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A'}, optional
     |          If order is 'C' (False) then the result is contiguous (default).
     |          If order is 'Fortran' (True) then the result has fortran order.
     |          If order is 'Any' (None) then the result has fortran order
     |          only if the array already is in fortran order.
     |  
     |  ____ddeelliitteemm____(self, key, /)
     |      Delete self[key].
     |  
     |  ____ddiivvmmoodd____(self, value, /)
     |      Return divmod(self, value).
     |  
     |  ____ggee____(self, value, /)
     |      Return self>=value.
     |  
     |  ____ggtt____(self, value, /)
     |      Return self>value.
     |  
     |  ____iiaanndd____(self, value, /)
     |      Return self&=value.
     |  
     |  ____iillsshhiifftt____(self, value, /)
     |      Return self<<=value.
     |  
     |  ____iimmaattmmuull____(self, value, /)
     |      Return self@=value.
     |  
     |  ____iimmoodd____(self, value, /)
     |      Return self%=value.
     |  
     |  ____iinnddeexx____(self, /)
     |      Return self converted to an integer, if self is suitable for use as an index into a list.
     |  
     |  ____iinnvveerrtt____(self, /)
     |      ~self
     |  
     |  ____iioorr____(self, value, /)
     |      Return self|=value.
     |  
     |  ____iirrsshhiifftt____(self, value, /)
     |      Return self>>=value.
     |  
     |  ____iitteerr____(self, /)
     |      Implement iter(self).
     |  
     |  ____iixxoorr____(self, value, /)
     |      Return self^=value.
     |  
     |  ____llee____(self, value, /)
     |      Return self<=value.
     |  
     |  ____lleenn____(self, /)
     |      Return len(self).
     |  
     |  ____llsshhiifftt____(self, value, /)
     |      Return self<<value.
     |  
     |  ____lltt____(self, value, /)
     |      Return self<value.
     |  
     |  ____mmaattmmuull____(self, value, /)
     |      Return self@value.
     |  
     |  ____mmoodd____(self, value, /)
     |      Return self%value.
     |  
     |  ____nneegg____(self, /)
     |      -self
     |  
     |  ____oorr____(self, value, /)
     |      Return self|value.
     |  
     |  ____ppooss____(self, /)
     |      +self
     |  
     |  ____rraanndd____(self, value, /)
     |      Return value&self.
     |  
     |  ____rrddiivvmmoodd____(self, value, /)
     |      Return divmod(value, self).
     |  
     |  ____rrllsshhiifftt____(self, value, /)
     |      Return value<<self.
     |  
     |  ____rrmmaattmmuull____(self, value, /)
     |      Return value@self.
     |  
     |  ____rrmmoodd____(self, value, /)
     |      Return value%self.
     |  
     |  ____rroorr____(self, value, /)
     |      Return value|self.
     |  
     |  ____rrrrsshhiifftt____(self, value, /)
     |      Return value>>self.
     |  
     |  ____rrsshhiifftt____(self, value, /)
     |      Return self>>value.
     |  
     |  ____rrxxoorr____(self, value, /)
     |      Return value^self.
     |  
     |  ____ssiizzeeooff____(...)
     |      __sizeof__() -> int
     |      size of object in memory, in bytes
     |  
     |  ____xxoorr____(self, value, /)
     |      Return self^value.
     |  
     |  bbyytteesswwaapp(...)
     |      a.byteswap(inplace)
     |      
     |      Swap the bytes of the array elements
     |      
     |      Toggle between low-endian and big-endian data representation by
     |      returning a byteswapped array, optionally swapped in-place.
     |      
     |      Parameters
     |      ----------
     |      inplace : bool, optional
     |          If ``True``, swap bytes in-place, default is ``False``.
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          The byteswapped array. If `inplace` is ``True``, this is
     |          a view to self.
     |      
     |      Examples
     |      --------
     |      >>> A = np.array([1, 256, 8755], dtype=np.int16)
     |      >>> map(hex, A)
     |      ['0x1', '0x100', '0x2233']
     |      >>> A.byteswap(True)
     |      array([  256,     1, 13090], dtype=int16)
     |      >>> map(hex, A)
     |      ['0x100', '0x1', '0x3322']
     |      
     |      Arrays of strings are not swapped
     |      
     |      >>> A = np.array(['ceg', 'fac'])
     |      >>> A.byteswap()
     |      array(['ceg', 'fac'],
     |            dtype='|S3')
     |  
     |  cchhoooossee(...)
     |      a.choose(choices, out=None, mode='raise')
     |      
     |      Use an index array to construct a new array from a set of choices.
     |      
     |      Refer to `numpy.choose` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.choose : equivalent function
     |  
     |  ccoonnjj(...)
     |      a.conj()
     |      
     |      Complex-conjugate all elements.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  ccoonnjjuuggaattee(...)
     |      a.conjugate()
     |      
     |      Return the complex conjugate, element-wise.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  dduummpp(...)
     |      a.dump(file)
     |      
     |      Dump a pickle of the array to the specified file.
     |      The array can be read back with pickle.load or numpy.load.
     |      
     |      Parameters
     |      ----------
     |      file : str
     |          A string naming the dump file.
     |  
     |  dduummppss(...)
     |      a.dumps()
     |      
     |      Returns the pickle of the array as a string.
     |      pickle.loads or numpy.loads will convert the string back to an array.
     |      
     |      Parameters
     |      ----------
     |      None
     |  
     |  ffiillll(...)
     |      a.fill(value)
     |      
     |      Fill the array with a scalar value.
     |      
     |      Parameters
     |      ----------
     |      value : scalar
     |          All elements of `a` will be assigned this value.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([1, 2])
     |      >>> a.fill(0)
     |      >>> a
     |      array([0, 0])
     |      >>> a = np.empty(2)
     |      >>> a.fill(1)
     |      >>> a
     |      array([ 1.,  1.])
     |  
     |  ggeettffiieelldd(...)
     |      a.getfield(dtype, offset=0)
     |      
     |      Returns a field of the given array as a certain type.
     |      
     |      A field is a view of the array data with a given data-type. The values in
     |      the view are determined by the given type and the offset into the current
     |      array in bytes. The offset needs to be such that the view dtype fits in the
     |      array dtype; for example an array of dtype complex128 has 16-byte elements.
     |      If taking a view with a 32-bit integer (4 bytes), the offset needs to be
     |      between 0 and 12 bytes.
     |      
     |      Parameters
     |      ----------
     |      dtype : str or dtype
     |          The data type of the view. The dtype size of the view can not be larger
     |          than that of the array itself.
     |      offset : int
     |          Number of bytes to skip before beginning the element view.
     |      
     |      Examples
     |      --------
     |      >>> x = np.diag([1.+1.j]*2)
     |      >>> x[1, 1] = 2 + 4.j
     |      >>> x
     |      array([[ 1.+1.j,  0.+0.j],
     |             [ 0.+0.j,  2.+4.j]])
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.],
     |             [ 0.,  2.]])
     |      
     |      By choosing an offset of 8 bytes we can select the complex part of the
     |      array for our view:
     |      
     |      >>> x.getfield(np.float64, offset=8)
     |      array([[ 1.,  0.],
     |         [ 0.,  4.]])
     |  
     |  iitteemm(...)
     |      a.item(*args)
     |      
     |      Copy an element of an array to a standard Python scalar and return it.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments (variable number and type)
     |      
     |          * none: in this case, the method only works for arrays
     |            with one element (`a.size == 1`), which element is
     |            copied into a standard Python scalar object and returned.
     |      
     |          * int_type: this argument is interpreted as a flat index into
     |            the array, specifying which element to copy and return.
     |      
     |          * tuple of int_types: functions as does a single int_type argument,
     |            except that the argument is interpreted as an nd-index into the
     |            array.
     |      
     |      Returns
     |      -------
     |      z : Standard Python scalar object
     |          A copy of the specified element of the array as a suitable
     |          Python scalar
     |      
     |      Notes
     |      -----
     |      When the data type of `a` is longdouble or clongdouble, item() returns
     |      a scalar array object because there is no available Python scalar that
     |      would not lose information. Void arrays return a buffer object for item(),
     |      unless fields are defined, in which case a tuple is returned.
     |      
     |      `item` is very similar to a[args], except, instead of an array scalar,
     |      a standard Python scalar is returned. This can be useful for speeding up
     |      access to elements of the array and doing arithmetic on elements of the
     |      array using Python's optimized math.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.item(3)
     |      2
     |      >>> x.item(7)
     |      5
     |      >>> x.item((0, 1))
     |      1
     |      >>> x.item((2, 2))
     |      3
     |  
     |  iitteemmsseett(...)
     |      a.itemset(*args)
     |      
     |      Insert scalar into an array (scalar is cast to array's dtype, if possible)
     |      
     |      There must be at least 1 argument, and define the last argument
     |      as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster
     |      than ``a[args] = item``.  The item should be a scalar value and `args`
     |      must select a single item in the array `a`.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments
     |          If one argument: a scalar, only used in case `a` is of size 1.
     |          If two arguments: the last argument is the value to be set
     |          and must be a scalar, the first argument specifies a single array
     |          element location. It is either an int or a tuple.
     |      
     |      Notes
     |      -----
     |      Compared to indexing syntax, `itemset` provides some speed increase
     |      for placing a scalar into a particular location in an `ndarray`,
     |      if you must do this.  However, generally this is discouraged:
     |      among other problems, it complicates the appearance of the code.
     |      Also, when using `itemset` (and `item`) inside a loop, be sure
     |      to assign the methods to a local variable to avoid the attribute
     |      look-up at each loop iteration.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.itemset(4, 0)
     |      >>> x.itemset((2, 2), 9)
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 0, 3],
     |             [8, 5, 9]])
     |  
     |  nneewwbbyytteeoorrddeerr(...)
     |      arr.newbyteorder(new_order='S')
     |      
     |      Return the array with the same data viewed with a different byte order.
     |      
     |      Equivalent to::
     |      
     |          arr.view(arr.dtype.newbytorder(new_order))
     |      
     |      Changes are also made in all fields and sub-arrays of the array data
     |      type.
     |      
     |      
     |      
     |      Parameters
     |      ----------
     |      new_order : string, optional
     |          Byte order to force; a value from the byte order specifications
     |          below. `new_order` codes can be any of:
     |      
     |          * 'S' - swap dtype from current to opposite endian
     |          * {'<', 'L'} - little endian
     |          * {'>', 'B'} - big endian
     |          * {'=', 'N'} - native order
     |          * {'|', 'I'} - ignore (no change to byte order)
     |      
     |          The default value ('S') results in swapping the current
     |          byte order. The code does a case-insensitive check on the first
     |          letter of `new_order` for the alternatives above.  For example,
     |          any of 'B' or 'b' or 'biggish' are valid to specify big-endian.
     |      
     |      
     |      Returns
     |      -------
     |      new_arr : array
     |          New array object with the dtype reflecting given change to the
     |          byte order.
     |  
     |  sseeaarrcchhssoorrtteedd(...)
     |      a.searchsorted(v, side='left', sorter=None)
     |      
     |      Find indices where elements of v should be inserted in a to maintain order.
     |      
     |      For full documentation, see `numpy.searchsorted`
     |      
     |      See Also
     |      --------
     |      numpy.searchsorted : equivalent function
     |  
     |  sseettffiieelldd(...)
     |      a.setfield(val, dtype, offset=0)
     |      
     |      Put a value into a specified place in a field defined by a data-type.
     |      
     |      Place `val` into `a`'s field defined by `dtype` and beginning `offset`
     |      bytes into the field.
     |      
     |      Parameters
     |      ----------
     |      val : object
     |          Value to be placed in field.
     |      dtype : dtype object
     |          Data-type of the field in which to place `val`.
     |      offset : int, optional
     |          The number of bytes into the field at which to place `val`.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      See Also
     |      --------
     |      getfield
     |      
     |      Examples
     |      --------
     |      >>> x = np.eye(3)
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |      >>> x.setfield(3, np.int32)
     |      >>> x.getfield(np.int32)
     |      array([[3, 3, 3],
     |             [3, 3, 3],
     |             [3, 3, 3]])
     |      >>> x
     |      array([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],
     |             [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],
     |             [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])
     |      >>> x.setfield(np.eye(3), np.int32)
     |      >>> x
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |  
     |  sseettffllaaggss(...)
     |      a.setflags(write=None, align=None, uic=None)
     |      
     |      Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.
     |      
     |      These Boolean-valued flags affect how numpy interprets the memory
     |      area used by `a` (see Notes below). The ALIGNED flag can only
     |      be set to True if the data is actually aligned according to the type.
     |      The UPDATEIFCOPY flag can never be set to True. The flag WRITEABLE
     |      can only be set to True if the array owns its own memory, or the
     |      ultimate owner of the memory exposes a writeable buffer interface,
     |      or is a string. (The exception for string is made so that unpickling
     |      can be done without copying memory.)
     |      
     |      Parameters
     |      ----------
     |      write : bool, optional
     |          Describes whether or not `a` can be written to.
     |      align : bool, optional
     |          Describes whether or not `a` is aligned properly for its type.
     |      uic : bool, optional
     |          Describes whether or not `a` is a copy of another "base" array.
     |      
     |      Notes
     |      -----
     |      Array flags provide information about how the memory area used
     |      for the array is to be interpreted. There are 6 Boolean flags
     |      in use, only three of which can be changed by the user:
     |      UPDATEIFCOPY, WRITEABLE, and ALIGNED.
     |      
     |      WRITEABLE (W) the data area can be written to;
     |      
     |      ALIGNED (A) the data and strides are aligned appropriately for the hardware
     |      (as determined by the compiler);
     |      
     |      UPDATEIFCOPY (U) this array is a copy of some other array (referenced
     |      by .base). When this array is deallocated, the base array will be
     |      updated with the contents of this array.
     |      
     |      All flags can be accessed using their first (upper case) letter as well
     |      as the full name.
     |      
     |      Examples
     |      --------
     |      >>> y
     |      array([[3, 1, 7],
     |             [2, 0, 0],
     |             [8, 5, 9]])
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(write=0, align=0)
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : False
     |        ALIGNED : False
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(uic=1)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: cannot set UPDATEIFCOPY flag to True
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from numpy.ndarray:
     |  
     |  ____aarrrraayy__iinntteerrffaaccee____
     |      Array protocol: Python side.
     |  
     |  ____aarrrraayy__ssttrruucctt____
     |      Array protocol: C-struct side.
     |  
     |  bbaassee
     |      Base object if memory is from some other object.
     |      
     |      Examples
     |      --------
     |      The base of an array that owns its memory is None:
     |      
     |      >>> x = np.array([1,2,3,4])
     |      >>> x.base is None
     |      True
     |      
     |      Slicing creates a view, whose memory is shared with x:
     |      
     |      >>> y = x[2:]
     |      >>> y.base is x
     |      True
     |  
     |  ccttyyppeess
     |      An object to simplify the interaction of the array with the ctypes
     |      module.
     |      
     |      This attribute creates an object that makes it easier to use arrays
     |      when calling shared libraries with the ctypes module. The returned
     |      object has, among others, data, shape, and strides attributes (see
     |      Notes below) which themselves return ctypes objects that can be used
     |      as arguments to a shared library.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      c : Python object
     |          Possessing attributes data, shape, strides, etc.
     |      
     |      See Also
     |      --------
     |      numpy.ctypeslib
     |      
     |      Notes
     |      -----
     |      Below are the public attributes of this object which were documented
     |      in "Guide to NumPy" (we have omitted undocumented public attributes,
     |      as well as documented private attributes):
     |      
     |      * data: A pointer to the memory area of the array as a Python integer.
     |        This memory area may contain data that is not aligned, or not in correct
     |        byte-order. The memory area may not even be writeable. The array
     |        flags and data-type of this array should be respected when passing this
     |        attribute to arbitrary C-code to avoid trouble that can include Python
     |        crashing. User Beware! The value of this attribute is exactly the same
     |        as self._array_interface_['data'][0].
     |      
     |      * shape (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the C-integer corresponding to dtype('p') on this
     |        platform. This base-type could be c_int, c_long, or c_longlong
     |        depending on the platform. The c_intp type is defined accordingly in
     |        numpy.ctypeslib. The ctypes array contains the shape of the underlying
     |        array.
     |      
     |      * strides (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the same as for the shape attribute. This ctypes array
     |        contains the strides information from the underlying array. This strides
     |        information is important for showing how many bytes must be jumped to
     |        get to the next element in the array.
     |      
     |      * data_as(obj): Return the data pointer cast to a particular c-types object.
     |        For example, calling self._as_parameter_ is equivalent to
     |        self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
     |        pointer to a ctypes array of floating-point data:
     |        self.data_as(ctypes.POINTER(ctypes.c_double)).
     |      
     |      * shape_as(obj): Return the shape tuple as an array of some other c-types
     |        type. For example: self.shape_as(ctypes.c_short).
     |      
     |      * strides_as(obj): Return the strides tuple as an array of some other
     |        c-types type. For example: self.strides_as(ctypes.c_longlong).
     |      
     |      Be careful using the ctypes attribute - especially on temporary
     |      arrays or arrays constructed on the fly. For example, calling
     |      ``(a+b).ctypes.data_as(ctypes.c_void_p)`` returns a pointer to memory
     |      that is invalid because the array created as (a+b) is deallocated
     |      before the next Python statement. You can avoid this problem using
     |      either ``c=a+b`` or ``ct=(a+b).ctypes``. In the latter case, ct will
     |      hold a reference to the array until ct is deleted or re-assigned.
     |      
     |      If the ctypes module is not available, then the ctypes attribute
     |      of array objects still returns something useful, but ctypes objects
     |      are not returned and errors may be raised instead. In particular,
     |      the object will still have the as parameter attribute which will
     |      return an integer equal to the data attribute.
     |      
     |      Examples
     |      --------
     |      >>> import ctypes
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.ctypes.data
     |      30439712
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))
     |      <ctypes.LP_c_long object at 0x01F01300>
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents
     |      c_long(0)
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents
     |      c_longlong(4294967296L)
     |      >>> x.ctypes.shape
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FFD580>
     |      >>> x.ctypes.shape_as(ctypes.c_long)
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides_as(ctypes.c_longlong)
     |      <numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>
     |  
     |  ddttyyppee
     |      Data-type of the array's elements.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      d : numpy dtype object
     |      
     |      See Also
     |      --------
     |      numpy.dtype
     |      
     |      Examples
     |      --------
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.dtype
     |      dtype('int32')
     |      >>> type(x.dtype)
     |      <type 'numpy.dtype'>
     |  
     |  ffllaaggss
     |      Information about the memory layout of the array.
     |      
     |      Attributes
     |      ----------
     |      C_CONTIGUOUS (C)
     |          The data is in a single, C-style contiguous segment.
     |      F_CONTIGUOUS (F)
     |          The data is in a single, Fortran-style contiguous segment.
     |      OWNDATA (O)
     |          The array owns the memory it uses or borrows it from another object.
     |      WRITEABLE (W)
     |          The data area can be written to.  Setting this to False locks
     |          the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
     |          from its base array at creation time, but a view of a writeable
     |          array may be subsequently locked while the base array remains writeable.
     |          (The opposite is not true, in that a view of a locked array may not
     |          be made writeable.  However, currently, locking a base object does not
     |          lock any views that already reference it, so under that circumstance it
     |          is possible to alter the contents of a locked array via a previously
     |          created writeable view onto it.)  Attempting to change a non-writeable
     |          array raises a RuntimeError exception.
     |      ALIGNED (A)
     |          The data and all elements are aligned appropriately for the hardware.
     |      UPDATEIFCOPY (U)
     |          This array is a copy of some other array. When this array is
     |          deallocated, the base array will be updated with the contents of
     |          this array.
     |      FNC
     |          F_CONTIGUOUS and not C_CONTIGUOUS.
     |      FORC
     |          F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
     |      BEHAVED (B)
     |          ALIGNED and WRITEABLE.
     |      CARRAY (CA)
     |          BEHAVED and C_CONTIGUOUS.
     |      FARRAY (FA)
     |          BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.
     |      
     |      Notes
     |      -----
     |      The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
     |      or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
     |      names are only supported in dictionary access.
     |      
     |      Only the UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by
     |      the user, via direct assignment to the attribute or dictionary entry,
     |      or by calling `ndarray.setflags`.
     |      
     |      The array flags cannot be set arbitrarily:
     |      
     |      - UPDATEIFCOPY can only be set ``False``.
     |      - ALIGNED can only be set ``True`` if the data is truly aligned.
     |      - WRITEABLE can only be set ``True`` if the array owns its own memory
     |        or the ultimate owner of the memory exposes a writeable buffer
     |        interface or is a string.
     |      
     |      Arrays can be both C-style and Fortran-style contiguous simultaneously.
     |      This is clear for 1-dimensional arrays, but can also be true for higher
     |      dimensional arrays.
     |      
     |      Even for contiguous arrays a stride for a given dimension
     |      ``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``
     |      or the array has no elements.
     |      It does *not* generally hold that ``self.strides[-1] == self.itemsize``
     |      for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for
     |      Fortran-style contiguous arrays is true.
     |  
     |  iitteemmssiizzee
     |      Length of one array element in bytes.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1,2,3], dtype=np.float64)
     |      >>> x.itemsize
     |      8
     |      >>> x = np.array([1,2,3], dtype=np.complex128)
     |      >>> x.itemsize
     |      16
     |  
     |  nnbbyytteess
     |      Total bytes consumed by the elements of the array.
     |      
     |      Notes
     |      -----
     |      Does not include memory consumed by non-element attributes of the
     |      array object.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3,5,2), dtype=np.complex128)
     |      >>> x.nbytes
     |      480
     |      >>> np.prod(x.shape) * x.itemsize
     |      480
     |  
     |  nnddiimm
     |      Number of array dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3])
     |      >>> x.ndim
     |      1
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.ndim
     |      3
     |  
     |  sshhaappee
     |      Tuple of array dimensions.
     |      
     |      Notes
     |      -----
     |      May be used to "reshape" the array, as long as this would not
     |      require a change in the total number of elements
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3, 4])
     |      >>> x.shape
     |      (4,)
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.shape
     |      (2, 3, 4)
     |      >>> y.shape = (3, 8)
     |      >>> y
     |      array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
     |      >>> y.shape = (3, 6)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: total size of new array must be unchanged
     |  
     |  ssiizzee
     |      Number of elements in the array.
     |      
     |      Equivalent to ``np.prod(a.shape)``, i.e., the product of the array's
     |      dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3, 5, 2), dtype=np.complex128)
     |      >>> x.size
     |      30
     |      >>> np.prod(x.shape)
     |      30
     |  
     |  ssttrriiddeess
     |      Tuple of bytes to step in each dimension when traversing an array.
     |      
     |      The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
     |      is::
     |      
     |          offset = sum(np.array(i) * a.strides)
     |      
     |      A more detailed explanation of strides can be found in the
     |      "ndarray.rst" file in the NumPy reference guide.
     |      
     |      Notes
     |      -----
     |      Imagine an array of 32-bit integers (each 4 bytes)::
     |      
     |        x = np.array([[0, 1, 2, 3, 4],
     |                      [5, 6, 7, 8, 9]], dtype=np.int32)
     |      
     |      This array is stored in memory as 40 bytes, one after the other
     |      (known as a contiguous block of memory).  The strides of an array tell
     |      us how many bytes we have to skip in memory to move to the next position
     |      along a certain axis.  For example, we have to skip 4 bytes (1 value) to
     |      move to the next column, but 20 bytes (5 values) to get to the same
     |      position in the next row.  As such, the strides for the array `x` will be
     |      ``(20, 4)``.
     |      
     |      See Also
     |      --------
     |      numpy.lib.stride_tricks.as_strided
     |      
     |      Examples
     |      --------
     |      >>> y = np.reshape(np.arange(2*3*4), (2,3,4))
     |      >>> y
     |      array([[[ 0,  1,  2,  3],
     |              [ 4,  5,  6,  7],
     |              [ 8,  9, 10, 11]],
     |             [[12, 13, 14, 15],
     |              [16, 17, 18, 19],
     |              [20, 21, 22, 23]]])
     |      >>> y.strides
     |      (48, 16, 4)
     |      >>> y[1,1,1]
     |      17
     |      >>> offset=sum(y.strides * np.array((1,1,1)))
     |      >>> offset/y.itemsize
     |      17
     |      
     |      >>> x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)
     |      >>> x.strides
     |      (32, 4, 224, 1344)
     |      >>> i = np.array([3,5,2,2])
     |      >>> offset = sum(i * x.strides)
     |      >>> x[3,5,2,2]
     |      813
     |      >>> offset / x.itemsize
     |      813
    
    class bbooooll__(generic)
     |  NumPy's Boolean type.  Character code: ``?``.  Alias: bool8
     |  
     |  Method resolution order:
     |      bool_
     |      generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____aanndd____(self, value, /)
     |      Return self&value.
     |  
     |  ____bbooooll____(self, /)
     |      self != 0
     |  
     |  ____eeqq____(self, value, /)
     |      Return self==value.
     |  
     |  ____ggee____(self, value, /)
     |      Return self>=value.
     |  
     |  ____ggtt____(self, value, /)
     |      Return self>value.
     |  
     |  ____hhaasshh____(self, /)
     |      Return hash(self).
     |  
     |  ____iinnddeexx____(self, /)
     |      Return self converted to an integer, if self is suitable for use as an index into a list.
     |  
     |  ____llee____(self, value, /)
     |      Return self<=value.
     |  
     |  ____lltt____(self, value, /)
     |      Return self<value.
     |  
     |  ____nnee____(self, value, /)
     |      Return self!=value.
     |  
     |  ____nneeww____(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ____oorr____(self, value, /)
     |      Return self|value.
     |  
     |  ____rraanndd____(self, value, /)
     |      Return value&self.
     |  
     |  ____rroorr____(self, value, /)
     |      Return value|self.
     |  
     |  ____rrxxoorr____(self, value, /)
     |      Return value^self.
     |  
     |  ____xxoorr____(self, value, /)
     |      Return self^value.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from generic:
     |  
     |  ____aabbss____(self, /)
     |      abs(self)
     |  
     |  ____aadddd____(self, value, /)
     |      Return self+value.
     |  
     |  ____aarrrraayy____(...)
     |      sc.__array__(|type) return 0-dim array
     |  
     |  ____aarrrraayy__wwrraapp____(...)
     |      sc.__array_wrap__(obj) return scalar from array
     |  
     |  ____ccooppyy____(...)
     |  
     |  ____ddeeeeppccooppyy____(...)
     |  
     |  ____ddiivvmmoodd____(self, value, /)
     |      Return divmod(self, value).
     |  
     |  ____ffllooaatt____(self, /)
     |      float(self)
     |  
     |  ____fflloooorrddiivv____(self, value, /)
     |      Return self//value.
     |  
     |  ____ffoorrmmaatt____(...)
     |      NumPy array scalar formatter
     |  
     |  ____ggeettiitteemm____(self, key, /)
     |      Return self[key].
     |  
     |  ____iinntt____(self, /)
     |      int(self)
     |  
     |  ____iinnvveerrtt____(self, /)
     |      ~self
     |  
     |  ____llsshhiifftt____(self, value, /)
     |      Return self<<value.
     |  
     |  ____mmoodd____(self, value, /)
     |      Return self%value.
     |  
     |  ____mmuull____(self, value, /)
     |      Return self*value.
     |  
     |  ____nneegg____(self, /)
     |      -self
     |  
     |  ____ppooss____(self, /)
     |      +self
     |  
     |  ____ppooww____(self, value, mod=None, /)
     |      Return pow(self, value, mod).
     |  
     |  ____rraadddd____(self, value, /)
     |      Return value+self.
     |  
     |  ____rrddiivvmmoodd____(self, value, /)
     |      Return divmod(value, self).
     |  
     |  ____rreedduuccee____(...)
     |      helper for pickle
     |  
     |  ____rreepprr____(self, /)
     |      Return repr(self).
     |  
     |  ____rrfflloooorrddiivv____(self, value, /)
     |      Return value//self.
     |  
     |  ____rrllsshhiifftt____(self, value, /)
     |      Return value<<self.
     |  
     |  ____rrmmoodd____(self, value, /)
     |      Return value%self.
     |  
     |  ____rrmmuull____(self, value, /)
     |      Return value*self.
     |  
     |  ____rroouunndd____(...)
     |  
     |  ____rrppooww____(self, value, mod=None, /)
     |      Return pow(value, self, mod).
     |  
     |  ____rrrrsshhiifftt____(self, value, /)
     |      Return value>>self.
     |  
     |  ____rrsshhiifftt____(self, value, /)
     |      Return self>>value.
     |  
     |  ____rrssuubb____(self, value, /)
     |      Return value-self.
     |  
     |  ____rrttrruueeddiivv____(self, value, /)
     |      Return value/self.
     |  
     |  ____sseettssttaattee____(...)
     |  
     |  ____ssiizzeeooff____(...)
     |      __sizeof__() -> int
     |      size of object in memory, in bytes
     |  
     |  ____ssttrr____(self, /)
     |      Return str(self).
     |  
     |  ____ssuubb____(self, value, /)
     |      Return self-value.
     |  
     |  ____ttrruueeddiivv____(self, value, /)
     |      Return self/value.
     |  
     |  aallll(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aannyy(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aarrggmmaaxx(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aarrggmmiinn(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aarrggssoorrtt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  aassttyyppee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  bbyytteesswwaapp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class so as to
     |      provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  cchhoooossee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  cclliipp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccoommpprreessss(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccoonnjj(...)
     |  
     |  ccoonnjjuuggaattee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccooppyy(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccuummpprroodd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ccuummssuumm(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ddiiaaggoonnaall(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  dduummpp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  dduummppss(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ffiillll(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ffllaatttteenn(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ggeettffiieelldd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  iitteemm(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  iitteemmsseett(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  mmaaxx(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  mmeeaann(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  mmiinn(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  nneewwbbyytteeoorrddeerr(...)
     |      newbyteorder(new_order='S')
     |      
     |      Return a new `dtype` with a different byte order.
     |      
     |      Changes are also made in all fields and sub-arrays of the data type.
     |      
     |      The `new_order` code can be any from the following:
     |      
     |      * 'S' - swap dtype from current to opposite endian
     |      * {'<', 'L'} - little endian
     |      * {'>', 'B'} - big endian
     |      * {'=', 'N'} - native order
     |      * {'|', 'I'} - ignore (no change to byte order)
     |      
     |      Parameters
     |      ----------
     |      new_order : str, optional
     |          Byte order to force; a value from the byte order specifications
     |          above.  The default value ('S') results in swapping the current
     |          byte order. The code does a case-insensitive check on the first
     |          letter of `new_order` for the alternatives above.  For example,
     |          any of 'B' or 'b' or 'biggish' are valid to specify big-endian.
     |      
     |      
     |      Returns
     |      -------
     |      new_dtype : dtype
     |          New `dtype` object with the given change to the byte order.
     |  
     |  nnoonnzzeerroo(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  pprroodd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ppttpp(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ppuutt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rraavveell(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rreeppeeaatt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rreesshhaappee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rreessiizzee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  rroouunndd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sseeaarrcchhssoorrtteedd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sseettffiieelldd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sseettffllaaggss(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class so as to
     |      provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssoorrtt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssqquueeeezzee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssttdd(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ssuumm(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  sswwaappaaxxeess(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttaakkee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttoobbyytteess(...)
     |  
     |  ttooffiillee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttoolliisstt(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttoossttrriinngg(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttrraaccee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ttrraannssppoossee(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  vvaarr(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  vviieeww(...)
     |      Not implemented (virtual attribute)
     |      
     |      Class generic exists solely to derive numpy scalars from, and possesses,
     |      albeit unimplemented, all the attributes of the ndarray class
     |      so as to provide a uniform API.
     |      
     |      See Also
     |      --------
     |      The corresponding attribute of the derived class of interest.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from generic:
     |  
     |  TT
     |      transpose
     |  
     |  ____aarrrraayy__iinntteerrffaaccee____
     |      Array protocol: Python side
     |  
     |  ____aarrrraayy__pprriioorriittyy____
     |      Array priority.
     |  
     |  ____aarrrraayy__ssttrruucctt____
     |      Array protocol: struct
     |  
     |  bbaassee
     |      base object
     |  
     |  ddaattaa
     |      pointer to start of data
     |  
     |  ddttyyppee
     |      get array data-descriptor
     |  
     |  ffllaaggss
     |      integer value of flags
     |  
     |  ffllaatt
     |      a 1-d view of scalar
     |  
     |  iimmaagg
     |      imaginary part of scalar
     |  
     |  iitteemmssiizzee
     |      length of one element in bytes
     |  
     |  nnbbyytteess
     |      length of item in bytes
     |  
     |  nnddiimm
     |      number of array dimensions
     |  
     |  rreeaall
     |      real part of scalar
     |  
     |  sshhaappee
     |      tuple of array dimensions
     |  
     |  ssiizzee
     |      number of elements in the gentype
     |  
     |  ssttrriiddeess
     |      tuple of bytes steps in each dimension
    
    mmaasskkeedd__aarrrraayy = class MaskedArray(numpy.ndarray)
     |  An array class with possibly masked values.
     |  
     |  Masked values of True exclude the corresponding element from any
     |  computation.
     |  
     |  Construction::
     |  
     |    x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
     |                    ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
     |                    shrink=True, order=None)
     |  
     |  Parameters
     |  ----------
     |  data : array_like
     |      Input data.
     |  mask : sequence, optional
     |      Mask. Must be convertible to an array of booleans with the same
     |      shape as `data`. True indicates a masked (i.e. invalid) data.
     |  dtype : dtype, optional
     |      Data type of the output.
     |      If `dtype` is None, the type of the data argument (``data.dtype``)
     |      is used. If `dtype` is not None and different from ``data.dtype``,
     |      a copy is performed.
     |  copy : bool, optional
     |      Whether to copy the input data (True), or to use a reference instead.
     |      Default is False.
     |  subok : bool, optional
     |      Whether to return a subclass of `MaskedArray` if possible (True) or a
     |      plain `MaskedArray`. Default is True.
     |  ndmin : int, optional
     |      Minimum number of dimensions. Default is 0.
     |  fill_value : scalar, optional
     |      Value used to fill in the masked values when necessary.
     |      If None, a default based on the data-type is used.
     |  keep_mask : bool, optional
     |      Whether to combine `mask` with the mask of the input data, if any
     |      (True), or to use only `mask` for the output (False). Default is True.
     |  hard_mask : bool, optional
     |      Whether to use a hard mask or not. With a hard mask, masked values
     |      cannot be unmasked. Default is False.
     |  shrink : bool, optional
     |      Whether to force compression of an empty mask. Default is True.
     |  order : {'C', 'F', 'A'}, optional
     |      Specify the order of the array.  If order is 'C', then the array
     |      will be in C-contiguous order (last-index varies the fastest).
     |      If order is 'F', then the returned array will be in
     |      Fortran-contiguous order (first-index varies the fastest).
     |      If order is 'A' (default), then the returned array may be
     |      in any order (either C-, Fortran-contiguous, or even discontiguous),
     |      unless a copy is required, in which case it will be C-contiguous.
     |  
     |  Method resolution order:
     |      MaskedArray
     |      numpy.ndarray
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____aadddd____(self, other)
     |      Add self to other, and return a new masked array.
     |  
     |  ____aarrrraayy__ffiinnaalliizzee____(self, obj)
     |      Finalizes the masked array.
     |  
     |  ____aarrrraayy__wwrraapp____(self, obj, context=None)
     |      Special hook for ufuncs.
     |      
     |      Wraps the numpy array and sets the mask according to context.
     |  
     |  ____ddeeeeppccooppyy____(self, memo=None)
     |      a.__deepcopy__() -> Deep copy of array.
     |      
     |      Used if copy.deepcopy is called on an array.
     |  
     |  ____ddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  ____eeqq____(self, other)
     |      Check whether other equals self elementwise.
     |      
     |      When either of the elements is masked, the result is masked as well,
     |      but the underlying boolean data are still set, with self and other
     |      considered equal if both are masked, and unequal otherwise.
     |      
     |      For structured arrays, all fields are combined, with masked values
     |      ignored. The result is masked if all fields were masked, with self
     |      and other considered equal only if both were fully masked.
     |  
     |  ____ffllooaatt____(self)
     |      Convert to float.
     |  
     |  ____fflloooorrddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  ____ggeettiitteemm____(self, indx)
     |      x.__getitem__(y) <==> x[y]
     |      
     |      Return the item described by i, as a masked array.
     |  
     |  ____ggeettssttaattee____(self)
     |      Return the internal state of the masked array, for pickling
     |      purposes.
     |  
     |  ____iiaadddd____(self, other)
     |      Add other to self in-place.
     |  
     |  ____iiddiivv____(self, other)
     |      Divide self by other in-place.
     |  
     |  ____iifflloooorrddiivv____(self, other)
     |      Floor divide self by other in-place.
     |  
     |  ____iimmuull____(self, other)
     |      Multiply self by other in-place.
     |  
     |  ____iinntt____(self)
     |      Convert to int.
     |  
     |  ____iippooww____(self, other)
     |      Raise self to the power other, in place.
     |  
     |  ____iissuubb____(self, other)
     |      Subtract other from self in-place.
     |  
     |  ____iittrruueeddiivv____(self, other)
     |      True divide self by other in-place.
     |  
     |  ____mmuull____(self, other)
     |      Multiply self by other, and return a new masked array.
     |  
     |  ____nnee____(self, other)
     |      Check whether other does not equal self elementwise.
     |      
     |      When either of the elements is masked, the result is masked as well,
     |      but the underlying boolean data are still set, with self and other
     |      considered equal if both are masked, and unequal otherwise.
     |      
     |      For structured arrays, all fields are combined, with masked values
     |      ignored. The result is masked if all fields were masked, with self
     |      and other considered equal only if both were fully masked.
     |  
     |  ____ppooww____(self, other)
     |      Raise self to the power other, masking the potential NaNs/Infs
     |  
     |  ____rraadddd____(self, other)
     |      Add other to self, and return a new masked array.
     |  
     |  ____rreedduuccee____(self)
     |      Return a 3-tuple for pickling a MaskedArray.
     |  
     |  ____rreepprr____(self)
     |      Literal string representation.
     |  
     |  ____rrfflloooorrddiivv____(self, other)
     |      Divide self into other, and return a new masked array.
     |  
     |  ____rrmmuull____(self, other)
     |      Multiply other by self, and return a new masked array.
     |  
     |  ____rrppooww____(self, other)
     |      Raise other to the power self, masking the potential NaNs/Infs
     |  
     |  ____rrssuubb____(self, other)
     |      Subtract self from other, and return a new masked array.
     |  
     |  ____rrttrruueeddiivv____(self, other)
     |      Divide self into other, and return a new masked array.
     |  
     |  ____sseettaattttrr____(self, attr, value)
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettiitteemm____(self, indx, value)
     |      x.__setitem__(i, y) <==> x[i]=y
     |      
     |      Set item described by index. If value is masked, masks those
     |      locations.
     |  
     |  ____sseettmmaasskk____(self, mask, copy=False)
     |      Set the mask.
     |  
     |  ____sseettssttaattee____(self, state)
     |      Restore the internal state of the masked array, for
     |      pickling purposes.  ``state`` is typically the output of the
     |      ``__getstate__`` output, and is a 5-tuple:
     |      
     |      - class name
     |      - a tuple giving the shape of the data
     |      - a typecode for the data
     |      - a binary string for the data
     |      - a binary string for the mask.
     |  
     |  ____ssttrr____(self)
     |      String representation.
     |  
     |  ____ssuubb____(self, other)
     |      Subtract other from self, and return a new masked array.
     |  
     |  ____ttrruueeddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  aallll(self, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns True if all elements evaluate to True.
     |      
     |      The output array is masked where all the values along the given axis
     |      are masked: if the output would have been a scalar and that all the
     |      values are masked, then the output is `masked`.
     |      
     |      Refer to `numpy.all` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.all : corresponding function for ndarrays
     |      numpy.all : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> np.ma.array([1,2,3]).all()
     |      True
     |      >>> a = np.ma.array([1,2,3], mask=True)
     |      >>> (a.all() is np.ma.masked)
     |      True
     |  
     |  aannoomm(self, axis=None, dtype=None)
     |      Compute the anomalies (deviations from the arithmetic mean)
     |      along the given axis.
     |      
     |      Returns an array of anomalies, with the same shape as the input and
     |      where the arithmetic mean is computed along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis over which the anomalies are taken.
     |          The default is to use the mean of the flattened array as reference.
     |      dtype : dtype, optional
     |          Type to use in computing the variance. For arrays of integer type
     |           the default is float32; for arrays of float types it is the same as
     |           the array type.
     |      
     |      See Also
     |      --------
     |      mean : Compute the mean of the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([1,2,3])
     |      >>> a.anom()
     |      masked_array(data = [-1.  0.  1.],
     |                   mask = False,
     |             fill_value = 1e+20)
     |  
     |  aannyy(self, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns True if any of the elements of `a` evaluate to True.
     |      
     |      Masked values are considered as False during computation.
     |      
     |      Refer to `numpy.any` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.any : corresponding function for ndarrays
     |      numpy.any : equivalent function
     |  
     |  aarrggmmaaxx(self, axis=None, fill_value=None, out=None)
     |      Returns array of indices of the maximum values along the given axis.
     |      Masked values are treated as if they had the value fill_value.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, integer}
     |          If None, the index is into the flattened array, otherwise along
     |          the specified axis
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.  If None, the output of
     |          maximum_fill_value(self._data) is used instead.
     |      out : {None, array}, optional
     |          Array into which the result can be placed. Its type is preserved
     |          and it must be of the right shape to hold the output.
     |      
     |      Returns
     |      -------
     |      index_array : {integer_array}
     |      
     |      Examples
     |      --------
     |      >>> a = np.arange(6).reshape(2,3)
     |      >>> a.argmax()
     |      5
     |      >>> a.argmax(0)
     |      array([1, 1, 1])
     |      >>> a.argmax(1)
     |      array([2, 2])
     |  
     |  aarrggmmiinn(self, axis=None, fill_value=None, out=None)
     |      Return array of indices to the minimum values along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, integer}
     |          If None, the index is into the flattened array, otherwise along
     |          the specified axis
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.  If None, the output of
     |          minimum_fill_value(self._data) is used instead.
     |      out : {None, array}, optional
     |          Array into which the result can be placed. Its type is preserved
     |          and it must be of the right shape to hold the output.
     |      
     |      Returns
     |      -------
     |      ndarray or scalar
     |          If multi-dimension input, returns a new ndarray of indices to the
     |          minimum values along the given axis.  Otherwise, returns a scalar
     |          of index to the minimum values along the given axis.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(arange(4), mask=[1,1,0,0])
     |      >>> x.shape = (2,2)
     |      >>> print(x)
     |      [[-- --]
     |       [2 3]]
     |      >>> print(x.argmin(axis=0, fill_value=-1))
     |      [0 0]
     |      >>> print(x.argmin(axis=0, fill_value=9))
     |      [1 1]
     |  
     |  aarrggppaarrttiittiioonn(self, *args, **kwargs)
     |      a.argpartition(kth, axis=-1, kind='introselect', order=None)
     |      
     |      Returns the indices that would partition this array.
     |      
     |      Refer to `numpy.argpartition` for full documentation.
     |      
     |      .. versionadded:: 1.8.0
     |      
     |      See Also
     |      --------
     |      numpy.argpartition : equivalent function
     |  
     |  aarrggssoorrtt(self, axis=<class 'numpy._globals._NoValue'>, kind='quicksort', order=None, endwith=True, fill_value=None)
     |      Return an ndarray of indices that sort the array along the
     |      specified axis.  Masked values are filled beforehand to
     |      `fill_value`.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis along which to sort. If None, the default, the flattened array
     |          is used.
     |      
     |          ..  versionchanged:: 1.13.0
     |              Previously, the default was documented to be -1, but that was
     |              in error. At some future date, the default will change to -1, as
     |              originally intended.
     |              Until then, the axis should be given explicitly when
     |              ``arr.ndim > 1``, to avoid a FutureWarning.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm.
     |      order : list, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  Not all fields need be
     |          specified.
     |      endwith : {True, False}, optional
     |          Whether missing values (if any) should be treated as the largest values
     |          (True) or the smallest values (False)
     |          When the array contains unmasked values at the same extremes of the
     |          datatype, the ordering of these values and the masked values is
     |          undefined.
     |      fill_value : {var}, optional
     |          Value used internally for the masked values.
     |          If ``fill_value`` is not None, it supersedes ``endwith``.
     |      
     |      Returns
     |      -------
     |      index_array : ndarray, int
     |          Array of indices that sort `a` along the specified axis.
     |          In other words, ``a[index_array]`` yields a sorted `a`.
     |      
     |      See Also
     |      --------
     |      MaskedArray.sort : Describes sorting algorithms used.
     |      lexsort : Indirect stable sort with multiple keys.
     |      ndarray.sort : Inplace sort.
     |      
     |      Notes
     |      -----
     |      See `sort` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([3,2,1], mask=[False, False, True])
     |      >>> a
     |      masked_array(data = [3 2 --],
     |                   mask = [False False  True],
     |             fill_value = 999999)
     |      >>> a.argsort()
     |      array([1, 0, 2])
     |  
     |  aassttyyppee(self, newtype)
     |      Returns a copy of the MaskedArray cast to given newtype.
     |      
     |      Returns
     |      -------
     |      output : MaskedArray
     |          A copy of self cast to input newtype.
     |          The returned record shape matches self.shape.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1.0 -- 3.1]
     |       [-- 5.0 --]
     |       [7.0 -- 9.0]]
     |      >>> print(x.astype(int32))
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |  
     |  cclliipp(self, *args, **params)
     |      a.clip(min=None, max=None, out=None)
     |      
     |      Return an array whose values are limited to ``[min, max]``.
     |      One of max or min must be given.
     |      
     |      Refer to `numpy.clip` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.clip : equivalent function
     |  
     |  ccoommpprreessss(self, condition, axis=None, out=None)
     |      Return `a` where condition is ``True``.
     |      
     |      If condition is a `MaskedArray`, missing values are considered
     |      as ``False``.
     |      
     |      Parameters
     |      ----------
     |      condition : var
     |          Boolean 1-d array selecting which entries to return. If len(condition)
     |          is less than the size of a along the axis, then output is truncated
     |          to length of condition array.
     |      axis : {None, int}, optional
     |          Axis along which the operation must be performed.
     |      out : {None, ndarray}, optional
     |          Alternative output array in which to place the result. It must have
     |          the same shape as the expected output but the type will be cast if
     |          necessary.
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          A :class:`MaskedArray` object.
     |      
     |      Notes
     |      -----
     |      Please note the difference with :meth:`compressed` !
     |      The output of :meth:`compress` has a mask, the output of
     |      :meth:`compressed` does not.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> x.compress([1, 0, 1])
     |      masked_array(data = [1 3],
     |            mask = [False False],
     |            fill_value=999999)
     |      
     |      >>> x.compress([1, 0, 1], axis=1)
     |      masked_array(data =
     |       [[1 3]
     |       [-- --]
     |       [7 9]],
     |            mask =
     |       [[False False]
     |       [ True  True]
     |       [False False]],
     |            fill_value=999999)
     |  
     |  ccoommpprreesssseedd(self)
     |      Return all the non-masked data as a 1-D array.
     |      
     |      Returns
     |      -------
     |      data : ndarray
     |          A new `ndarray` holding the non-masked data is returned.
     |      
     |      Notes
     |      -----
     |      The result is **not** a MaskedArray!
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
     |      >>> x.compressed()
     |      array([0, 1])
     |      >>> type(x.compressed())
     |      <type 'numpy.ndarray'>
     |  
     |  ccooppyy(self, *args, **params)
     |      a.copy(order='C')
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          Controls the memory layout of the copy. 'C' means C-order,
     |          'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
     |          'C' otherwise. 'K' means match the layout of `a` as closely
     |          as possible. (Note that this function and :func:numpy.copy are very
     |          similar, but have different default values for their order=
     |          arguments.)
     |      
     |      See also
     |      --------
     |      numpy.copy
     |      numpy.copyto
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([[1,2,3],[4,5,6]], order='F')
     |      
     |      >>> y = x.copy()
     |      
     |      >>> x.fill(0)
     |      
     |      >>> x
     |      array([[0, 0, 0],
     |             [0, 0, 0]])
     |      
     |      >>> y
     |      array([[1, 2, 3],
     |             [4, 5, 6]])
     |      
     |      >>> y.flags['C_CONTIGUOUS']
     |      True
     |  
     |  ccoouunntt(self, axis=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Count the non-masked elements of the array along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : None or int or tuple of ints, optional
     |          Axis or axes along which the count is performed.
     |          The default (`axis` = `None`) performs the count over all
     |          the dimensions of the input array. `axis` may be negative, in
     |          which case it counts from the last to the first axis.
     |      
     |          .. versionadded:: 1.10.0
     |      
     |          If this is a tuple of ints, the count is performed on multiple
     |          axes, instead of a single axis or all the axes as before.
     |      keepdims : bool, optional
     |          If this is set to True, the axes which are reduced are left
     |          in the result as dimensions with size one. With this option,
     |          the result will broadcast correctly against the array.
     |      
     |      Returns
     |      -------
     |      result : ndarray or scalar
     |          An array with the same shape as the input array, with the specified
     |          axis removed. If the array is a 0-d array, or if `axis` is None, a
     |          scalar is returned.
     |      
     |      See Also
     |      --------
     |      count_masked : Count masked elements in array or along a given axis.
     |      
     |      Examples
     |      --------
     |      >>> import numpy.ma as ma
     |      >>> a = ma.arange(6).reshape((2, 3))
     |      >>> a[1, :] = ma.masked
     |      >>> a
     |      masked_array(data =
     |       [[0 1 2]
     |       [-- -- --]],
     |                   mask =
     |       [[False False False]
     |       [ True  True  True]],
     |             fill_value = 999999)
     |      >>> a.count()
     |      3
     |      
     |      When the `axis` keyword is specified an array of appropriate size is
     |      returned.
     |      
     |      >>> a.count(axis=0)
     |      array([1, 1, 1])
     |      >>> a.count(axis=1)
     |      array([3, 0])
     |  
     |  ccuummpprroodd(self, axis=None, dtype=None, out=None)
     |      Return the cumulative product of the array elements over the given axis.
     |      
     |      Masked values are set to 1 internally during the computation.
     |      However, their position is saved, and the result will be masked at
     |      the same locations.
     |      
     |      Refer to `numpy.cumprod` for full documentation.
     |      
     |      Notes
     |      -----
     |      The mask is lost if `out` is not a valid MaskedArray !
     |      
     |      Arithmetic is modular when using integer types, and no error is
     |      raised on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.cumprod : corresponding function for ndarrays
     |      numpy.cumprod : equivalent function
     |  
     |  ccuummssuumm(self, axis=None, dtype=None, out=None)
     |      Return the cumulative sum of the array elements over the given axis.
     |      
     |      Masked values are set to 0 internally during the computation.
     |      However, their position is saved, and the result will be masked at
     |      the same locations.
     |      
     |      Refer to `numpy.cumsum` for full documentation.
     |      
     |      Notes
     |      -----
     |      The mask is lost if `out` is not a valid :class:`MaskedArray` !
     |      
     |      Arithmetic is modular when using integer types, and no error is
     |      raised on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.cumsum : corresponding function for ndarrays
     |      numpy.cumsum : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
     |      >>> print(marr.cumsum())
     |      [0 1 3 -- -- -- 9 16 24 33]
     |  
     |  ddiiaaggoonnaall(self, *args, **params)
     |      a.diagonal(offset=0, axis1=0, axis2=1)
     |      
     |      Return specified diagonals. In NumPy 1.9 the returned array is a
     |      read-only view instead of a copy as in previous NumPy versions.  In
     |      a future version the read-only restriction will be removed.
     |      
     |      Refer to :func:`numpy.diagonal` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.diagonal : equivalent function
     |  
     |  ddoott(self, b, out=None, strict=False)
     |      a.dot(b, out=None)
     |      
     |      Masked dot product of two arrays. Note that `out` and `strict` are
     |      located in different positions than in `ma.dot`. In order to
     |      maintain compatibility with the functional version, it is
     |      recommended that the optional arguments be treated as keyword only.
     |      At some point that may be mandatory.
     |      
     |      .. versionadded:: 1.10.0
     |      
     |      Parameters
     |      ----------
     |      b : masked_array_like
     |          Inputs array.
     |      out : masked_array, optional
     |          Output argument. This must have the exact kind that would be
     |          returned if it was not used. In particular, it must have the
     |          right type, must be C-contiguous, and its dtype must be the
     |          dtype that would be returned for `ma.dot(a,b)`. This is a
     |          performance feature. Therefore, if these conditions are not
     |          met, an exception is raised, instead of attempting to be
     |          flexible.
     |      strict : bool, optional
     |          Whether masked data are propagated (True) or set to 0 (False)
     |          for the computation. Default is False.  Propagating the mask
     |          means that if a masked value appears in a row or column, the
     |          whole row or column is considered masked.
     |      
     |          .. versionadded:: 1.10.2
     |      
     |      See Also
     |      --------
     |      numpy.ma.dot : equivalent function
     |  
     |  ffiilllleedd(self, fill_value=None)
     |      Return a copy of self, with masked values filled with a given value.
     |      **However**, if there are no masked values to fill, self will be
     |      returned instead as an ndarray.
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          The value to use for invalid entries (None by default).
     |          If None, the `fill_value` attribute of the array is used instead.
     |      
     |      Returns
     |      -------
     |      filled_array : ndarray
     |          A copy of ``self`` with invalid entries replaced by *fill_value*
     |          (be it the function argument or the attribute of ``self``), or
     |          ``self`` itself as an ndarray if there are no invalid entries to
     |          be replaced.
     |      
     |      Notes
     |      -----
     |      The result is **not** a MaskedArray!
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
     |      >>> x.filled()
     |      array([1, 2, -999, 4, -999])
     |      >>> type(x.filled())
     |      <type 'numpy.ndarray'>
     |      
     |      Subclassing is preserved. This means that if the data part of the masked
     |      array is a matrix, `filled` returns a matrix:
     |      
     |      >>> x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
     |      >>> x.filled()
     |      matrix([[     1, 999999],
     |              [999999,      4]])
     |  
     |  ffllaatttteenn(self, *args, **params)
     |      a.flatten(order='C')
     |      
     |      Return a copy of the array collapsed into one dimension.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          'C' means to flatten in row-major (C-style) order.
     |          'F' means to flatten in column-major (Fortran-
     |          style) order. 'A' means to flatten in column-major
     |          order if `a` is Fortran *contiguous* in memory,
     |          row-major order otherwise. 'K' means to flatten
     |          `a` in the order the elements occur in memory.
     |          The default is 'C'.
     |      
     |      Returns
     |      -------
     |      y : ndarray
     |          A copy of the input array, flattened to one dimension.
     |      
     |      See Also
     |      --------
     |      ravel : Return a flattened array.
     |      flat : A 1-D flat iterator over the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1,2], [3,4]])
     |      >>> a.flatten()
     |      array([1, 2, 3, 4])
     |      >>> a.flatten('F')
     |      array([1, 3, 2, 4])
     |  
     |  ggeett__ffiillll__vvaalluuee(self)
     |      Return the filling value of the masked array.
     |      
     |      Returns
     |      -------
     |      fill_value : scalar
     |          The filling value.
     |      
     |      Examples
     |      --------
     |      >>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
     |      ...     np.ma.array([0, 1], dtype=dt).get_fill_value()
     |      ...
     |      999999
     |      999999
     |      1e+20
     |      (1e+20+0j)
     |      
     |      >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
     |      >>> x.get_fill_value()
     |      -inf
     |  
     |  ggeett__iimmaagg(self)
     |      Return the imaginary part of the masked array.
     |      
     |      The returned array is a view on the imaginary part of the `MaskedArray`
     |      whose `get_imag` method is called.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          The imaginary part of the masked array.
     |      
     |      See Also
     |      --------
     |      get_real, real, imag
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
     |      >>> x.get_imag()
     |      masked_array(data = [1.0 -- 1.6],
     |                   mask = [False  True False],
     |             fill_value = 1e+20)
     |  
     |  ggeett__rreeaall(self)
     |      Return the real part of the masked array.
     |      
     |      The returned array is a view on the real part of the `MaskedArray`
     |      whose `get_real` method is called.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          The real part of the masked array.
     |      
     |      See Also
     |      --------
     |      get_imag, real, imag
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
     |      >>> x.get_real()
     |      masked_array(data = [1.0 -- 3.45],
     |                   mask = [False  True False],
     |             fill_value = 1e+20)
     |  
     |  hhaarrddeenn__mmaasskk(self)
     |      Force the mask to hard.
     |      
     |      Whether the mask of a masked array is hard or soft is determined by
     |      its `hardmask` property. `harden_mask` sets `hardmask` to True.
     |      
     |      See Also
     |      --------
     |      hardmask
     |  
     |  iiddss(self)
     |      Return the addresses of the data and mask areas.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
     |      >>> x.ids()
     |      (166670640, 166659832)
     |      
     |      If the array has no mask, the address of `nomask` is returned. This address
     |      is typically not close to the data in memory:
     |      
     |      >>> x = np.ma.array([1, 2, 3])
     |      >>> x.ids()
     |      (166691080, 3083169284L)
     |  
     |  iissccoonnttiigguuoouuss(self)
     |      Return a boolean indicating whether the data is contiguous.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1, 2, 3])
     |      >>> x.iscontiguous()
     |      True
     |      
     |      `iscontiguous` returns one of the flags of the masked array:
     |      
     |      >>> x.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : True
     |        OWNDATA : False
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |  
     |  mmaaxx(self, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the maximum along a given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to operate.  By default, ``axis`` is None and the
     |          flattened input is used.
     |      out : array_like, optional
     |          Alternative output array in which to place the result.  Must
     |          be of the same shape and buffer length as the expected output.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |          If None, use the output of maximum_fill_value().
     |      
     |      Returns
     |      -------
     |      amax : array_like
     |          New array holding the result.
     |          If ``out`` was specified, ``out`` is returned.
     |      
     |      See Also
     |      --------
     |      maximum_fill_value
     |          Returns the maximum filling value for a given datatype.
     |  
     |  mmeeaann(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns the average of the array elements along given axis.
     |      
     |      Masked entries are ignored, and result elements which are not
     |      finite will be masked.
     |      
     |      Refer to `numpy.mean` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.mean : corresponding function for ndarrays
     |      numpy.mean : Equivalent function
     |      numpy.ma.average: Weighted average.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([1,2,3], mask=[False, False, True])
     |      >>> a
     |      masked_array(data = [1 2 --],
     |                   mask = [False False  True],
     |             fill_value = 999999)
     |      >>> a.mean()
     |      1.5
     |  
     |  mmiinn(self, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the minimum along a given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to operate.  By default, ``axis`` is None and the
     |          flattened input is used.
     |      out : array_like, optional
     |          Alternative output array in which to place the result.  Must be of
     |          the same shape and buffer length as the expected output.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |          If None, use the output of `minimum_fill_value`.
     |      
     |      Returns
     |      -------
     |      amin : array_like
     |          New array holding the result.
     |          If ``out`` was specified, ``out`` is returned.
     |      
     |      See Also
     |      --------
     |      minimum_fill_value
     |          Returns the minimum filling value for a given datatype.
     |  
     |  mmiinnii(self, axis=None)
     |      Return the array minimum along the specified axis.
     |      
     |      .. deprecated:: 1.13.0
     |         This function is identical to both:
     |      
     |          * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
     |          * ``np.ma.minimum.reduce(self, axis=axis)``
     |      
     |         Typically though, ``self.min(axis=axis)`` is sufficient.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          The axis along which to find the minima. Default is None, in which case
     |          the minimum value in the whole array is returned.
     |      
     |      Returns
     |      -------
     |      min : scalar or MaskedArray
     |          If `axis` is None, the result is a scalar. Otherwise, if `axis` is
     |          given and the array is at least 2-D, the result is a masked array with
     |          dimension one smaller than the array on which `mini` is called.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
     |      >>> print(x)
     |      [[0 --]
     |       [2 3]
     |       [4 --]]
     |      >>> x.mini()
     |      0
     |      >>> x.mini(axis=0)
     |      masked_array(data = [0 3],
     |                   mask = [False False],
     |             fill_value = 999999)
     |      >>> print(x.mini(axis=1))
     |      [0 2 4]
     |      
     |      There is a small difference between `mini` and `min`:
     |      
     |      >>> x[:,1].mini(axis=0)
     |      masked_array(data = --,
     |                   mask = True,
     |             fill_value = 999999)
     |      >>> x[:,1].min(axis=0)
     |      masked
     |  
     |  nnoonnzzeerroo(self)
     |      Return the indices of unmasked elements that are not zero.
     |      
     |      Returns a tuple of arrays, one for each dimension, containing the
     |      indices of the non-zero elements in that dimension. The corresponding
     |      non-zero values can be obtained with::
     |      
     |          a[a.nonzero()]
     |      
     |      To group the indices by element, rather than dimension, use
     |      instead::
     |      
     |          np.transpose(a.nonzero())
     |      
     |      The result of this is always a 2d array, with a row for each non-zero
     |      element.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      tuple_of_arrays : tuple
     |          Indices of elements that are non-zero.
     |      
     |      See Also
     |      --------
     |      numpy.nonzero :
     |          Function operating on ndarrays.
     |      flatnonzero :
     |          Return indices that are non-zero in the flattened version of the input
     |          array.
     |      ndarray.nonzero :
     |          Equivalent ndarray method.
     |      count_nonzero :
     |          Counts the number of non-zero elements in the input array.
     |      
     |      Examples
     |      --------
     |      >>> import numpy.ma as ma
     |      >>> x = ma.array(np.eye(3))
     |      >>> x
     |      masked_array(data =
     |       [[ 1.  0.  0.]
     |       [ 0.  1.  0.]
     |       [ 0.  0.  1.]],
     |            mask =
     |       False,
     |            fill_value=1e+20)
     |      >>> x.nonzero()
     |      (array([0, 1, 2]), array([0, 1, 2]))
     |      
     |      Masked elements are ignored.
     |      
     |      >>> x[1, 1] = ma.masked
     |      >>> x
     |      masked_array(data =
     |       [[1.0 0.0 0.0]
     |       [0.0 -- 0.0]
     |       [0.0 0.0 1.0]],
     |            mask =
     |       [[False False False]
     |       [False  True False]
     |       [False False False]],
     |            fill_value=1e+20)
     |      >>> x.nonzero()
     |      (array([0, 2]), array([0, 2]))
     |      
     |      Indices can also be grouped by element.
     |      
     |      >>> np.transpose(x.nonzero())
     |      array([[0, 0],
     |             [2, 2]])
     |      
     |      A common use for ``nonzero`` is to find the indices of an array, where
     |      a condition is True.  Given an array `a`, the condition `a` > 3 is a
     |      boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
     |      yields the indices of the `a` where the condition is true.
     |      
     |      >>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
     |      >>> a > 3
     |      masked_array(data =
     |       [[False False False]
     |       [ True  True  True]
     |       [ True  True  True]],
     |            mask =
     |       False,
     |            fill_value=999999)
     |      >>> ma.nonzero(a > 3)
     |      (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
     |      
     |      The ``nonzero`` method of the condition array can also be called.
     |      
     |      >>> (a > 3).nonzero()
     |      (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
     |  
     |  ppaarrttiittiioonn(self, *args, **kwargs)
     |      a.partition(kth, axis=-1, kind='introselect', order=None)
     |      
     |      Rearranges the elements in the array in such a way that value of the
     |      element in kth position is in the position it would be in a sorted array.
     |      All elements smaller than the kth element are moved before this element and
     |      all equal or greater are moved behind it. The ordering of the elements in
     |      the two partitions is undefined.
     |      
     |      .. versionadded:: 1.8.0
     |      
     |      Parameters
     |      ----------
     |      kth : int or sequence of ints
     |          Element index to partition by. The kth element value will be in its
     |          final sorted position and all smaller elements will be moved before it
     |          and all equal or greater elements behind it.
     |          The order all elements in the partitions is undefined.
     |          If provided with a sequence of kth it will partition all elements
     |          indexed by kth of them into their sorted position at once.
     |      axis : int, optional
     |          Axis along which to sort. Default is -1, which means sort along the
     |          last axis.
     |      kind : {'introselect'}, optional
     |          Selection algorithm. Default is 'introselect'.
     |      order : str or list of str, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  A single field can
     |          be specified as a string, and not all fields need be specified,
     |          but unspecified fields will still be used, in the order in which
     |          they come up in the dtype, to break ties.
     |      
     |      See Also
     |      --------
     |      numpy.partition : Return a parititioned copy of an array.
     |      argpartition : Indirect partition.
     |      sort : Full sort.
     |      
     |      Notes
     |      -----
     |      See ``np.partition`` for notes on the different algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([3, 4, 2, 1])
     |      >>> a.partition(3)
     |      >>> a
     |      array([2, 1, 3, 4])
     |      
     |      >>> a.partition((1, 3))
     |      array([1, 2, 3, 4])
     |  
     |  pprroodd(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the product of the array elements over the given axis.
     |      
     |      Masked elements are set to 1 internally for computation.
     |      
     |      Refer to `numpy.prod` for full documentation.
     |      
     |      Notes
     |      -----
     |      Arithmetic is modular when using integer types, and no error is raised
     |      on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.prod : corresponding function for ndarrays
     |      numpy.prod : equivalent function
     |  
     |  pprroodduucctt = prod(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |  
     |  ppttpp(self, axis=None, out=None, fill_value=None)
     |      Return (maximum - minimum) along the given dimension
     |      (i.e. peak-to-peak value).
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to find the peaks.  If None (default) the
     |          flattened array is used.
     |      out : {None, array_like}, optional
     |          Alternative output array in which to place the result. It must
     |          have the same shape and buffer length as the expected output
     |          but the type will be cast if necessary.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |      
     |      Returns
     |      -------
     |      ptp : ndarray.
     |          A new array holding the result, unless ``out`` was
     |          specified, in which case a reference to ``out`` is returned.
     |  
     |  ppuutt(self, indices, values, mode='raise')
     |      Set storage-indexed locations to corresponding values.
     |      
     |      Sets self._data.flat[n] = values[n] for each n in indices.
     |      If `values` is shorter than `indices` then it will repeat.
     |      If `values` has some masked values, the initial mask is updated
     |      in consequence, else the corresponding values are unmasked.
     |      
     |      Parameters
     |      ----------
     |      indices : 1-D array_like
     |          Target indices, interpreted as integers.
     |      values : array_like
     |          Values to place in self._data copy at target indices.
     |      mode : {'raise', 'wrap', 'clip'}, optional
     |          Specifies how out-of-bounds indices will behave.
     |          'raise' : raise an error.
     |          'wrap' : wrap around.
     |          'clip' : clip to the range.
     |      
     |      Notes
     |      -----
     |      `values` can be a scalar or length 1 array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> x.put([0,4,8],[10,20,30])
     |      >>> print(x)
     |      [[10 -- 3]
     |       [-- 20 --]
     |       [7 -- 30]]
     |      
     |      >>> x.put(4,999)
     |      >>> print(x)
     |      [[10 -- 3]
     |       [-- 999 --]
     |       [7 -- 30]]
     |  
     |  rraavveell(self, order='C')
     |      Returns a 1D version of self, as a view.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          The elements of `a` are read using this index order. 'C' means to
     |          index the elements in C-like order, with the last axis index
     |          changing fastest, back to the first axis index changing slowest.
     |          'F' means to index the elements in Fortran-like index order, with
     |          the first index changing fastest, and the last index changing
     |          slowest. Note that the 'C' and 'F' options take no account of the
     |          memory layout of the underlying array, and only refer to the order
     |          of axis indexing.  'A' means to read the elements in Fortran-like
     |          index order if `m` is Fortran *contiguous* in memory, C-like order
     |          otherwise.  'K' means to read the elements in the order they occur
     |          in memory, except for reversing the data when strides are negative.
     |          By default, 'C' index order is used.
     |      
     |      Returns
     |      -------
     |      MaskedArray
     |          Output view is of shape ``(self.size,)`` (or
     |          ``(np.ma.product(self.shape),)``).
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.ravel())
     |      [1 -- 3 -- 5 -- 7 -- 9]
     |  
     |  rreeppeeaatt(self, *args, **params)
     |      a.repeat(repeats, axis=None)
     |      
     |      Repeat elements of an array.
     |      
     |      Refer to `numpy.repeat` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.repeat : equivalent function
     |  
     |  rreesshhaappee(self, *s, **kwargs)
     |      Give a new shape to the array without changing its data.
     |      
     |      Returns a masked array containing the same data, but with a new shape.
     |      The result is a view on the original array; if this is not possible, a
     |      ValueError is raised.
     |      
     |      Parameters
     |      ----------
     |      shape : int or tuple of ints
     |          The new shape should be compatible with the original shape. If an
     |          integer is supplied, then the result will be a 1-D array of that
     |          length.
     |      order : {'C', 'F'}, optional
     |          Determines whether the array data should be viewed as in C
     |          (row-major) or FORTRAN (column-major) order.
     |      
     |      Returns
     |      -------
     |      reshaped_array : array
     |          A new view on the array.
     |      
     |      See Also
     |      --------
     |      reshape : Equivalent function in the masked array module.
     |      numpy.ndarray.reshape : Equivalent method on ndarray object.
     |      numpy.reshape : Equivalent function in the NumPy module.
     |      
     |      Notes
     |      -----
     |      The reshaping operation cannot guarantee that a copy will not be made,
     |      to modify the shape in place, use ``a.shape = s``
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
     |      >>> print(x)
     |      [[-- 2]
     |       [3 --]]
     |      >>> x = x.reshape((4,1))
     |      >>> print(x)
     |      [[--]
     |       [2]
     |       [3]
     |       [--]]
     |  
     |  rreessiizzee(self, newshape, refcheck=True, order=False)
     |      .. warning::
     |      
     |          This method does nothing, except raise a ValueError exception. A
     |          masked array does not own its data and therefore cannot safely be
     |          resized in place. Use the `numpy.ma.resize` function instead.
     |      
     |      This method is difficult to implement safely and may be deprecated in
     |      future releases of NumPy.
     |  
     |  rroouunndd(self, decimals=0, out=None)
     |      Return each element rounded to the given number of decimals.
     |      
     |      Refer to `numpy.around` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.around : corresponding function for ndarrays
     |      numpy.around : equivalent function
     |  
     |  sseett__ffiillll__vvaalluuee(self, value=None)
     |      Set the filling value of the masked array.
     |      
     |      Parameters
     |      ----------
     |      value : scalar, optional
     |          The new filling value. Default is None, in which case a default
     |          based on the data type is used.
     |      
     |      See Also
     |      --------
     |      ma.set_fill_value : Equivalent function.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
     |      >>> x.fill_value
     |      -inf
     |      >>> x.set_fill_value(np.pi)
     |      >>> x.fill_value
     |      3.1415926535897931
     |      
     |      Reset to default:
     |      
     |      >>> x.set_fill_value()
     |      >>> x.fill_value
     |      1e+20
     |  
     |  sshhrriinnkk__mmaasskk(self)
     |      Reduce a mask to nomask when possible.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
     |      >>> x.mask
     |      array([[False, False],
     |             [False, False]], dtype=bool)
     |      >>> x.shrink_mask()
     |      >>> x.mask
     |      False
     |  
     |  ssoofftteenn__mmaasskk(self)
     |      Force the mask to soft.
     |      
     |      Whether the mask of a masked array is hard or soft is determined by
     |      its `hardmask` property. `soften_mask` sets `hardmask` to False.
     |      
     |      See Also
     |      --------
     |      hardmask
     |  
     |  ssoorrtt(self, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)
     |      Sort the array, in-place
     |      
     |      Parameters
     |      ----------
     |      a : array_like
     |          Array to be sorted.
     |      axis : int, optional
     |          Axis along which to sort. If None, the array is flattened before
     |          sorting. The default is -1, which sorts along the last axis.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm. Default is 'quicksort'.
     |      order : list, optional
     |          When `a` is a structured array, this argument specifies which fields
     |          to compare first, second, and so on.  This list does not need to
     |          include all of the fields.
     |      endwith : {True, False}, optional
     |          Whether missing values (if any) should be treated as the largest values
     |          (True) or the smallest values (False)
     |          When the array contains unmasked values at the same extremes of the
     |          datatype, the ordering of these values and the masked values is
     |          undefined.
     |      fill_value : {var}, optional
     |          Value used internally for the masked values.
     |          If ``fill_value`` is not None, it supersedes ``endwith``.
     |      
     |      Returns
     |      -------
     |      sorted_array : ndarray
     |          Array of the same type and shape as `a`.
     |      
     |      See Also
     |      --------
     |      ndarray.sort : Method to sort an array in-place.
     |      argsort : Indirect sort.
     |      lexsort : Indirect stable sort on multiple keys.
     |      searchsorted : Find elements in a sorted array.
     |      
     |      Notes
     |      -----
     |      See ``sort`` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # Default
     |      >>> a.sort()
     |      >>> print(a)
     |      [1 3 5 -- --]
     |      
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # Put missing values in the front
     |      >>> a.sort(endwith=False)
     |      >>> print(a)
     |      [-- -- 1 3 5]
     |      
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # fill_value takes over endwith
     |      >>> a.sort(endwith=False, fill_value=3)
     |      >>> print(a)
     |      [1 -- -- 3 5]
     |  
     |  ssqquueeeezzee(self, *args, **params)
     |      a.squeeze(axis=None)
     |      
     |      Remove single-dimensional entries from the shape of `a`.
     |      
     |      Refer to `numpy.squeeze` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.squeeze : equivalent function
     |  
     |  ssttdd(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns the standard deviation of the array elements along given axis.
     |      
     |      Masked entries are ignored.
     |      
     |      Refer to `numpy.std` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.std : corresponding function for ndarrays
     |      numpy.std : Equivalent function
     |  
     |  ssuumm(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the sum of the array elements over the given axis.
     |      
     |      Masked elements are set to 0 internally.
     |      
     |      Refer to `numpy.sum` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.sum : corresponding function for ndarrays
     |      numpy.sum : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.sum())
     |      25
     |      >>> print(x.sum(axis=1))
     |      [4 5 16]
     |      >>> print(x.sum(axis=0))
     |      [8 5 12]
     |      >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
     |      <type 'numpy.int64'>
     |  
     |  sswwaappaaxxeess(self, *args, **params)
     |      a.swapaxes(axis1, axis2)
     |      
     |      Return a view of the array with `axis1` and `axis2` interchanged.
     |      
     |      Refer to `numpy.swapaxes` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.swapaxes : equivalent function
     |  
     |  ttaakkee(self, indices, axis=None, out=None, mode='raise')
     |  
     |  ttoobbyytteess(self, fill_value=None, order='C')
     |      Return the array data as a string containing the raw bytes in the array.
     |      
     |      The array is filled with a fill value before the string conversion.
     |      
     |      .. versionadded:: 1.9.0
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          Value used to fill in the masked values. Default is None, in which
     |          case `MaskedArray.fill_value` is used.
     |      order : {'C','F','A'}, optional
     |          Order of the data item in the copy. Default is 'C'.
     |      
     |          - 'C'   -- C order (row major).
     |          - 'F'   -- Fortran order (column major).
     |          - 'A'   -- Any, current order of array.
     |          - None  -- Same as 'A'.
     |      
     |      See Also
     |      --------
     |      ndarray.tobytes
     |      tolist, tofile
     |      
     |      Notes
     |      -----
     |      As for `ndarray.tobytes`, information about the shape, dtype, etc.,
     |      but also about `fill_value`, will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
     |      >>> x.tobytes()
     |      '\x01\x00\x00\x00?B\x0f\x00?B\x0f\x00\x04\x00\x00\x00'
     |  
     |  ttooffiillee(self, fid, sep='', format='%s')
     |      Save a masked array to a file in binary format.
     |      
     |      .. warning::
     |        This function is not implemented yet.
     |      
     |      Raises
     |      ------
     |      NotImplementedError
     |          When `tofile` is called.
     |  
     |  ttoofflleexx(self)
     |      Transforms a masked array into a flexible-type array.
     |      
     |      The flexible type array that is returned will have two fields:
     |      
     |      * the ``_data`` field stores the ``_data`` part of the array.
     |      * the ``_mask`` field stores the ``_mask`` part of the array.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      record : ndarray
     |          A new flexible-type `ndarray` with two fields: the first element
     |          containing a value, the second element containing the corresponding
     |          mask boolean. The returned record shape matches self.shape.
     |      
     |      Notes
     |      -----
     |      A side-effect of transforming a masked array into a flexible `ndarray` is
     |      that meta information (``fill_value``, ...) will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.toflex())
     |      [[(1, False) (2, True) (3, False)]
     |       [(4, True) (5, False) (6, True)]
     |       [(7, False) (8, True) (9, False)]]
     |  
     |  ttoolliisstt(self, fill_value=None)
     |      Return the data portion of the masked array as a hierarchical Python list.
     |      
     |      Data items are converted to the nearest compatible Python type.
     |      Masked values are converted to `fill_value`. If `fill_value` is None,
     |      the corresponding entries in the output list will be ``None``.
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          The value to use for invalid entries. Default is None.
     |      
     |      Returns
     |      -------
     |      result : list
     |          The Python list representation of the masked array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
     |      >>> x.tolist()
     |      [[1, None, 3], [None, 5, None], [7, None, 9]]
     |      >>> x.tolist(-999)
     |      [[1, -999, 3], [-999, 5, -999], [7, -999, 9]]
     |  
     |  ttoorreeccoorrddss = toflex(self)
     |  
     |  ttoossttrriinngg(self, fill_value=None, order='C')
     |      This function is a compatibility alias for tobytes. Despite its name it
     |      returns bytes not strings.
     |  
     |  ttrraaccee(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      
     |      Return the sum along diagonals of the array.
     |      
     |      Refer to `numpy.trace` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.trace : equivalent function
     |  
     |  ttrraannssppoossee(self, *args, **params)
     |      a.transpose(*axes)
     |      
     |      Returns a view of the array with axes transposed.
     |      
     |      For a 1-D array, this has no effect. (To change between column and
     |      row vectors, first cast the 1-D array into a matrix object.)
     |      For a 2-D array, this is the usual matrix transpose.
     |      For an n-D array, if axes are given, their order indicates how the
     |      axes are permuted (see Examples). If axes are not provided and
     |      ``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
     |      ``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.
     |      
     |      Parameters
     |      ----------
     |      axes : None, tuple of ints, or `n` ints
     |      
     |       * None or no argument: reverses the order of the axes.
     |      
     |       * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
     |         `i`-th axis becomes `a.transpose()`'s `j`-th axis.
     |      
     |       * `n` ints: same as an n-tuple of the same ints (this form is
     |         intended simply as a "convenience" alternative to the tuple form)
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          View of `a`, with axes suitably permuted.
     |      
     |      See Also
     |      --------
     |      ndarray.T : Array property returning the array transposed.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> a
     |      array([[1, 2],
     |             [3, 4]])
     |      >>> a.transpose()
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose((1, 0))
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose(1, 0)
     |      array([[1, 3],
     |             [2, 4]])
     |  
     |  uunnsshhaarree__mmaasskk(self)
     |      Copy the mask and set the sharedmask flag to False.
     |      
     |      Whether the mask is shared between masked arrays can be seen from
     |      the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
     |      A copy of the mask is only made if it was shared.
     |      
     |      See Also
     |      --------
     |      sharedmask
     |  
     |  vvaarr(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class 'numpy._globals._NoValue'>)
     |      Compute the variance along the specified axis.
     |      
     |      Returns the variance of the array elements, a measure of the spread of a
     |      distribution.  The variance is computed for the flattened array by
     |      default, otherwise over the specified axis.
     |      
     |      Parameters
     |      ----------
     |      a : array_like
     |          Array containing numbers whose variance is desired.  If `a` is not an
     |          array, a conversion is attempted.
     |      axis : None or int or tuple of ints, optional
     |          Axis or axes along which the variance is computed.  The default is to
     |          compute the variance of the flattened array.
     |      
     |          .. versionadded:: 1.7.0
     |      
     |          If this is a tuple of ints, a variance is performed over multiple axes,
     |          instead of a single axis or all the axes as before.
     |      dtype : data-type, optional
     |          Type to use in computing the variance.  For arrays of integer type
     |          the default is `float32`; for arrays of float types it is the same as
     |          the array type.
     |      out : ndarray, optional
     |          Alternate output array in which to place the result.  It must have
     |          the same shape as the expected output, but the type is cast if
     |          necessary.
     |      ddof : int, optional
     |          "Delta Degrees of Freedom": the divisor used in the calculation is
     |          ``N - ddof``, where ``N`` represents the number of elements. By
     |          default `ddof` is zero.
     |      keepdims : bool, optional
     |          If this is set to True, the axes which are reduced are left
     |          in the result as dimensions with size one. With this option,
     |          the result will broadcast correctly against the input array.
     |      
     |          If the default value is passed, then `keepdims` will not be
     |          passed through to the `var` method of sub-classes of
     |          `ndarray`, however any non-default value will be.  If the
     |          sub-classes `sum` method does not implement `keepdims` any
     |          exceptions will be raised.
     |      
     |      Returns
     |      -------
     |      variance : ndarray, see dtype parameter above
     |          If ``out=None``, returns a new array containing the variance;
     |          otherwise, a reference to the output array is returned.
     |      
     |      See Also
     |      --------
     |      std , mean, nanmean, nanstd, nanvar
     |      numpy.doc.ufuncs : Section "Output arguments"
     |      
     |      Notes
     |      -----
     |      The variance is the average of the squared deviations from the mean,
     |      i.e.,  ``var = mean(abs(x - x.mean())**2)``.
     |      
     |      The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
     |      If, however, `ddof` is specified, the divisor ``N - ddof`` is used
     |      instead.  In standard statistical practice, ``ddof=1`` provides an
     |      unbiased estimator of the variance of a hypothetical infinite population.
     |      ``ddof=0`` provides a maximum likelihood estimate of the variance for
     |      normally distributed variables.
     |      
     |      Note that for complex numbers, the absolute value is taken before
     |      squaring, so that the result is always real and nonnegative.
     |      
     |      For floating-point input, the variance is computed using the same
     |      precision the input has.  Depending on the input data, this can cause
     |      the results to be inaccurate, especially for `float32` (see example
     |      below).  Specifying a higher-accuracy accumulator using the ``dtype``
     |      keyword can alleviate this issue.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> np.var(a)
     |      1.25
     |      >>> np.var(a, axis=0)
     |      array([ 1.,  1.])
     |      >>> np.var(a, axis=1)
     |      array([ 0.25,  0.25])
     |      
     |      In single precision, var() can be inaccurate:
     |      
     |      >>> a = np.zeros((2, 512*512), dtype=np.float32)
     |      >>> a[0, :] = 1.0
     |      >>> a[1, :] = 0.1
     |      >>> np.var(a)
     |      0.20250003
     |      
     |      Computing the variance in float64 is more accurate:
     |      
     |      >>> np.var(a, dtype=np.float64)
     |      0.20249999932944759
     |      >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
     |      0.2025
     |  
     |  vviieeww(self, dtype=None, type=None, fill_value=None)
     |      a.view(dtype=None, type=None)
     |      
     |      New view of array with the same data.
     |      
     |      Parameters
     |      ----------
     |      dtype : data-type or ndarray sub-class, optional
     |          Data-type descriptor of the returned view, e.g., float32 or int16. The
     |          default, None, results in the view having the same data-type as `a`.
     |          This argument can also be specified as an ndarray sub-class, which
     |          then specifies the type of the returned object (this is equivalent to
     |          setting the ``type`` parameter).
     |      type : Python type, optional
     |          Type of the returned view, e.g., ndarray or matrix.  Again, the
     |          default None results in type preservation.
     |      
     |      Notes
     |      -----
     |      ``a.view()`` is used two different ways:
     |      
     |      ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
     |      of the array's memory with a different data-type.  This can cause a
     |      reinterpretation of the bytes of memory.
     |      
     |      ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
     |      returns an instance of `ndarray_subclass` that looks at the same array
     |      (same shape, dtype, etc.)  This does not cause a reinterpretation of the
     |      memory.
     |      
     |      For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
     |      bytes per entry than the previous dtype (for example, converting a
     |      regular array to a structured array), then the behavior of the view
     |      cannot be predicted just from the superficial appearance of ``a`` (shown
     |      by ``print(a)``). It also depends on exactly how ``a`` is stored in
     |      memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
     |      defined as a slice or transpose, etc., the view may give different
     |      results.
     |      
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])
     |      
     |      Viewing array data using a different type and dtype:
     |      
     |      >>> y = x.view(dtype=np.int16, type=np.matrix)
     |      >>> y
     |      matrix([[513]], dtype=int16)
     |      >>> print(type(y))
     |      <class 'numpy.matrixlib.defmatrix.matrix'>
     |      
     |      Creating a view on a structured array so it can be used in calculations
     |      
     |      >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
     |      >>> xv = x.view(dtype=np.int8).reshape(-1,2)
     |      >>> xv
     |      array([[1, 2],
     |             [3, 4]], dtype=int8)
     |      >>> xv.mean(0)
     |      array([ 2.,  3.])
     |      
     |      Making changes to the view changes the underlying array
     |      
     |      >>> xv[0,1] = 20
     |      >>> print(x)
     |      [(1, 20) (3, 4)]
     |      
     |      Using a view to convert an array to a recarray:
     |      
     |      >>> z = x.view(np.recarray)
     |      >>> z.a
     |      array([1], dtype=int8)
     |      
     |      Views share data:
     |      
     |      >>> x[0] = (9, 10)
     |      >>> z[0]
     |      (9, 10)
     |      
     |      Views that change the dtype size (bytes per entry) should normally be
     |      avoided on arrays defined by slices, transposes, fortran-ordering, etc.:
     |      
     |      >>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
     |      >>> y = x[:, 0:2]
     |      >>> y
     |      array([[1, 2],
     |             [4, 5]], dtype=int16)
     |      >>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: new type not compatible with array.
     |      >>> z = y.copy()
     |      >>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
     |      array([[(1, 2)],
     |             [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  ____nneeww____(cls, data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None, **options)
     |      Create a new masked array from scratch.
     |      
     |      Notes
     |      -----
     |      A masked array can also be created by taking a .view(MaskedArray).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  TT
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  bbaasseeccllaassss
     |      Class of the underlying data (read-only).
     |  
     |  ddaattaa
     |      Return the current data, as a view of the original
     |      underlying data.
     |  
     |  ffiillll__vvaalluuee
     |      Filling value.
     |  
     |  ffllaatt
     |      Flat version of the array.
     |  
     |  hhaarrddmmaasskk
     |      Hardness of the mask
     |  
     |  iimmaagg
     |      Imaginary part.
     |  
     |  mmaasskk
     |      Mask
     |  
     |  rreeaall
     |      Real part
     |  
     |  rreeccoorrddmmaasskk
     |      Return the mask of the records.
     |      
     |      A record is masked when all the fields are masked.
     |  
     |  sshhaarreeddmmaasskk
     |      Share status of the mask (read-only).
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aarrrraayy__pprriioorriittyy____ = 15
     |  
     |  ____hhaasshh____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from numpy.ndarray:
     |  
     |  ____aabbss____(self, /)
     |      abs(self)
     |  
     |  ____aanndd____(self, value, /)
     |      Return self&value.
     |  
     |  ____aarrrraayy____(...)
     |      a.__array__(|dtype) -> reference if type unchanged, copy otherwise.
     |      
     |      Returns either a new reference to self if dtype is not given or a new array
     |      of provided data type if dtype is different from the current dtype of the
     |      array.
     |  
     |  ____aarrrraayy__pprreeppaarree____(...)
     |      a.__array_prepare__(obj) -> Object of same type as ndarray object obj.
     |  
     |  ____aarrrraayy__uuffuunncc____(...)
     |  
     |  ____bbooooll____(self, /)
     |      self != 0
     |  
     |  ____ccoommpplleexx____(...)
     |  
     |  ____ccoonnttaaiinnss____(self, key, /)
     |      Return key in self.
     |  
     |  ____ccooppyy____(...)
     |      a.__copy__([order])
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A'}, optional
     |          If order is 'C' (False) then the result is contiguous (default).
     |          If order is 'Fortran' (True) then the result has fortran order.
     |          If order is 'Any' (None) then the result has fortran order
     |          only if the array already is in fortran order.
     |  
     |  ____ddeelliitteemm____(self, key, /)
     |      Delete self[key].
     |  
     |  ____ddiivvmmoodd____(self, value, /)
     |      Return divmod(self, value).
     |  
     |  ____ggee____(self, value, /)
     |      Return self>=value.
     |  
     |  ____ggtt____(self, value, /)
     |      Return self>value.
     |  
     |  ____iiaanndd____(self, value, /)
     |      Return self&=value.
     |  
     |  ____iillsshhiifftt____(self, value, /)
     |      Return self<<=value.
     |  
     |  ____iimmaattmmuull____(self, value, /)
     |      Return self@=value.
     |  
     |  ____iimmoodd____(self, value, /)
     |      Return self%=value.
     |  
     |  ____iinnddeexx____(self, /)
     |      Return self converted to an integer, if self is suitable for use as an index into a list.
     |  
     |  ____iinnvveerrtt____(self, /)
     |      ~self
     |  
     |  ____iioorr____(self, value, /)
     |      Return self|=value.
     |  
     |  ____iirrsshhiifftt____(self, value, /)
     |      Return self>>=value.
     |  
     |  ____iitteerr____(self, /)
     |      Implement iter(self).
     |  
     |  ____iixxoorr____(self, value, /)
     |      Return self^=value.
     |  
     |  ____llee____(self, value, /)
     |      Return self<=value.
     |  
     |  ____lleenn____(self, /)
     |      Return len(self).
     |  
     |  ____llsshhiifftt____(self, value, /)
     |      Return self<<value.
     |  
     |  ____lltt____(self, value, /)
     |      Return self<value.
     |  
     |  ____mmaattmmuull____(self, value, /)
     |      Return self@value.
     |  
     |  ____mmoodd____(self, value, /)
     |      Return self%value.
     |  
     |  ____nneegg____(self, /)
     |      -self
     |  
     |  ____oorr____(self, value, /)
     |      Return self|value.
     |  
     |  ____ppooss____(self, /)
     |      +self
     |  
     |  ____rraanndd____(self, value, /)
     |      Return value&self.
     |  
     |  ____rrddiivvmmoodd____(self, value, /)
     |      Return divmod(value, self).
     |  
     |  ____rrllsshhiifftt____(self, value, /)
     |      Return value<<self.
     |  
     |  ____rrmmaattmmuull____(self, value, /)
     |      Return value@self.
     |  
     |  ____rrmmoodd____(self, value, /)
     |      Return value%self.
     |  
     |  ____rroorr____(self, value, /)
     |      Return value|self.
     |  
     |  ____rrrrsshhiifftt____(self, value, /)
     |      Return value>>self.
     |  
     |  ____rrsshhiifftt____(self, value, /)
     |      Return self>>value.
     |  
     |  ____rrxxoorr____(self, value, /)
     |      Return value^self.
     |  
     |  ____ssiizzeeooff____(...)
     |      __sizeof__() -> int
     |      size of object in memory, in bytes
     |  
     |  ____xxoorr____(self, value, /)
     |      Return self^value.
     |  
     |  bbyytteesswwaapp(...)
     |      a.byteswap(inplace)
     |      
     |      Swap the bytes of the array elements
     |      
     |      Toggle between low-endian and big-endian data representation by
     |      returning a byteswapped array, optionally swapped in-place.
     |      
     |      Parameters
     |      ----------
     |      inplace : bool, optional
     |          If ``True``, swap bytes in-place, default is ``False``.
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          The byteswapped array. If `inplace` is ``True``, this is
     |          a view to self.
     |      
     |      Examples
     |      --------
     |      >>> A = np.array([1, 256, 8755], dtype=np.int16)
     |      >>> map(hex, A)
     |      ['0x1', '0x100', '0x2233']
     |      >>> A.byteswap(True)
     |      array([  256,     1, 13090], dtype=int16)
     |      >>> map(hex, A)
     |      ['0x100', '0x1', '0x3322']
     |      
     |      Arrays of strings are not swapped
     |      
     |      >>> A = np.array(['ceg', 'fac'])
     |      >>> A.byteswap()
     |      array(['ceg', 'fac'],
     |            dtype='|S3')
     |  
     |  cchhoooossee(...)
     |      a.choose(choices, out=None, mode='raise')
     |      
     |      Use an index array to construct a new array from a set of choices.
     |      
     |      Refer to `numpy.choose` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.choose : equivalent function
     |  
     |  ccoonnjj(...)
     |      a.conj()
     |      
     |      Complex-conjugate all elements.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  ccoonnjjuuggaattee(...)
     |      a.conjugate()
     |      
     |      Return the complex conjugate, element-wise.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  dduummpp(...)
     |      a.dump(file)
     |      
     |      Dump a pickle of the array to the specified file.
     |      The array can be read back with pickle.load or numpy.load.
     |      
     |      Parameters
     |      ----------
     |      file : str
     |          A string naming the dump file.
     |  
     |  dduummppss(...)
     |      a.dumps()
     |      
     |      Returns the pickle of the array as a string.
     |      pickle.loads or numpy.loads will convert the string back to an array.
     |      
     |      Parameters
     |      ----------
     |      None
     |  
     |  ffiillll(...)
     |      a.fill(value)
     |      
     |      Fill the array with a scalar value.
     |      
     |      Parameters
     |      ----------
     |      value : scalar
     |          All elements of `a` will be assigned this value.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([1, 2])
     |      >>> a.fill(0)
     |      >>> a
     |      array([0, 0])
     |      >>> a = np.empty(2)
     |      >>> a.fill(1)
     |      >>> a
     |      array([ 1.,  1.])
     |  
     |  ggeettffiieelldd(...)
     |      a.getfield(dtype, offset=0)
     |      
     |      Returns a field of the given array as a certain type.
     |      
     |      A field is a view of the array data with a given data-type. The values in
     |      the view are determined by the given type and the offset into the current
     |      array in bytes. The offset needs to be such that the view dtype fits in the
     |      array dtype; for example an array of dtype complex128 has 16-byte elements.
     |      If taking a view with a 32-bit integer (4 bytes), the offset needs to be
     |      between 0 and 12 bytes.
     |      
     |      Parameters
     |      ----------
     |      dtype : str or dtype
     |          The data type of the view. The dtype size of the view can not be larger
     |          than that of the array itself.
     |      offset : int
     |          Number of bytes to skip before beginning the element view.
     |      
     |      Examples
     |      --------
     |      >>> x = np.diag([1.+1.j]*2)
     |      >>> x[1, 1] = 2 + 4.j
     |      >>> x
     |      array([[ 1.+1.j,  0.+0.j],
     |             [ 0.+0.j,  2.+4.j]])
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.],
     |             [ 0.,  2.]])
     |      
     |      By choosing an offset of 8 bytes we can select the complex part of the
     |      array for our view:
     |      
     |      >>> x.getfield(np.float64, offset=8)
     |      array([[ 1.,  0.],
     |         [ 0.,  4.]])
     |  
     |  iitteemm(...)
     |      a.item(*args)
     |      
     |      Copy an element of an array to a standard Python scalar and return it.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments (variable number and type)
     |      
     |          * none: in this case, the method only works for arrays
     |            with one element (`a.size == 1`), which element is
     |            copied into a standard Python scalar object and returned.
     |      
     |          * int_type: this argument is interpreted as a flat index into
     |            the array, specifying which element to copy and return.
     |      
     |          * tuple of int_types: functions as does a single int_type argument,
     |            except that the argument is interpreted as an nd-index into the
     |            array.
     |      
     |      Returns
     |      -------
     |      z : Standard Python scalar object
     |          A copy of the specified element of the array as a suitable
     |          Python scalar
     |      
     |      Notes
     |      -----
     |      When the data type of `a` is longdouble or clongdouble, item() returns
     |      a scalar array object because there is no available Python scalar that
     |      would not lose information. Void arrays return a buffer object for item(),
     |      unless fields are defined, in which case a tuple is returned.
     |      
     |      `item` is very similar to a[args], except, instead of an array scalar,
     |      a standard Python scalar is returned. This can be useful for speeding up
     |      access to elements of the array and doing arithmetic on elements of the
     |      array using Python's optimized math.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.item(3)
     |      2
     |      >>> x.item(7)
     |      5
     |      >>> x.item((0, 1))
     |      1
     |      >>> x.item((2, 2))
     |      3
     |  
     |  iitteemmsseett(...)
     |      a.itemset(*args)
     |      
     |      Insert scalar into an array (scalar is cast to array's dtype, if possible)
     |      
     |      There must be at least 1 argument, and define the last argument
     |      as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster
     |      than ``a[args] = item``.  The item should be a scalar value and `args`
     |      must select a single item in the array `a`.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments
     |          If one argument: a scalar, only used in case `a` is of size 1.
     |          If two arguments: the last argument is the value to be set
     |          and must be a scalar, the first argument specifies a single array
     |          element location. It is either an int or a tuple.
     |      
     |      Notes
     |      -----
     |      Compared to indexing syntax, `itemset` provides some speed increase
     |      for placing a scalar into a particular location in an `ndarray`,
     |      if you must do this.  However, generally this is discouraged:
     |      among other problems, it complicates the appearance of the code.
     |      Also, when using `itemset` (and `item`) inside a loop, be sure
     |      to assign the methods to a local variable to avoid the attribute
     |      look-up at each loop iteration.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.itemset(4, 0)
     |      >>> x.itemset((2, 2), 9)
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 0, 3],
     |             [8, 5, 9]])
     |  
     |  nneewwbbyytteeoorrddeerr(...)
     |      arr.newbyteorder(new_order='S')
     |      
     |      Return the array with the same data viewed with a different byte order.
     |      
     |      Equivalent to::
     |      
     |          arr.view(arr.dtype.newbytorder(new_order))
     |      
     |      Changes are also made in all fields and sub-arrays of the array data
     |      type.
     |      
     |      
     |      
     |      Parameters
     |      ----------
     |      new_order : string, optional
     |          Byte order to force; a value from the byte order specifications
     |          below. `new_order` codes can be any of:
     |      
     |          * 'S' - swap dtype from current to opposite endian
     |          * {'<', 'L'} - little endian
     |          * {'>', 'B'} - big endian
     |          * {'=', 'N'} - native order
     |          * {'|', 'I'} - ignore (no change to byte order)
     |      
     |          The default value ('S') results in swapping the current
     |          byte order. The code does a case-insensitive check on the first
     |          letter of `new_order` for the alternatives above.  For example,
     |          any of 'B' or 'b' or 'biggish' are valid to specify big-endian.
     |      
     |      
     |      Returns
     |      -------
     |      new_arr : array
     |          New array object with the dtype reflecting given change to the
     |          byte order.
     |  
     |  sseeaarrcchhssoorrtteedd(...)
     |      a.searchsorted(v, side='left', sorter=None)
     |      
     |      Find indices where elements of v should be inserted in a to maintain order.
     |      
     |      For full documentation, see `numpy.searchsorted`
     |      
     |      See Also
     |      --------
     |      numpy.searchsorted : equivalent function
     |  
     |  sseettffiieelldd(...)
     |      a.setfield(val, dtype, offset=0)
     |      
     |      Put a value into a specified place in a field defined by a data-type.
     |      
     |      Place `val` into `a`'s field defined by `dtype` and beginning `offset`
     |      bytes into the field.
     |      
     |      Parameters
     |      ----------
     |      val : object
     |          Value to be placed in field.
     |      dtype : dtype object
     |          Data-type of the field in which to place `val`.
     |      offset : int, optional
     |          The number of bytes into the field at which to place `val`.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      See Also
     |      --------
     |      getfield
     |      
     |      Examples
     |      --------
     |      >>> x = np.eye(3)
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |      >>> x.setfield(3, np.int32)
     |      >>> x.getfield(np.int32)
     |      array([[3, 3, 3],
     |             [3, 3, 3],
     |             [3, 3, 3]])
     |      >>> x
     |      array([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],
     |             [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],
     |             [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])
     |      >>> x.setfield(np.eye(3), np.int32)
     |      >>> x
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |  
     |  sseettffllaaggss(...)
     |      a.setflags(write=None, align=None, uic=None)
     |      
     |      Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.
     |      
     |      These Boolean-valued flags affect how numpy interprets the memory
     |      area used by `a` (see Notes below). The ALIGNED flag can only
     |      be set to True if the data is actually aligned according to the type.
     |      The UPDATEIFCOPY flag can never be set to True. The flag WRITEABLE
     |      can only be set to True if the array owns its own memory, or the
     |      ultimate owner of the memory exposes a writeable buffer interface,
     |      or is a string. (The exception for string is made so that unpickling
     |      can be done without copying memory.)
     |      
     |      Parameters
     |      ----------
     |      write : bool, optional
     |          Describes whether or not `a` can be written to.
     |      align : bool, optional
     |          Describes whether or not `a` is aligned properly for its type.
     |      uic : bool, optional
     |          Describes whether or not `a` is a copy of another "base" array.
     |      
     |      Notes
     |      -----
     |      Array flags provide information about how the memory area used
     |      for the array is to be interpreted. There are 6 Boolean flags
     |      in use, only three of which can be changed by the user:
     |      UPDATEIFCOPY, WRITEABLE, and ALIGNED.
     |      
     |      WRITEABLE (W) the data area can be written to;
     |      
     |      ALIGNED (A) the data and strides are aligned appropriately for the hardware
     |      (as determined by the compiler);
     |      
     |      UPDATEIFCOPY (U) this array is a copy of some other array (referenced
     |      by .base). When this array is deallocated, the base array will be
     |      updated with the contents of this array.
     |      
     |      All flags can be accessed using their first (upper case) letter as well
     |      as the full name.
     |      
     |      Examples
     |      --------
     |      >>> y
     |      array([[3, 1, 7],
     |             [2, 0, 0],
     |             [8, 5, 9]])
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(write=0, align=0)
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : False
     |        ALIGNED : False
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(uic=1)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: cannot set UPDATEIFCOPY flag to True
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from numpy.ndarray:
     |  
     |  ____aarrrraayy__iinntteerrffaaccee____
     |      Array protocol: Python side.
     |  
     |  ____aarrrraayy__ssttrruucctt____
     |      Array protocol: C-struct side.
     |  
     |  bbaassee
     |      Base object if memory is from some other object.
     |      
     |      Examples
     |      --------
     |      The base of an array that owns its memory is None:
     |      
     |      >>> x = np.array([1,2,3,4])
     |      >>> x.base is None
     |      True
     |      
     |      Slicing creates a view, whose memory is shared with x:
     |      
     |      >>> y = x[2:]
     |      >>> y.base is x
     |      True
     |  
     |  ccttyyppeess
     |      An object to simplify the interaction of the array with the ctypes
     |      module.
     |      
     |      This attribute creates an object that makes it easier to use arrays
     |      when calling shared libraries with the ctypes module. The returned
     |      object has, among others, data, shape, and strides attributes (see
     |      Notes below) which themselves return ctypes objects that can be used
     |      as arguments to a shared library.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      c : Python object
     |          Possessing attributes data, shape, strides, etc.
     |      
     |      See Also
     |      --------
     |      numpy.ctypeslib
     |      
     |      Notes
     |      -----
     |      Below are the public attributes of this object which were documented
     |      in "Guide to NumPy" (we have omitted undocumented public attributes,
     |      as well as documented private attributes):
     |      
     |      * data: A pointer to the memory area of the array as a Python integer.
     |        This memory area may contain data that is not aligned, or not in correct
     |        byte-order. The memory area may not even be writeable. The array
     |        flags and data-type of this array should be respected when passing this
     |        attribute to arbitrary C-code to avoid trouble that can include Python
     |        crashing. User Beware! The value of this attribute is exactly the same
     |        as self._array_interface_['data'][0].
     |      
     |      * shape (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the C-integer corresponding to dtype('p') on this
     |        platform. This base-type could be c_int, c_long, or c_longlong
     |        depending on the platform. The c_intp type is defined accordingly in
     |        numpy.ctypeslib. The ctypes array contains the shape of the underlying
     |        array.
     |      
     |      * strides (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the same as for the shape attribute. This ctypes array
     |        contains the strides information from the underlying array. This strides
     |        information is important for showing how many bytes must be jumped to
     |        get to the next element in the array.
     |      
     |      * data_as(obj): Return the data pointer cast to a particular c-types object.
     |        For example, calling self._as_parameter_ is equivalent to
     |        self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
     |        pointer to a ctypes array of floating-point data:
     |        self.data_as(ctypes.POINTER(ctypes.c_double)).
     |      
     |      * shape_as(obj): Return the shape tuple as an array of some other c-types
     |        type. For example: self.shape_as(ctypes.c_short).
     |      
     |      * strides_as(obj): Return the strides tuple as an array of some other
     |        c-types type. For example: self.strides_as(ctypes.c_longlong).
     |      
     |      Be careful using the ctypes attribute - especially on temporary
     |      arrays or arrays constructed on the fly. For example, calling
     |      ``(a+b).ctypes.data_as(ctypes.c_void_p)`` returns a pointer to memory
     |      that is invalid because the array created as (a+b) is deallocated
     |      before the next Python statement. You can avoid this problem using
     |      either ``c=a+b`` or ``ct=(a+b).ctypes``. In the latter case, ct will
     |      hold a reference to the array until ct is deleted or re-assigned.
     |      
     |      If the ctypes module is not available, then the ctypes attribute
     |      of array objects still returns something useful, but ctypes objects
     |      are not returned and errors may be raised instead. In particular,
     |      the object will still have the as parameter attribute which will
     |      return an integer equal to the data attribute.
     |      
     |      Examples
     |      --------
     |      >>> import ctypes
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.ctypes.data
     |      30439712
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))
     |      <ctypes.LP_c_long object at 0x01F01300>
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents
     |      c_long(0)
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents
     |      c_longlong(4294967296L)
     |      >>> x.ctypes.shape
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FFD580>
     |      >>> x.ctypes.shape_as(ctypes.c_long)
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides_as(ctypes.c_longlong)
     |      <numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>
     |  
     |  ddttyyppee
     |      Data-type of the array's elements.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      d : numpy dtype object
     |      
     |      See Also
     |      --------
     |      numpy.dtype
     |      
     |      Examples
     |      --------
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.dtype
     |      dtype('int32')
     |      >>> type(x.dtype)
     |      <type 'numpy.dtype'>
     |  
     |  ffllaaggss
     |      Information about the memory layout of the array.
     |      
     |      Attributes
     |      ----------
     |      C_CONTIGUOUS (C)
     |          The data is in a single, C-style contiguous segment.
     |      F_CONTIGUOUS (F)
     |          The data is in a single, Fortran-style contiguous segment.
     |      OWNDATA (O)
     |          The array owns the memory it uses or borrows it from another object.
     |      WRITEABLE (W)
     |          The data area can be written to.  Setting this to False locks
     |          the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
     |          from its base array at creation time, but a view of a writeable
     |          array may be subsequently locked while the base array remains writeable.
     |          (The opposite is not true, in that a view of a locked array may not
     |          be made writeable.  However, currently, locking a base object does not
     |          lock any views that already reference it, so under that circumstance it
     |          is possible to alter the contents of a locked array via a previously
     |          created writeable view onto it.)  Attempting to change a non-writeable
     |          array raises a RuntimeError exception.
     |      ALIGNED (A)
     |          The data and all elements are aligned appropriately for the hardware.
     |      UPDATEIFCOPY (U)
     |          This array is a copy of some other array. When this array is
     |          deallocated, the base array will be updated with the contents of
     |          this array.
     |      FNC
     |          F_CONTIGUOUS and not C_CONTIGUOUS.
     |      FORC
     |          F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
     |      BEHAVED (B)
     |          ALIGNED and WRITEABLE.
     |      CARRAY (CA)
     |          BEHAVED and C_CONTIGUOUS.
     |      FARRAY (FA)
     |          BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.
     |      
     |      Notes
     |      -----
     |      The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
     |      or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
     |      names are only supported in dictionary access.
     |      
     |      Only the UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by
     |      the user, via direct assignment to the attribute or dictionary entry,
     |      or by calling `ndarray.setflags`.
     |      
     |      The array flags cannot be set arbitrarily:
     |      
     |      - UPDATEIFCOPY can only be set ``False``.
     |      - ALIGNED can only be set ``True`` if the data is truly aligned.
     |      - WRITEABLE can only be set ``True`` if the array owns its own memory
     |        or the ultimate owner of the memory exposes a writeable buffer
     |        interface or is a string.
     |      
     |      Arrays can be both C-style and Fortran-style contiguous simultaneously.
     |      This is clear for 1-dimensional arrays, but can also be true for higher
     |      dimensional arrays.
     |      
     |      Even for contiguous arrays a stride for a given dimension
     |      ``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``
     |      or the array has no elements.
     |      It does *not* generally hold that ``self.strides[-1] == self.itemsize``
     |      for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for
     |      Fortran-style contiguous arrays is true.
     |  
     |  iitteemmssiizzee
     |      Length of one array element in bytes.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1,2,3], dtype=np.float64)
     |      >>> x.itemsize
     |      8
     |      >>> x = np.array([1,2,3], dtype=np.complex128)
     |      >>> x.itemsize
     |      16
     |  
     |  nnbbyytteess
     |      Total bytes consumed by the elements of the array.
     |      
     |      Notes
     |      -----
     |      Does not include memory consumed by non-element attributes of the
     |      array object.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3,5,2), dtype=np.complex128)
     |      >>> x.nbytes
     |      480
     |      >>> np.prod(x.shape) * x.itemsize
     |      480
     |  
     |  nnddiimm
     |      Number of array dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3])
     |      >>> x.ndim
     |      1
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.ndim
     |      3
     |  
     |  sshhaappee
     |      Tuple of array dimensions.
     |      
     |      Notes
     |      -----
     |      May be used to "reshape" the array, as long as this would not
     |      require a change in the total number of elements
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3, 4])
     |      >>> x.shape
     |      (4,)
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.shape
     |      (2, 3, 4)
     |      >>> y.shape = (3, 8)
     |      >>> y
     |      array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
     |      >>> y.shape = (3, 6)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: total size of new array must be unchanged
     |  
     |  ssiizzee
     |      Number of elements in the array.
     |      
     |      Equivalent to ``np.prod(a.shape)``, i.e., the product of the array's
     |      dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3, 5, 2), dtype=np.complex128)
     |      >>> x.size
     |      30
     |      >>> np.prod(x.shape)
     |      30
     |  
     |  ssttrriiddeess
     |      Tuple of bytes to step in each dimension when traversing an array.
     |      
     |      The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
     |      is::
     |      
     |          offset = sum(np.array(i) * a.strides)
     |      
     |      A more detailed explanation of strides can be found in the
     |      "ndarray.rst" file in the NumPy reference guide.
     |      
     |      Notes
     |      -----
     |      Imagine an array of 32-bit integers (each 4 bytes)::
     |      
     |        x = np.array([[0, 1, 2, 3, 4],
     |                      [5, 6, 7, 8, 9]], dtype=np.int32)
     |      
     |      This array is stored in memory as 40 bytes, one after the other
     |      (known as a contiguous block of memory).  The strides of an array tell
     |      us how many bytes we have to skip in memory to move to the next position
     |      along a certain axis.  For example, we have to skip 4 bytes (1 value) to
     |      move to the next column, but 20 bytes (5 values) to get to the same
     |      position in the next row.  As such, the strides for the array `x` will be
     |      ``(20, 4)``.
     |      
     |      See Also
     |      --------
     |      numpy.lib.stride_tricks.as_strided
     |      
     |      Examples
     |      --------
     |      >>> y = np.reshape(np.arange(2*3*4), (2,3,4))
     |      >>> y
     |      array([[[ 0,  1,  2,  3],
     |              [ 4,  5,  6,  7],
     |              [ 8,  9, 10, 11]],
     |             [[12, 13, 14, 15],
     |              [16, 17, 18, 19],
     |              [20, 21, 22, 23]]])
     |      >>> y.strides
     |      (48, 16, 4)
     |      >>> y[1,1,1]
     |      17
     |      >>> offset=sum(y.strides * np.array((1,1,1)))
     |      >>> offset/y.itemsize
     |      17
     |      
     |      >>> x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)
     |      >>> x.strides
     |      (32, 4, 224, 1344)
     |      >>> i = np.array([3,5,2,2])
     |      >>> offset = sum(i * x.strides)
     |      >>> x[3,5,2,2]
     |      813
     |      >>> offset / x.itemsize
     |      813
    
    class mmvvooiidd(MaskedArray)
     |  Fake a 'void' object to use for masked array with structured dtypes.
     |  
     |  Method resolution order:
     |      mvoid
     |      MaskedArray
     |      numpy.ndarray
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____ggeettiitteemm____(self, indx)
     |      Get the index.
     |  
     |  ____iitteerr____(self)
     |      Defines an iterator for mvoid
     |  
     |  ____lleenn____(self)
     |      Return len(self).
     |  
     |  ____rreepprr____ = __str__(self)
     |  
     |  ____sseettiitteemm____(self, indx, value)
     |      x.__setitem__(i, y) <==> x[i]=y
     |      
     |      Set item described by index. If value is masked, masks those
     |      locations.
     |  
     |  ____ssttrr____(self)
     |      String representation.
     |  
     |  ffiilllleedd(self, fill_value=None)
     |      Return a copy with masked fields filled with a given value.
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          The value to use for invalid entries (None by default).
     |          If None, the `fill_value` attribute is used instead.
     |      
     |      Returns
     |      -------
     |      filled_void
     |          A `np.void` object
     |      
     |      See Also
     |      --------
     |      MaskedArray.filled
     |  
     |  ttoolliisstt(self)
     |      Transforms the mvoid object into a tuple.
     |      
     |      Masked fields are replaced by None.
     |      
     |      Returns
     |      -------
     |      returned_tuple
     |          Tuple of fields
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  ____nneeww____(self, data, mask=False, dtype=None, fill_value=None, hardmask=False, copy=False, subok=True)
     |      Create a new masked array from scratch.
     |      
     |      Notes
     |      -----
     |      A masked array can also be created by taking a .view(MaskedArray).
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from MaskedArray:
     |  
     |  ____aadddd____(self, other)
     |      Add self to other, and return a new masked array.
     |  
     |  ____aarrrraayy__ffiinnaalliizzee____(self, obj)
     |      Finalizes the masked array.
     |  
     |  ____aarrrraayy__wwrraapp____(self, obj, context=None)
     |      Special hook for ufuncs.
     |      
     |      Wraps the numpy array and sets the mask according to context.
     |  
     |  ____ddeeeeppccooppyy____(self, memo=None)
     |      a.__deepcopy__() -> Deep copy of array.
     |      
     |      Used if copy.deepcopy is called on an array.
     |  
     |  ____ddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  ____eeqq____(self, other)
     |      Check whether other equals self elementwise.
     |      
     |      When either of the elements is masked, the result is masked as well,
     |      but the underlying boolean data are still set, with self and other
     |      considered equal if both are masked, and unequal otherwise.
     |      
     |      For structured arrays, all fields are combined, with masked values
     |      ignored. The result is masked if all fields were masked, with self
     |      and other considered equal only if both were fully masked.
     |  
     |  ____ffllooaatt____(self)
     |      Convert to float.
     |  
     |  ____fflloooorrddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  ____ggeettssttaattee____(self)
     |      Return the internal state of the masked array, for pickling
     |      purposes.
     |  
     |  ____iiaadddd____(self, other)
     |      Add other to self in-place.
     |  
     |  ____iiddiivv____(self, other)
     |      Divide self by other in-place.
     |  
     |  ____iifflloooorrddiivv____(self, other)
     |      Floor divide self by other in-place.
     |  
     |  ____iimmuull____(self, other)
     |      Multiply self by other in-place.
     |  
     |  ____iinntt____(self)
     |      Convert to int.
     |  
     |  ____iippooww____(self, other)
     |      Raise self to the power other, in place.
     |  
     |  ____iissuubb____(self, other)
     |      Subtract other from self in-place.
     |  
     |  ____iittrruueeddiivv____(self, other)
     |      True divide self by other in-place.
     |  
     |  ____mmuull____(self, other)
     |      Multiply self by other, and return a new masked array.
     |  
     |  ____nnee____(self, other)
     |      Check whether other does not equal self elementwise.
     |      
     |      When either of the elements is masked, the result is masked as well,
     |      but the underlying boolean data are still set, with self and other
     |      considered equal if both are masked, and unequal otherwise.
     |      
     |      For structured arrays, all fields are combined, with masked values
     |      ignored. The result is masked if all fields were masked, with self
     |      and other considered equal only if both were fully masked.
     |  
     |  ____ppooww____(self, other)
     |      Raise self to the power other, masking the potential NaNs/Infs
     |  
     |  ____rraadddd____(self, other)
     |      Add other to self, and return a new masked array.
     |  
     |  ____rreedduuccee____(self)
     |      Return a 3-tuple for pickling a MaskedArray.
     |  
     |  ____rrfflloooorrddiivv____(self, other)
     |      Divide self into other, and return a new masked array.
     |  
     |  ____rrmmuull____(self, other)
     |      Multiply other by self, and return a new masked array.
     |  
     |  ____rrppooww____(self, other)
     |      Raise other to the power self, masking the potential NaNs/Infs
     |  
     |  ____rrssuubb____(self, other)
     |      Subtract self from other, and return a new masked array.
     |  
     |  ____rrttrruueeddiivv____(self, other)
     |      Divide self into other, and return a new masked array.
     |  
     |  ____sseettaattttrr____(self, attr, value)
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettmmaasskk____(self, mask, copy=False)
     |      Set the mask.
     |  
     |  ____sseettssttaattee____(self, state)
     |      Restore the internal state of the masked array, for
     |      pickling purposes.  ``state`` is typically the output of the
     |      ``__getstate__`` output, and is a 5-tuple:
     |      
     |      - class name
     |      - a tuple giving the shape of the data
     |      - a typecode for the data
     |      - a binary string for the data
     |      - a binary string for the mask.
     |  
     |  ____ssuubb____(self, other)
     |      Subtract other from self, and return a new masked array.
     |  
     |  ____ttrruueeddiivv____(self, other)
     |      Divide other into self, and return a new masked array.
     |  
     |  aallll(self, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns True if all elements evaluate to True.
     |      
     |      The output array is masked where all the values along the given axis
     |      are masked: if the output would have been a scalar and that all the
     |      values are masked, then the output is `masked`.
     |      
     |      Refer to `numpy.all` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.all : corresponding function for ndarrays
     |      numpy.all : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> np.ma.array([1,2,3]).all()
     |      True
     |      >>> a = np.ma.array([1,2,3], mask=True)
     |      >>> (a.all() is np.ma.masked)
     |      True
     |  
     |  aannoomm(self, axis=None, dtype=None)
     |      Compute the anomalies (deviations from the arithmetic mean)
     |      along the given axis.
     |      
     |      Returns an array of anomalies, with the same shape as the input and
     |      where the arithmetic mean is computed along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis over which the anomalies are taken.
     |          The default is to use the mean of the flattened array as reference.
     |      dtype : dtype, optional
     |          Type to use in computing the variance. For arrays of integer type
     |           the default is float32; for arrays of float types it is the same as
     |           the array type.
     |      
     |      See Also
     |      --------
     |      mean : Compute the mean of the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([1,2,3])
     |      >>> a.anom()
     |      masked_array(data = [-1.  0.  1.],
     |                   mask = False,
     |             fill_value = 1e+20)
     |  
     |  aannyy(self, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns True if any of the elements of `a` evaluate to True.
     |      
     |      Masked values are considered as False during computation.
     |      
     |      Refer to `numpy.any` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.any : corresponding function for ndarrays
     |      numpy.any : equivalent function
     |  
     |  aarrggmmaaxx(self, axis=None, fill_value=None, out=None)
     |      Returns array of indices of the maximum values along the given axis.
     |      Masked values are treated as if they had the value fill_value.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, integer}
     |          If None, the index is into the flattened array, otherwise along
     |          the specified axis
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.  If None, the output of
     |          maximum_fill_value(self._data) is used instead.
     |      out : {None, array}, optional
     |          Array into which the result can be placed. Its type is preserved
     |          and it must be of the right shape to hold the output.
     |      
     |      Returns
     |      -------
     |      index_array : {integer_array}
     |      
     |      Examples
     |      --------
     |      >>> a = np.arange(6).reshape(2,3)
     |      >>> a.argmax()
     |      5
     |      >>> a.argmax(0)
     |      array([1, 1, 1])
     |      >>> a.argmax(1)
     |      array([2, 2])
     |  
     |  aarrggmmiinn(self, axis=None, fill_value=None, out=None)
     |      Return array of indices to the minimum values along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, integer}
     |          If None, the index is into the flattened array, otherwise along
     |          the specified axis
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.  If None, the output of
     |          minimum_fill_value(self._data) is used instead.
     |      out : {None, array}, optional
     |          Array into which the result can be placed. Its type is preserved
     |          and it must be of the right shape to hold the output.
     |      
     |      Returns
     |      -------
     |      ndarray or scalar
     |          If multi-dimension input, returns a new ndarray of indices to the
     |          minimum values along the given axis.  Otherwise, returns a scalar
     |          of index to the minimum values along the given axis.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(arange(4), mask=[1,1,0,0])
     |      >>> x.shape = (2,2)
     |      >>> print(x)
     |      [[-- --]
     |       [2 3]]
     |      >>> print(x.argmin(axis=0, fill_value=-1))
     |      [0 0]
     |      >>> print(x.argmin(axis=0, fill_value=9))
     |      [1 1]
     |  
     |  aarrggppaarrttiittiioonn(self, *args, **kwargs)
     |      a.argpartition(kth, axis=-1, kind='introselect', order=None)
     |      
     |      Returns the indices that would partition this array.
     |      
     |      Refer to `numpy.argpartition` for full documentation.
     |      
     |      .. versionadded:: 1.8.0
     |      
     |      See Also
     |      --------
     |      numpy.argpartition : equivalent function
     |  
     |  aarrggssoorrtt(self, axis=<class 'numpy._globals._NoValue'>, kind='quicksort', order=None, endwith=True, fill_value=None)
     |      Return an ndarray of indices that sort the array along the
     |      specified axis.  Masked values are filled beforehand to
     |      `fill_value`.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis along which to sort. If None, the default, the flattened array
     |          is used.
     |      
     |          ..  versionchanged:: 1.13.0
     |              Previously, the default was documented to be -1, but that was
     |              in error. At some future date, the default will change to -1, as
     |              originally intended.
     |              Until then, the axis should be given explicitly when
     |              ``arr.ndim > 1``, to avoid a FutureWarning.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm.
     |      order : list, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  Not all fields need be
     |          specified.
     |      endwith : {True, False}, optional
     |          Whether missing values (if any) should be treated as the largest values
     |          (True) or the smallest values (False)
     |          When the array contains unmasked values at the same extremes of the
     |          datatype, the ordering of these values and the masked values is
     |          undefined.
     |      fill_value : {var}, optional
     |          Value used internally for the masked values.
     |          If ``fill_value`` is not None, it supersedes ``endwith``.
     |      
     |      Returns
     |      -------
     |      index_array : ndarray, int
     |          Array of indices that sort `a` along the specified axis.
     |          In other words, ``a[index_array]`` yields a sorted `a`.
     |      
     |      See Also
     |      --------
     |      MaskedArray.sort : Describes sorting algorithms used.
     |      lexsort : Indirect stable sort with multiple keys.
     |      ndarray.sort : Inplace sort.
     |      
     |      Notes
     |      -----
     |      See `sort` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([3,2,1], mask=[False, False, True])
     |      >>> a
     |      masked_array(data = [3 2 --],
     |                   mask = [False False  True],
     |             fill_value = 999999)
     |      >>> a.argsort()
     |      array([1, 0, 2])
     |  
     |  aassttyyppee(self, newtype)
     |      Returns a copy of the MaskedArray cast to given newtype.
     |      
     |      Returns
     |      -------
     |      output : MaskedArray
     |          A copy of self cast to input newtype.
     |          The returned record shape matches self.shape.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1.0 -- 3.1]
     |       [-- 5.0 --]
     |       [7.0 -- 9.0]]
     |      >>> print(x.astype(int32))
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |  
     |  cclliipp(self, *args, **params)
     |      a.clip(min=None, max=None, out=None)
     |      
     |      Return an array whose values are limited to ``[min, max]``.
     |      One of max or min must be given.
     |      
     |      Refer to `numpy.clip` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.clip : equivalent function
     |  
     |  ccoommpprreessss(self, condition, axis=None, out=None)
     |      Return `a` where condition is ``True``.
     |      
     |      If condition is a `MaskedArray`, missing values are considered
     |      as ``False``.
     |      
     |      Parameters
     |      ----------
     |      condition : var
     |          Boolean 1-d array selecting which entries to return. If len(condition)
     |          is less than the size of a along the axis, then output is truncated
     |          to length of condition array.
     |      axis : {None, int}, optional
     |          Axis along which the operation must be performed.
     |      out : {None, ndarray}, optional
     |          Alternative output array in which to place the result. It must have
     |          the same shape as the expected output but the type will be cast if
     |          necessary.
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          A :class:`MaskedArray` object.
     |      
     |      Notes
     |      -----
     |      Please note the difference with :meth:`compressed` !
     |      The output of :meth:`compress` has a mask, the output of
     |      :meth:`compressed` does not.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> x.compress([1, 0, 1])
     |      masked_array(data = [1 3],
     |            mask = [False False],
     |            fill_value=999999)
     |      
     |      >>> x.compress([1, 0, 1], axis=1)
     |      masked_array(data =
     |       [[1 3]
     |       [-- --]
     |       [7 9]],
     |            mask =
     |       [[False False]
     |       [ True  True]
     |       [False False]],
     |            fill_value=999999)
     |  
     |  ccoommpprreesssseedd(self)
     |      Return all the non-masked data as a 1-D array.
     |      
     |      Returns
     |      -------
     |      data : ndarray
     |          A new `ndarray` holding the non-masked data is returned.
     |      
     |      Notes
     |      -----
     |      The result is **not** a MaskedArray!
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
     |      >>> x.compressed()
     |      array([0, 1])
     |      >>> type(x.compressed())
     |      <type 'numpy.ndarray'>
     |  
     |  ccooppyy(self, *args, **params)
     |      a.copy(order='C')
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          Controls the memory layout of the copy. 'C' means C-order,
     |          'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
     |          'C' otherwise. 'K' means match the layout of `a` as closely
     |          as possible. (Note that this function and :func:numpy.copy are very
     |          similar, but have different default values for their order=
     |          arguments.)
     |      
     |      See also
     |      --------
     |      numpy.copy
     |      numpy.copyto
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([[1,2,3],[4,5,6]], order='F')
     |      
     |      >>> y = x.copy()
     |      
     |      >>> x.fill(0)
     |      
     |      >>> x
     |      array([[0, 0, 0],
     |             [0, 0, 0]])
     |      
     |      >>> y
     |      array([[1, 2, 3],
     |             [4, 5, 6]])
     |      
     |      >>> y.flags['C_CONTIGUOUS']
     |      True
     |  
     |  ccoouunntt(self, axis=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Count the non-masked elements of the array along the given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : None or int or tuple of ints, optional
     |          Axis or axes along which the count is performed.
     |          The default (`axis` = `None`) performs the count over all
     |          the dimensions of the input array. `axis` may be negative, in
     |          which case it counts from the last to the first axis.
     |      
     |          .. versionadded:: 1.10.0
     |      
     |          If this is a tuple of ints, the count is performed on multiple
     |          axes, instead of a single axis or all the axes as before.
     |      keepdims : bool, optional
     |          If this is set to True, the axes which are reduced are left
     |          in the result as dimensions with size one. With this option,
     |          the result will broadcast correctly against the array.
     |      
     |      Returns
     |      -------
     |      result : ndarray or scalar
     |          An array with the same shape as the input array, with the specified
     |          axis removed. If the array is a 0-d array, or if `axis` is None, a
     |          scalar is returned.
     |      
     |      See Also
     |      --------
     |      count_masked : Count masked elements in array or along a given axis.
     |      
     |      Examples
     |      --------
     |      >>> import numpy.ma as ma
     |      >>> a = ma.arange(6).reshape((2, 3))
     |      >>> a[1, :] = ma.masked
     |      >>> a
     |      masked_array(data =
     |       [[0 1 2]
     |       [-- -- --]],
     |                   mask =
     |       [[False False False]
     |       [ True  True  True]],
     |             fill_value = 999999)
     |      >>> a.count()
     |      3
     |      
     |      When the `axis` keyword is specified an array of appropriate size is
     |      returned.
     |      
     |      >>> a.count(axis=0)
     |      array([1, 1, 1])
     |      >>> a.count(axis=1)
     |      array([3, 0])
     |  
     |  ccuummpprroodd(self, axis=None, dtype=None, out=None)
     |      Return the cumulative product of the array elements over the given axis.
     |      
     |      Masked values are set to 1 internally during the computation.
     |      However, their position is saved, and the result will be masked at
     |      the same locations.
     |      
     |      Refer to `numpy.cumprod` for full documentation.
     |      
     |      Notes
     |      -----
     |      The mask is lost if `out` is not a valid MaskedArray !
     |      
     |      Arithmetic is modular when using integer types, and no error is
     |      raised on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.cumprod : corresponding function for ndarrays
     |      numpy.cumprod : equivalent function
     |  
     |  ccuummssuumm(self, axis=None, dtype=None, out=None)
     |      Return the cumulative sum of the array elements over the given axis.
     |      
     |      Masked values are set to 0 internally during the computation.
     |      However, their position is saved, and the result will be masked at
     |      the same locations.
     |      
     |      Refer to `numpy.cumsum` for full documentation.
     |      
     |      Notes
     |      -----
     |      The mask is lost if `out` is not a valid :class:`MaskedArray` !
     |      
     |      Arithmetic is modular when using integer types, and no error is
     |      raised on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.cumsum : corresponding function for ndarrays
     |      numpy.cumsum : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
     |      >>> print(marr.cumsum())
     |      [0 1 3 -- -- -- 9 16 24 33]
     |  
     |  ddiiaaggoonnaall(self, *args, **params)
     |      a.diagonal(offset=0, axis1=0, axis2=1)
     |      
     |      Return specified diagonals. In NumPy 1.9 the returned array is a
     |      read-only view instead of a copy as in previous NumPy versions.  In
     |      a future version the read-only restriction will be removed.
     |      
     |      Refer to :func:`numpy.diagonal` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.diagonal : equivalent function
     |  
     |  ddoott(self, b, out=None, strict=False)
     |      a.dot(b, out=None)
     |      
     |      Masked dot product of two arrays. Note that `out` and `strict` are
     |      located in different positions than in `ma.dot`. In order to
     |      maintain compatibility with the functional version, it is
     |      recommended that the optional arguments be treated as keyword only.
     |      At some point that may be mandatory.
     |      
     |      .. versionadded:: 1.10.0
     |      
     |      Parameters
     |      ----------
     |      b : masked_array_like
     |          Inputs array.
     |      out : masked_array, optional
     |          Output argument. This must have the exact kind that would be
     |          returned if it was not used. In particular, it must have the
     |          right type, must be C-contiguous, and its dtype must be the
     |          dtype that would be returned for `ma.dot(a,b)`. This is a
     |          performance feature. Therefore, if these conditions are not
     |          met, an exception is raised, instead of attempting to be
     |          flexible.
     |      strict : bool, optional
     |          Whether masked data are propagated (True) or set to 0 (False)
     |          for the computation. Default is False.  Propagating the mask
     |          means that if a masked value appears in a row or column, the
     |          whole row or column is considered masked.
     |      
     |          .. versionadded:: 1.10.2
     |      
     |      See Also
     |      --------
     |      numpy.ma.dot : equivalent function
     |  
     |  ffllaatttteenn(self, *args, **params)
     |      a.flatten(order='C')
     |      
     |      Return a copy of the array collapsed into one dimension.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          'C' means to flatten in row-major (C-style) order.
     |          'F' means to flatten in column-major (Fortran-
     |          style) order. 'A' means to flatten in column-major
     |          order if `a` is Fortran *contiguous* in memory,
     |          row-major order otherwise. 'K' means to flatten
     |          `a` in the order the elements occur in memory.
     |          The default is 'C'.
     |      
     |      Returns
     |      -------
     |      y : ndarray
     |          A copy of the input array, flattened to one dimension.
     |      
     |      See Also
     |      --------
     |      ravel : Return a flattened array.
     |      flat : A 1-D flat iterator over the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1,2], [3,4]])
     |      >>> a.flatten()
     |      array([1, 2, 3, 4])
     |      >>> a.flatten('F')
     |      array([1, 3, 2, 4])
     |  
     |  ggeett__ffiillll__vvaalluuee(self)
     |      Return the filling value of the masked array.
     |      
     |      Returns
     |      -------
     |      fill_value : scalar
     |          The filling value.
     |      
     |      Examples
     |      --------
     |      >>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
     |      ...     np.ma.array([0, 1], dtype=dt).get_fill_value()
     |      ...
     |      999999
     |      999999
     |      1e+20
     |      (1e+20+0j)
     |      
     |      >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
     |      >>> x.get_fill_value()
     |      -inf
     |  
     |  ggeett__iimmaagg(self)
     |      Return the imaginary part of the masked array.
     |      
     |      The returned array is a view on the imaginary part of the `MaskedArray`
     |      whose `get_imag` method is called.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          The imaginary part of the masked array.
     |      
     |      See Also
     |      --------
     |      get_real, real, imag
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
     |      >>> x.get_imag()
     |      masked_array(data = [1.0 -- 1.6],
     |                   mask = [False  True False],
     |             fill_value = 1e+20)
     |  
     |  ggeett__rreeaall(self)
     |      Return the real part of the masked array.
     |      
     |      The returned array is a view on the real part of the `MaskedArray`
     |      whose `get_real` method is called.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      result : MaskedArray
     |          The real part of the masked array.
     |      
     |      See Also
     |      --------
     |      get_imag, real, imag
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
     |      >>> x.get_real()
     |      masked_array(data = [1.0 -- 3.45],
     |                   mask = [False  True False],
     |             fill_value = 1e+20)
     |  
     |  hhaarrddeenn__mmaasskk(self)
     |      Force the mask to hard.
     |      
     |      Whether the mask of a masked array is hard or soft is determined by
     |      its `hardmask` property. `harden_mask` sets `hardmask` to True.
     |      
     |      See Also
     |      --------
     |      hardmask
     |  
     |  iiddss(self)
     |      Return the addresses of the data and mask areas.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
     |      >>> x.ids()
     |      (166670640, 166659832)
     |      
     |      If the array has no mask, the address of `nomask` is returned. This address
     |      is typically not close to the data in memory:
     |      
     |      >>> x = np.ma.array([1, 2, 3])
     |      >>> x.ids()
     |      (166691080, 3083169284L)
     |  
     |  iissccoonnttiigguuoouuss(self)
     |      Return a boolean indicating whether the data is contiguous.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([1, 2, 3])
     |      >>> x.iscontiguous()
     |      True
     |      
     |      `iscontiguous` returns one of the flags of the masked array:
     |      
     |      >>> x.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : True
     |        OWNDATA : False
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |  
     |  mmaaxx(self, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the maximum along a given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to operate.  By default, ``axis`` is None and the
     |          flattened input is used.
     |      out : array_like, optional
     |          Alternative output array in which to place the result.  Must
     |          be of the same shape and buffer length as the expected output.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |          If None, use the output of maximum_fill_value().
     |      
     |      Returns
     |      -------
     |      amax : array_like
     |          New array holding the result.
     |          If ``out`` was specified, ``out`` is returned.
     |      
     |      See Also
     |      --------
     |      maximum_fill_value
     |          Returns the maximum filling value for a given datatype.
     |  
     |  mmeeaann(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns the average of the array elements along given axis.
     |      
     |      Masked entries are ignored, and result elements which are not
     |      finite will be masked.
     |      
     |      Refer to `numpy.mean` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.mean : corresponding function for ndarrays
     |      numpy.mean : Equivalent function
     |      numpy.ma.average: Weighted average.
     |      
     |      Examples
     |      --------
     |      >>> a = np.ma.array([1,2,3], mask=[False, False, True])
     |      >>> a
     |      masked_array(data = [1 2 --],
     |                   mask = [False False  True],
     |             fill_value = 999999)
     |      >>> a.mean()
     |      1.5
     |  
     |  mmiinn(self, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the minimum along a given axis.
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to operate.  By default, ``axis`` is None and the
     |          flattened input is used.
     |      out : array_like, optional
     |          Alternative output array in which to place the result.  Must be of
     |          the same shape and buffer length as the expected output.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |          If None, use the output of `minimum_fill_value`.
     |      
     |      Returns
     |      -------
     |      amin : array_like
     |          New array holding the result.
     |          If ``out`` was specified, ``out`` is returned.
     |      
     |      See Also
     |      --------
     |      minimum_fill_value
     |          Returns the minimum filling value for a given datatype.
     |  
     |  mmiinnii(self, axis=None)
     |      Return the array minimum along the specified axis.
     |      
     |      .. deprecated:: 1.13.0
     |         This function is identical to both:
     |      
     |          * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
     |          * ``np.ma.minimum.reduce(self, axis=axis)``
     |      
     |         Typically though, ``self.min(axis=axis)`` is sufficient.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          The axis along which to find the minima. Default is None, in which case
     |          the minimum value in the whole array is returned.
     |      
     |      Returns
     |      -------
     |      min : scalar or MaskedArray
     |          If `axis` is None, the result is a scalar. Otherwise, if `axis` is
     |          given and the array is at least 2-D, the result is a masked array with
     |          dimension one smaller than the array on which `mini` is called.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
     |      >>> print(x)
     |      [[0 --]
     |       [2 3]
     |       [4 --]]
     |      >>> x.mini()
     |      0
     |      >>> x.mini(axis=0)
     |      masked_array(data = [0 3],
     |                   mask = [False False],
     |             fill_value = 999999)
     |      >>> print(x.mini(axis=1))
     |      [0 2 4]
     |      
     |      There is a small difference between `mini` and `min`:
     |      
     |      >>> x[:,1].mini(axis=0)
     |      masked_array(data = --,
     |                   mask = True,
     |             fill_value = 999999)
     |      >>> x[:,1].min(axis=0)
     |      masked
     |  
     |  nnoonnzzeerroo(self)
     |      Return the indices of unmasked elements that are not zero.
     |      
     |      Returns a tuple of arrays, one for each dimension, containing the
     |      indices of the non-zero elements in that dimension. The corresponding
     |      non-zero values can be obtained with::
     |      
     |          a[a.nonzero()]
     |      
     |      To group the indices by element, rather than dimension, use
     |      instead::
     |      
     |          np.transpose(a.nonzero())
     |      
     |      The result of this is always a 2d array, with a row for each non-zero
     |      element.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      tuple_of_arrays : tuple
     |          Indices of elements that are non-zero.
     |      
     |      See Also
     |      --------
     |      numpy.nonzero :
     |          Function operating on ndarrays.
     |      flatnonzero :
     |          Return indices that are non-zero in the flattened version of the input
     |          array.
     |      ndarray.nonzero :
     |          Equivalent ndarray method.
     |      count_nonzero :
     |          Counts the number of non-zero elements in the input array.
     |      
     |      Examples
     |      --------
     |      >>> import numpy.ma as ma
     |      >>> x = ma.array(np.eye(3))
     |      >>> x
     |      masked_array(data =
     |       [[ 1.  0.  0.]
     |       [ 0.  1.  0.]
     |       [ 0.  0.  1.]],
     |            mask =
     |       False,
     |            fill_value=1e+20)
     |      >>> x.nonzero()
     |      (array([0, 1, 2]), array([0, 1, 2]))
     |      
     |      Masked elements are ignored.
     |      
     |      >>> x[1, 1] = ma.masked
     |      >>> x
     |      masked_array(data =
     |       [[1.0 0.0 0.0]
     |       [0.0 -- 0.0]
     |       [0.0 0.0 1.0]],
     |            mask =
     |       [[False False False]
     |       [False  True False]
     |       [False False False]],
     |            fill_value=1e+20)
     |      >>> x.nonzero()
     |      (array([0, 2]), array([0, 2]))
     |      
     |      Indices can also be grouped by element.
     |      
     |      >>> np.transpose(x.nonzero())
     |      array([[0, 0],
     |             [2, 2]])
     |      
     |      A common use for ``nonzero`` is to find the indices of an array, where
     |      a condition is True.  Given an array `a`, the condition `a` > 3 is a
     |      boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
     |      yields the indices of the `a` where the condition is true.
     |      
     |      >>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
     |      >>> a > 3
     |      masked_array(data =
     |       [[False False False]
     |       [ True  True  True]
     |       [ True  True  True]],
     |            mask =
     |       False,
     |            fill_value=999999)
     |      >>> ma.nonzero(a > 3)
     |      (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
     |      
     |      The ``nonzero`` method of the condition array can also be called.
     |      
     |      >>> (a > 3).nonzero()
     |      (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
     |  
     |  ppaarrttiittiioonn(self, *args, **kwargs)
     |      a.partition(kth, axis=-1, kind='introselect', order=None)
     |      
     |      Rearranges the elements in the array in such a way that value of the
     |      element in kth position is in the position it would be in a sorted array.
     |      All elements smaller than the kth element are moved before this element and
     |      all equal or greater are moved behind it. The ordering of the elements in
     |      the two partitions is undefined.
     |      
     |      .. versionadded:: 1.8.0
     |      
     |      Parameters
     |      ----------
     |      kth : int or sequence of ints
     |          Element index to partition by. The kth element value will be in its
     |          final sorted position and all smaller elements will be moved before it
     |          and all equal or greater elements behind it.
     |          The order all elements in the partitions is undefined.
     |          If provided with a sequence of kth it will partition all elements
     |          indexed by kth of them into their sorted position at once.
     |      axis : int, optional
     |          Axis along which to sort. Default is -1, which means sort along the
     |          last axis.
     |      kind : {'introselect'}, optional
     |          Selection algorithm. Default is 'introselect'.
     |      order : str or list of str, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  A single field can
     |          be specified as a string, and not all fields need be specified,
     |          but unspecified fields will still be used, in the order in which
     |          they come up in the dtype, to break ties.
     |      
     |      See Also
     |      --------
     |      numpy.partition : Return a parititioned copy of an array.
     |      argpartition : Indirect partition.
     |      sort : Full sort.
     |      
     |      Notes
     |      -----
     |      See ``np.partition`` for notes on the different algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([3, 4, 2, 1])
     |      >>> a.partition(3)
     |      >>> a
     |      array([2, 1, 3, 4])
     |      
     |      >>> a.partition((1, 3))
     |      array([1, 2, 3, 4])
     |  
     |  pprroodd(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the product of the array elements over the given axis.
     |      
     |      Masked elements are set to 1 internally for computation.
     |      
     |      Refer to `numpy.prod` for full documentation.
     |      
     |      Notes
     |      -----
     |      Arithmetic is modular when using integer types, and no error is raised
     |      on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.prod : corresponding function for ndarrays
     |      numpy.prod : equivalent function
     |  
     |  pprroodduucctt = prod(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the product of the array elements over the given axis.
     |      
     |      Masked elements are set to 1 internally for computation.
     |      
     |      Refer to `numpy.prod` for full documentation.
     |      
     |      Notes
     |      -----
     |      Arithmetic is modular when using integer types, and no error is raised
     |      on overflow.
     |      
     |      See Also
     |      --------
     |      ndarray.prod : corresponding function for ndarrays
     |      numpy.prod : equivalent function
     |  
     |  ppttpp(self, axis=None, out=None, fill_value=None)
     |      Return (maximum - minimum) along the given dimension
     |      (i.e. peak-to-peak value).
     |      
     |      Parameters
     |      ----------
     |      axis : {None, int}, optional
     |          Axis along which to find the peaks.  If None (default) the
     |          flattened array is used.
     |      out : {None, array_like}, optional
     |          Alternative output array in which to place the result. It must
     |          have the same shape and buffer length as the expected output
     |          but the type will be cast if necessary.
     |      fill_value : {var}, optional
     |          Value used to fill in the masked values.
     |      
     |      Returns
     |      -------
     |      ptp : ndarray.
     |          A new array holding the result, unless ``out`` was
     |          specified, in which case a reference to ``out`` is returned.
     |  
     |  ppuutt(self, indices, values, mode='raise')
     |      Set storage-indexed locations to corresponding values.
     |      
     |      Sets self._data.flat[n] = values[n] for each n in indices.
     |      If `values` is shorter than `indices` then it will repeat.
     |      If `values` has some masked values, the initial mask is updated
     |      in consequence, else the corresponding values are unmasked.
     |      
     |      Parameters
     |      ----------
     |      indices : 1-D array_like
     |          Target indices, interpreted as integers.
     |      values : array_like
     |          Values to place in self._data copy at target indices.
     |      mode : {'raise', 'wrap', 'clip'}, optional
     |          Specifies how out-of-bounds indices will behave.
     |          'raise' : raise an error.
     |          'wrap' : wrap around.
     |          'clip' : clip to the range.
     |      
     |      Notes
     |      -----
     |      `values` can be a scalar or length 1 array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> x.put([0,4,8],[10,20,30])
     |      >>> print(x)
     |      [[10 -- 3]
     |       [-- 20 --]
     |       [7 -- 30]]
     |      
     |      >>> x.put(4,999)
     |      >>> print(x)
     |      [[10 -- 3]
     |       [-- 999 --]
     |       [7 -- 30]]
     |  
     |  rraavveell(self, order='C')
     |      Returns a 1D version of self, as a view.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A', 'K'}, optional
     |          The elements of `a` are read using this index order. 'C' means to
     |          index the elements in C-like order, with the last axis index
     |          changing fastest, back to the first axis index changing slowest.
     |          'F' means to index the elements in Fortran-like index order, with
     |          the first index changing fastest, and the last index changing
     |          slowest. Note that the 'C' and 'F' options take no account of the
     |          memory layout of the underlying array, and only refer to the order
     |          of axis indexing.  'A' means to read the elements in Fortran-like
     |          index order if `m` is Fortran *contiguous* in memory, C-like order
     |          otherwise.  'K' means to read the elements in the order they occur
     |          in memory, except for reversing the data when strides are negative.
     |          By default, 'C' index order is used.
     |      
     |      Returns
     |      -------
     |      MaskedArray
     |          Output view is of shape ``(self.size,)`` (or
     |          ``(np.ma.product(self.shape),)``).
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.ravel())
     |      [1 -- 3 -- 5 -- 7 -- 9]
     |  
     |  rreeppeeaatt(self, *args, **params)
     |      a.repeat(repeats, axis=None)
     |      
     |      Repeat elements of an array.
     |      
     |      Refer to `numpy.repeat` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.repeat : equivalent function
     |  
     |  rreesshhaappee(self, *s, **kwargs)
     |      Give a new shape to the array without changing its data.
     |      
     |      Returns a masked array containing the same data, but with a new shape.
     |      The result is a view on the original array; if this is not possible, a
     |      ValueError is raised.
     |      
     |      Parameters
     |      ----------
     |      shape : int or tuple of ints
     |          The new shape should be compatible with the original shape. If an
     |          integer is supplied, then the result will be a 1-D array of that
     |          length.
     |      order : {'C', 'F'}, optional
     |          Determines whether the array data should be viewed as in C
     |          (row-major) or FORTRAN (column-major) order.
     |      
     |      Returns
     |      -------
     |      reshaped_array : array
     |          A new view on the array.
     |      
     |      See Also
     |      --------
     |      reshape : Equivalent function in the masked array module.
     |      numpy.ndarray.reshape : Equivalent method on ndarray object.
     |      numpy.reshape : Equivalent function in the NumPy module.
     |      
     |      Notes
     |      -----
     |      The reshaping operation cannot guarantee that a copy will not be made,
     |      to modify the shape in place, use ``a.shape = s``
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
     |      >>> print(x)
     |      [[-- 2]
     |       [3 --]]
     |      >>> x = x.reshape((4,1))
     |      >>> print(x)
     |      [[--]
     |       [2]
     |       [3]
     |       [--]]
     |  
     |  rreessiizzee(self, newshape, refcheck=True, order=False)
     |      .. warning::
     |      
     |          This method does nothing, except raise a ValueError exception. A
     |          masked array does not own its data and therefore cannot safely be
     |          resized in place. Use the `numpy.ma.resize` function instead.
     |      
     |      This method is difficult to implement safely and may be deprecated in
     |      future releases of NumPy.
     |  
     |  rroouunndd(self, decimals=0, out=None)
     |      Return each element rounded to the given number of decimals.
     |      
     |      Refer to `numpy.around` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.around : corresponding function for ndarrays
     |      numpy.around : equivalent function
     |  
     |  sseett__ffiillll__vvaalluuee(self, value=None)
     |      Set the filling value of the masked array.
     |      
     |      Parameters
     |      ----------
     |      value : scalar, optional
     |          The new filling value. Default is None, in which case a default
     |          based on the data type is used.
     |      
     |      See Also
     |      --------
     |      ma.set_fill_value : Equivalent function.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
     |      >>> x.fill_value
     |      -inf
     |      >>> x.set_fill_value(np.pi)
     |      >>> x.fill_value
     |      3.1415926535897931
     |      
     |      Reset to default:
     |      
     |      >>> x.set_fill_value()
     |      >>> x.fill_value
     |      1e+20
     |  
     |  sshhrriinnkk__mmaasskk(self)
     |      Reduce a mask to nomask when possible.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
     |      >>> x.mask
     |      array([[False, False],
     |             [False, False]], dtype=bool)
     |      >>> x.shrink_mask()
     |      >>> x.mask
     |      False
     |  
     |  ssoofftteenn__mmaasskk(self)
     |      Force the mask to soft.
     |      
     |      Whether the mask of a masked array is hard or soft is determined by
     |      its `hardmask` property. `soften_mask` sets `hardmask` to False.
     |      
     |      See Also
     |      --------
     |      hardmask
     |  
     |  ssoorrtt(self, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)
     |      Sort the array, in-place
     |      
     |      Parameters
     |      ----------
     |      a : array_like
     |          Array to be sorted.
     |      axis : int, optional
     |          Axis along which to sort. If None, the array is flattened before
     |          sorting. The default is -1, which sorts along the last axis.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm. Default is 'quicksort'.
     |      order : list, optional
     |          When `a` is a structured array, this argument specifies which fields
     |          to compare first, second, and so on.  This list does not need to
     |          include all of the fields.
     |      endwith : {True, False}, optional
     |          Whether missing values (if any) should be treated as the largest values
     |          (True) or the smallest values (False)
     |          When the array contains unmasked values at the same extremes of the
     |          datatype, the ordering of these values and the masked values is
     |          undefined.
     |      fill_value : {var}, optional
     |          Value used internally for the masked values.
     |          If ``fill_value`` is not None, it supersedes ``endwith``.
     |      
     |      Returns
     |      -------
     |      sorted_array : ndarray
     |          Array of the same type and shape as `a`.
     |      
     |      See Also
     |      --------
     |      ndarray.sort : Method to sort an array in-place.
     |      argsort : Indirect sort.
     |      lexsort : Indirect stable sort on multiple keys.
     |      searchsorted : Find elements in a sorted array.
     |      
     |      Notes
     |      -----
     |      See ``sort`` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # Default
     |      >>> a.sort()
     |      >>> print(a)
     |      [1 3 5 -- --]
     |      
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # Put missing values in the front
     |      >>> a.sort(endwith=False)
     |      >>> print(a)
     |      [-- -- 1 3 5]
     |      
     |      >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
     |      >>> # fill_value takes over endwith
     |      >>> a.sort(endwith=False, fill_value=3)
     |      >>> print(a)
     |      [1 -- -- 3 5]
     |  
     |  ssqquueeeezzee(self, *args, **params)
     |      a.squeeze(axis=None)
     |      
     |      Remove single-dimensional entries from the shape of `a`.
     |      
     |      Refer to `numpy.squeeze` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.squeeze : equivalent function
     |  
     |  ssttdd(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class 'numpy._globals._NoValue'>)
     |      Returns the standard deviation of the array elements along given axis.
     |      
     |      Masked entries are ignored.
     |      
     |      Refer to `numpy.std` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.std : corresponding function for ndarrays
     |      numpy.std : Equivalent function
     |  
     |  ssuumm(self, axis=None, dtype=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
     |      Return the sum of the array elements over the given axis.
     |      
     |      Masked elements are set to 0 internally.
     |      
     |      Refer to `numpy.sum` for full documentation.
     |      
     |      See Also
     |      --------
     |      ndarray.sum : corresponding function for ndarrays
     |      numpy.sum : equivalent function
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.sum())
     |      25
     |      >>> print(x.sum(axis=1))
     |      [4 5 16]
     |      >>> print(x.sum(axis=0))
     |      [8 5 12]
     |      >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
     |      <type 'numpy.int64'>
     |  
     |  sswwaappaaxxeess(self, *args, **params)
     |      a.swapaxes(axis1, axis2)
     |      
     |      Return a view of the array with `axis1` and `axis2` interchanged.
     |      
     |      Refer to `numpy.swapaxes` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.swapaxes : equivalent function
     |  
     |  ttaakkee(self, indices, axis=None, out=None, mode='raise')
     |  
     |  ttoobbyytteess(self, fill_value=None, order='C')
     |      Return the array data as a string containing the raw bytes in the array.
     |      
     |      The array is filled with a fill value before the string conversion.
     |      
     |      .. versionadded:: 1.9.0
     |      
     |      Parameters
     |      ----------
     |      fill_value : scalar, optional
     |          Value used to fill in the masked values. Default is None, in which
     |          case `MaskedArray.fill_value` is used.
     |      order : {'C','F','A'}, optional
     |          Order of the data item in the copy. Default is 'C'.
     |      
     |          - 'C'   -- C order (row major).
     |          - 'F'   -- Fortran order (column major).
     |          - 'A'   -- Any, current order of array.
     |          - None  -- Same as 'A'.
     |      
     |      See Also
     |      --------
     |      ndarray.tobytes
     |      tolist, tofile
     |      
     |      Notes
     |      -----
     |      As for `ndarray.tobytes`, information about the shape, dtype, etc.,
     |      but also about `fill_value`, will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
     |      >>> x.tobytes()
     |      '\x01\x00\x00\x00?B\x0f\x00?B\x0f\x00\x04\x00\x00\x00'
     |  
     |  ttooffiillee(self, fid, sep='', format='%s')
     |      Save a masked array to a file in binary format.
     |      
     |      .. warning::
     |        This function is not implemented yet.
     |      
     |      Raises
     |      ------
     |      NotImplementedError
     |          When `tofile` is called.
     |  
     |  ttoofflleexx(self)
     |      Transforms a masked array into a flexible-type array.
     |      
     |      The flexible type array that is returned will have two fields:
     |      
     |      * the ``_data`` field stores the ``_data`` part of the array.
     |      * the ``_mask`` field stores the ``_mask`` part of the array.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      record : ndarray
     |          A new flexible-type `ndarray` with two fields: the first element
     |          containing a value, the second element containing the corresponding
     |          mask boolean. The returned record shape matches self.shape.
     |      
     |      Notes
     |      -----
     |      A side-effect of transforming a masked array into a flexible `ndarray` is
     |      that meta information (``fill_value``, ...) will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.toflex())
     |      [[(1, False) (2, True) (3, False)]
     |       [(4, True) (5, False) (6, True)]
     |       [(7, False) (8, True) (9, False)]]
     |  
     |  ttoorreeccoorrddss = toflex(self)
     |      Transforms a masked array into a flexible-type array.
     |      
     |      The flexible type array that is returned will have two fields:
     |      
     |      * the ``_data`` field stores the ``_data`` part of the array.
     |      * the ``_mask`` field stores the ``_mask`` part of the array.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      record : ndarray
     |          A new flexible-type `ndarray` with two fields: the first element
     |          containing a value, the second element containing the corresponding
     |          mask boolean. The returned record shape matches self.shape.
     |      
     |      Notes
     |      -----
     |      A side-effect of transforming a masked array into a flexible `ndarray` is
     |      that meta information (``fill_value``, ...) will be lost.
     |      
     |      Examples
     |      --------
     |      >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
     |      >>> print(x)
     |      [[1 -- 3]
     |       [-- 5 --]
     |       [7 -- 9]]
     |      >>> print(x.toflex())
     |      [[(1, False) (2, True) (3, False)]
     |       [(4, True) (5, False) (6, True)]
     |       [(7, False) (8, True) (9, False)]]
     |  
     |  ttoossttrriinngg(self, fill_value=None, order='C')
     |      This function is a compatibility alias for tobytes. Despite its name it
     |      returns bytes not strings.
     |  
     |  ttrraaccee(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      
     |      Return the sum along diagonals of the array.
     |      
     |      Refer to `numpy.trace` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.trace : equivalent function
     |  
     |  ttrraannssppoossee(self, *args, **params)
     |      a.transpose(*axes)
     |      
     |      Returns a view of the array with axes transposed.
     |      
     |      For a 1-D array, this has no effect. (To change between column and
     |      row vectors, first cast the 1-D array into a matrix object.)
     |      For a 2-D array, this is the usual matrix transpose.
     |      For an n-D array, if axes are given, their order indicates how the
     |      axes are permuted (see Examples). If axes are not provided and
     |      ``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
     |      ``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.
     |      
     |      Parameters
     |      ----------
     |      axes : None, tuple of ints, or `n` ints
     |      
     |       * None or no argument: reverses the order of the axes.
     |      
     |       * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
     |         `i`-th axis becomes `a.transpose()`'s `j`-th axis.
     |      
     |       * `n` ints: same as an n-tuple of the same ints (this form is
     |         intended simply as a "convenience" alternative to the tuple form)
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          View of `a`, with axes suitably permuted.
     |      
     |      See Also
     |      --------
     |      ndarray.T : Array property returning the array transposed.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> a
     |      array([[1, 2],
     |             [3, 4]])
     |      >>> a.transpose()
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose((1, 0))
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose(1, 0)
     |      array([[1, 3],
     |             [2, 4]])
     |  
     |  uunnsshhaarree__mmaasskk(self)
     |      Copy the mask and set the sharedmask flag to False.
     |      
     |      Whether the mask is shared between masked arrays can be seen from
     |      the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
     |      A copy of the mask is only made if it was shared.
     |      
     |      See Also
     |      --------
     |      sharedmask
     |  
     |  vvaarr(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<class 'numpy._globals._NoValue'>)
     |      Compute the variance along the specified axis.
     |      
     |      Returns the variance of the array elements, a measure of the spread of a
     |      distribution.  The variance is computed for the flattened array by
     |      default, otherwise over the specified axis.
     |      
     |      Parameters
     |      ----------
     |      a : array_like
     |          Array containing numbers whose variance is desired.  If `a` is not an
     |          array, a conversion is attempted.
     |      axis : None or int or tuple of ints, optional
     |          Axis or axes along which the variance is computed.  The default is to
     |          compute the variance of the flattened array.
     |      
     |          .. versionadded:: 1.7.0
     |      
     |          If this is a tuple of ints, a variance is performed over multiple axes,
     |          instead of a single axis or all the axes as before.
     |      dtype : data-type, optional
     |          Type to use in computing the variance.  For arrays of integer type
     |          the default is `float32`; for arrays of float types it is the same as
     |          the array type.
     |      out : ndarray, optional
     |          Alternate output array in which to place the result.  It must have
     |          the same shape as the expected output, but the type is cast if
     |          necessary.
     |      ddof : int, optional
     |          "Delta Degrees of Freedom": the divisor used in the calculation is
     |          ``N - ddof``, where ``N`` represents the number of elements. By
     |          default `ddof` is zero.
     |      keepdims : bool, optional
     |          If this is set to True, the axes which are reduced are left
     |          in the result as dimensions with size one. With this option,
     |          the result will broadcast correctly against the input array.
     |      
     |          If the default value is passed, then `keepdims` will not be
     |          passed through to the `var` method of sub-classes of
     |          `ndarray`, however any non-default value will be.  If the
     |          sub-classes `sum` method does not implement `keepdims` any
     |          exceptions will be raised.
     |      
     |      Returns
     |      -------
     |      variance : ndarray, see dtype parameter above
     |          If ``out=None``, returns a new array containing the variance;
     |          otherwise, a reference to the output array is returned.
     |      
     |      See Also
     |      --------
     |      std , mean, nanmean, nanstd, nanvar
     |      numpy.doc.ufuncs : Section "Output arguments"
     |      
     |      Notes
     |      -----
     |      The variance is the average of the squared deviations from the mean,
     |      i.e.,  ``var = mean(abs(x - x.mean())**2)``.
     |      
     |      The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
     |      If, however, `ddof` is specified, the divisor ``N - ddof`` is used
     |      instead.  In standard statistical practice, ``ddof=1`` provides an
     |      unbiased estimator of the variance of a hypothetical infinite population.
     |      ``ddof=0`` provides a maximum likelihood estimate of the variance for
     |      normally distributed variables.
     |      
     |      Note that for complex numbers, the absolute value is taken before
     |      squaring, so that the result is always real and nonnegative.
     |      
     |      For floating-point input, the variance is computed using the same
     |      precision the input has.  Depending on the input data, this can cause
     |      the results to be inaccurate, especially for `float32` (see example
     |      below).  Specifying a higher-accuracy accumulator using the ``dtype``
     |      keyword can alleviate this issue.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> np.var(a)
     |      1.25
     |      >>> np.var(a, axis=0)
     |      array([ 1.,  1.])
     |      >>> np.var(a, axis=1)
     |      array([ 0.25,  0.25])
     |      
     |      In single precision, var() can be inaccurate:
     |      
     |      >>> a = np.zeros((2, 512*512), dtype=np.float32)
     |      >>> a[0, :] = 1.0
     |      >>> a[1, :] = 0.1
     |      >>> np.var(a)
     |      0.20250003
     |      
     |      Computing the variance in float64 is more accurate:
     |      
     |      >>> np.var(a, dtype=np.float64)
     |      0.20249999932944759
     |      >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
     |      0.2025
     |  
     |  vviieeww(self, dtype=None, type=None, fill_value=None)
     |      a.view(dtype=None, type=None)
     |      
     |      New view of array with the same data.
     |      
     |      Parameters
     |      ----------
     |      dtype : data-type or ndarray sub-class, optional
     |          Data-type descriptor of the returned view, e.g., float32 or int16. The
     |          default, None, results in the view having the same data-type as `a`.
     |          This argument can also be specified as an ndarray sub-class, which
     |          then specifies the type of the returned object (this is equivalent to
     |          setting the ``type`` parameter).
     |      type : Python type, optional
     |          Type of the returned view, e.g., ndarray or matrix.  Again, the
     |          default None results in type preservation.
     |      
     |      Notes
     |      -----
     |      ``a.view()`` is used two different ways:
     |      
     |      ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
     |      of the array's memory with a different data-type.  This can cause a
     |      reinterpretation of the bytes of memory.
     |      
     |      ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
     |      returns an instance of `ndarray_subclass` that looks at the same array
     |      (same shape, dtype, etc.)  This does not cause a reinterpretation of the
     |      memory.
     |      
     |      For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
     |      bytes per entry than the previous dtype (for example, converting a
     |      regular array to a structured array), then the behavior of the view
     |      cannot be predicted just from the superficial appearance of ``a`` (shown
     |      by ``print(a)``). It also depends on exactly how ``a`` is stored in
     |      memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
     |      defined as a slice or transpose, etc., the view may give different
     |      results.
     |      
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])
     |      
     |      Viewing array data using a different type and dtype:
     |      
     |      >>> y = x.view(dtype=np.int16, type=np.matrix)
     |      >>> y
     |      matrix([[513]], dtype=int16)
     |      >>> print(type(y))
     |      <class 'numpy.matrixlib.defmatrix.matrix'>
     |      
     |      Creating a view on a structured array so it can be used in calculations
     |      
     |      >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
     |      >>> xv = x.view(dtype=np.int8).reshape(-1,2)
     |      >>> xv
     |      array([[1, 2],
     |             [3, 4]], dtype=int8)
     |      >>> xv.mean(0)
     |      array([ 2.,  3.])
     |      
     |      Making changes to the view changes the underlying array
     |      
     |      >>> xv[0,1] = 20
     |      >>> print(x)
     |      [(1, 20) (3, 4)]
     |      
     |      Using a view to convert an array to a recarray:
     |      
     |      >>> z = x.view(np.recarray)
     |      >>> z.a
     |      array([1], dtype=int8)
     |      
     |      Views share data:
     |      
     |      >>> x[0] = (9, 10)
     |      >>> z[0]
     |      (9, 10)
     |      
     |      Views that change the dtype size (bytes per entry) should normally be
     |      avoided on arrays defined by slices, transposes, fortran-ordering, etc.:
     |      
     |      >>> x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)
     |      >>> y = x[:, 0:2]
     |      >>> y
     |      array([[1, 2],
     |             [4, 5]], dtype=int16)
     |      >>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: new type not compatible with array.
     |      >>> z = y.copy()
     |      >>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
     |      array([[(1, 2)],
     |             [(4, 5)]], dtype=[('width', '<i2'), ('length', '<i2')])
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MaskedArray:
     |  
     |  TT
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  bbaasseeccllaassss
     |      Class of the underlying data (read-only).
     |  
     |  ddaattaa
     |      Return the current data, as a view of the original
     |      underlying data.
     |  
     |  ffiillll__vvaalluuee
     |      Filling value.
     |  
     |  ffllaatt
     |      Flat version of the array.
     |  
     |  hhaarrddmmaasskk
     |      Hardness of the mask
     |  
     |  iimmaagg
     |      Imaginary part.
     |  
     |  mmaasskk
     |      Mask
     |  
     |  rreeaall
     |      Real part
     |  
     |  rreeccoorrddmmaasskk
     |      Return the mask of the records.
     |      
     |      A record is masked when all the fields are masked.
     |  
     |  sshhaarreeddmmaasskk
     |      Share status of the mask (read-only).
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from MaskedArray:
     |  
     |  ____aarrrraayy__pprriioorriittyy____ = 15
     |  
     |  ____hhaasshh____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from numpy.ndarray:
     |  
     |  ____aabbss____(self, /)
     |      abs(self)
     |  
     |  ____aanndd____(self, value, /)
     |      Return self&value.
     |  
     |  ____aarrrraayy____(...)
     |      a.__array__(|dtype) -> reference if type unchanged, copy otherwise.
     |      
     |      Returns either a new reference to self if dtype is not given or a new array
     |      of provided data type if dtype is different from the current dtype of the
     |      array.
     |  
     |  ____aarrrraayy__pprreeppaarree____(...)
     |      a.__array_prepare__(obj) -> Object of same type as ndarray object obj.
     |  
     |  ____aarrrraayy__uuffuunncc____(...)
     |  
     |  ____bbooooll____(self, /)
     |      self != 0
     |  
     |  ____ccoommpplleexx____(...)
     |  
     |  ____ccoonnttaaiinnss____(self, key, /)
     |      Return key in self.
     |  
     |  ____ccooppyy____(...)
     |      a.__copy__([order])
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A'}, optional
     |          If order is 'C' (False) then the result is contiguous (default).
     |          If order is 'Fortran' (True) then the result has fortran order.
     |          If order is 'Any' (None) then the result has fortran order
     |          only if the array already is in fortran order.
     |  
     |  ____ddeelliitteemm____(self, key, /)
     |      Delete self[key].
     |  
     |  ____ddiivvmmoodd____(self, value, /)
     |      Return divmod(self, value).
     |  
     |  ____ggee____(self, value, /)
     |      Return self>=value.
     |  
     |  ____ggtt____(self, value, /)
     |      Return self>value.
     |  
     |  ____iiaanndd____(self, value, /)
     |      Return self&=value.
     |  
     |  ____iillsshhiifftt____(self, value, /)
     |      Return self<<=value.
     |  
     |  ____iimmaattmmuull____(self, value, /)
     |      Return self@=value.
     |  
     |  ____iimmoodd____(self, value, /)
     |      Return self%=value.
     |  
     |  ____iinnddeexx____(self, /)
     |      Return self converted to an integer, if self is suitable for use as an index into a list.
     |  
     |  ____iinnvveerrtt____(self, /)
     |      ~self
     |  
     |  ____iioorr____(self, value, /)
     |      Return self|=value.
     |  
     |  ____iirrsshhiifftt____(self, value, /)
     |      Return self>>=value.
     |  
     |  ____iixxoorr____(self, value, /)
     |      Return self^=value.
     |  
     |  ____llee____(self, value, /)
     |      Return self<=value.
     |  
     |  ____llsshhiifftt____(self, value, /)
     |      Return self<<value.
     |  
     |  ____lltt____(self, value, /)
     |      Return self<value.
     |  
     |  ____mmaattmmuull____(self, value, /)
     |      Return self@value.
     |  
     |  ____mmoodd____(self, value, /)
     |      Return self%value.
     |  
     |  ____nneegg____(self, /)
     |      -self
     |  
     |  ____oorr____(self, value, /)
     |      Return self|value.
     |  
     |  ____ppooss____(self, /)
     |      +self
     |  
     |  ____rraanndd____(self, value, /)
     |      Return value&self.
     |  
     |  ____rrddiivvmmoodd____(self, value, /)
     |      Return divmod(value, self).
     |  
     |  ____rrllsshhiifftt____(self, value, /)
     |      Return value<<self.
     |  
     |  ____rrmmaattmmuull____(self, value, /)
     |      Return value@self.
     |  
     |  ____rrmmoodd____(self, value, /)
     |      Return value%self.
     |  
     |  ____rroorr____(self, value, /)
     |      Return value|self.
     |  
     |  ____rrrrsshhiifftt____(self, value, /)
     |      Return value>>self.
     |  
     |  ____rrsshhiifftt____(self, value, /)
     |      Return self>>value.
     |  
     |  ____rrxxoorr____(self, value, /)
     |      Return value^self.
     |  
     |  ____ssiizzeeooff____(...)
     |      __sizeof__() -> int
     |      size of object in memory, in bytes
     |  
     |  ____xxoorr____(self, value, /)
     |      Return self^value.
     |  
     |  bbyytteesswwaapp(...)
     |      a.byteswap(inplace)
     |      
     |      Swap the bytes of the array elements
     |      
     |      Toggle between low-endian and big-endian data representation by
     |      returning a byteswapped array, optionally swapped in-place.
     |      
     |      Parameters
     |      ----------
     |      inplace : bool, optional
     |          If ``True``, swap bytes in-place, default is ``False``.
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          The byteswapped array. If `inplace` is ``True``, this is
     |          a view to self.
     |      
     |      Examples
     |      --------
     |      >>> A = np.array([1, 256, 8755], dtype=np.int16)
     |      >>> map(hex, A)
     |      ['0x1', '0x100', '0x2233']
     |      >>> A.byteswap(True)
     |      array([  256,     1, 13090], dtype=int16)
     |      >>> map(hex, A)
     |      ['0x100', '0x1', '0x3322']
     |      
     |      Arrays of strings are not swapped
     |      
     |      >>> A = np.array(['ceg', 'fac'])
     |      >>> A.byteswap()
     |      array(['ceg', 'fac'],
     |            dtype='|S3')
     |  
     |  cchhoooossee(...)
     |      a.choose(choices, out=None, mode='raise')
     |      
     |      Use an index array to construct a new array from a set of choices.
     |      
     |      Refer to `numpy.choose` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.choose : equivalent function
     |  
     |  ccoonnjj(...)
     |      a.conj()
     |      
     |      Complex-conjugate all elements.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  ccoonnjjuuggaattee(...)
     |      a.conjugate()
     |      
     |      Return the complex conjugate, element-wise.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  dduummpp(...)
     |      a.dump(file)
     |      
     |      Dump a pickle of the array to the specified file.
     |      The array can be read back with pickle.load or numpy.load.
     |      
     |      Parameters
     |      ----------
     |      file : str
     |          A string naming the dump file.
     |  
     |  dduummppss(...)
     |      a.dumps()
     |      
     |      Returns the pickle of the array as a string.
     |      pickle.loads or numpy.loads will convert the string back to an array.
     |      
     |      Parameters
     |      ----------
     |      None
     |  
     |  ffiillll(...)
     |      a.fill(value)
     |      
     |      Fill the array with a scalar value.
     |      
     |      Parameters
     |      ----------
     |      value : scalar
     |          All elements of `a` will be assigned this value.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([1, 2])
     |      >>> a.fill(0)
     |      >>> a
     |      array([0, 0])
     |      >>> a = np.empty(2)
     |      >>> a.fill(1)
     |      >>> a
     |      array([ 1.,  1.])
     |  
     |  ggeettffiieelldd(...)
     |      a.getfield(dtype, offset=0)
     |      
     |      Returns a field of the given array as a certain type.
     |      
     |      A field is a view of the array data with a given data-type. The values in
     |      the view are determined by the given type and the offset into the current
     |      array in bytes. The offset needs to be such that the view dtype fits in the
     |      array dtype; for example an array of dtype complex128 has 16-byte elements.
     |      If taking a view with a 32-bit integer (4 bytes), the offset needs to be
     |      between 0 and 12 bytes.
     |      
     |      Parameters
     |      ----------
     |      dtype : str or dtype
     |          The data type of the view. The dtype size of the view can not be larger
     |          than that of the array itself.
     |      offset : int
     |          Number of bytes to skip before beginning the element view.
     |      
     |      Examples
     |      --------
     |      >>> x = np.diag([1.+1.j]*2)
     |      >>> x[1, 1] = 2 + 4.j
     |      >>> x
     |      array([[ 1.+1.j,  0.+0.j],
     |             [ 0.+0.j,  2.+4.j]])
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.],
     |             [ 0.,  2.]])
     |      
     |      By choosing an offset of 8 bytes we can select the complex part of the
     |      array for our view:
     |      
     |      >>> x.getfield(np.float64, offset=8)
     |      array([[ 1.,  0.],
     |         [ 0.,  4.]])
     |  
     |  iitteemm(...)
     |      a.item(*args)
     |      
     |      Copy an element of an array to a standard Python scalar and return it.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments (variable number and type)
     |      
     |          * none: in this case, the method only works for arrays
     |            with one element (`a.size == 1`), which element is
     |            copied into a standard Python scalar object and returned.
     |      
     |          * int_type: this argument is interpreted as a flat index into
     |            the array, specifying which element to copy and return.
     |      
     |          * tuple of int_types: functions as does a single int_type argument,
     |            except that the argument is interpreted as an nd-index into the
     |            array.
     |      
     |      Returns
     |      -------
     |      z : Standard Python scalar object
     |          A copy of the specified element of the array as a suitable
     |          Python scalar
     |      
     |      Notes
     |      -----
     |      When the data type of `a` is longdouble or clongdouble, item() returns
     |      a scalar array object because there is no available Python scalar that
     |      would not lose information. Void arrays return a buffer object for item(),
     |      unless fields are defined, in which case a tuple is returned.
     |      
     |      `item` is very similar to a[args], except, instead of an array scalar,
     |      a standard Python scalar is returned. This can be useful for speeding up
     |      access to elements of the array and doing arithmetic on elements of the
     |      array using Python's optimized math.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.item(3)
     |      2
     |      >>> x.item(7)
     |      5
     |      >>> x.item((0, 1))
     |      1
     |      >>> x.item((2, 2))
     |      3
     |  
     |  iitteemmsseett(...)
     |      a.itemset(*args)
     |      
     |      Insert scalar into an array (scalar is cast to array's dtype, if possible)
     |      
     |      There must be at least 1 argument, and define the last argument
     |      as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster
     |      than ``a[args] = item``.  The item should be a scalar value and `args`
     |      must select a single item in the array `a`.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments
     |          If one argument: a scalar, only used in case `a` is of size 1.
     |          If two arguments: the last argument is the value to be set
     |          and must be a scalar, the first argument specifies a single array
     |          element location. It is either an int or a tuple.
     |      
     |      Notes
     |      -----
     |      Compared to indexing syntax, `itemset` provides some speed increase
     |      for placing a scalar into a particular location in an `ndarray`,
     |      if you must do this.  However, generally this is discouraged:
     |      among other problems, it complicates the appearance of the code.
     |      Also, when using `itemset` (and `item`) inside a loop, be sure
     |      to assign the methods to a local variable to avoid the attribute
     |      look-up at each loop iteration.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.itemset(4, 0)
     |      >>> x.itemset((2, 2), 9)
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 0, 3],
     |             [8, 5, 9]])
     |  
     |  nneewwbbyytteeoorrddeerr(...)
     |      arr.newbyteorder(new_order='S')
     |      
     |      Return the array with the same data viewed with a different byte order.
     |      
     |      Equivalent to::
     |      
     |          arr.view(arr.dtype.newbytorder(new_order))
     |      
     |      Changes are also made in all fields and sub-arrays of the array data
     |      type.
     |      
     |      
     |      
     |      Parameters
     |      ----------
     |      new_order : string, optional
     |          Byte order to force; a value from the byte order specifications
     |          below. `new_order` codes can be any of:
     |      
     |          * 'S' - swap dtype from current to opposite endian
     |          * {'<', 'L'} - little endian
     |          * {'>', 'B'} - big endian
     |          * {'=', 'N'} - native order
     |          * {'|', 'I'} - ignore (no change to byte order)
     |      
     |          The default value ('S') results in swapping the current
     |          byte order. The code does a case-insensitive check on the first
     |          letter of `new_order` for the alternatives above.  For example,
     |          any of 'B' or 'b' or 'biggish' are valid to specify big-endian.
     |      
     |      
     |      Returns
     |      -------
     |      new_arr : array
     |          New array object with the dtype reflecting given change to the
     |          byte order.
     |  
     |  sseeaarrcchhssoorrtteedd(...)
     |      a.searchsorted(v, side='left', sorter=None)
     |      
     |      Find indices where elements of v should be inserted in a to maintain order.
     |      
     |      For full documentation, see `numpy.searchsorted`
     |      
     |      See Also
     |      --------
     |      numpy.searchsorted : equivalent function
     |  
     |  sseettffiieelldd(...)
     |      a.setfield(val, dtype, offset=0)
     |      
     |      Put a value into a specified place in a field defined by a data-type.
     |      
     |      Place `val` into `a`'s field defined by `dtype` and beginning `offset`
     |      bytes into the field.
     |      
     |      Parameters
     |      ----------
     |      val : object
     |          Value to be placed in field.
     |      dtype : dtype object
     |          Data-type of the field in which to place `val`.
     |      offset : int, optional
     |          The number of bytes into the field at which to place `val`.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      See Also
     |      --------
     |      getfield
     |      
     |      Examples
     |      --------
     |      >>> x = np.eye(3)
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |      >>> x.setfield(3, np.int32)
     |      >>> x.getfield(np.int32)
     |      array([[3, 3, 3],
     |             [3, 3, 3],
     |             [3, 3, 3]])
     |      >>> x
     |      array([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],
     |             [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],
     |             [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])
     |      >>> x.setfield(np.eye(3), np.int32)
     |      >>> x
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |  
     |  sseettffllaaggss(...)
     |      a.setflags(write=None, align=None, uic=None)
     |      
     |      Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.
     |      
     |      These Boolean-valued flags affect how numpy interprets the memory
     |      area used by `a` (see Notes below). The ALIGNED flag can only
     |      be set to True if the data is actually aligned according to the type.
     |      The UPDATEIFCOPY flag can never be set to True. The flag WRITEABLE
     |      can only be set to True if the array owns its own memory, or the
     |      ultimate owner of the memory exposes a writeable buffer interface,
     |      or is a string. (The exception for string is made so that unpickling
     |      can be done without copying memory.)
     |      
     |      Parameters
     |      ----------
     |      write : bool, optional
     |          Describes whether or not `a` can be written to.
     |      align : bool, optional
     |          Describes whether or not `a` is aligned properly for its type.
     |      uic : bool, optional
     |          Describes whether or not `a` is a copy of another "base" array.
     |      
     |      Notes
     |      -----
     |      Array flags provide information about how the memory area used
     |      for the array is to be interpreted. There are 6 Boolean flags
     |      in use, only three of which can be changed by the user:
     |      UPDATEIFCOPY, WRITEABLE, and ALIGNED.
     |      
     |      WRITEABLE (W) the data area can be written to;
     |      
     |      ALIGNED (A) the data and strides are aligned appropriately for the hardware
     |      (as determined by the compiler);
     |      
     |      UPDATEIFCOPY (U) this array is a copy of some other array (referenced
     |      by .base). When this array is deallocated, the base array will be
     |      updated with the contents of this array.
     |      
     |      All flags can be accessed using their first (upper case) letter as well
     |      as the full name.
     |      
     |      Examples
     |      --------
     |      >>> y
     |      array([[3, 1, 7],
     |             [2, 0, 0],
     |             [8, 5, 9]])
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(write=0, align=0)
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : False
     |        ALIGNED : False
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(uic=1)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: cannot set UPDATEIFCOPY flag to True
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from numpy.ndarray:
     |  
     |  ____aarrrraayy__iinntteerrffaaccee____
     |      Array protocol: Python side.
     |  
     |  ____aarrrraayy__ssttrruucctt____
     |      Array protocol: C-struct side.
     |  
     |  bbaassee
     |      Base object if memory is from some other object.
     |      
     |      Examples
     |      --------
     |      The base of an array that owns its memory is None:
     |      
     |      >>> x = np.array([1,2,3,4])
     |      >>> x.base is None
     |      True
     |      
     |      Slicing creates a view, whose memory is shared with x:
     |      
     |      >>> y = x[2:]
     |      >>> y.base is x
     |      True
     |  
     |  ccttyyppeess
     |      An object to simplify the interaction of the array with the ctypes
     |      module.
     |      
     |      This attribute creates an object that makes it easier to use arrays
     |      when calling shared libraries with the ctypes module. The returned
     |      object has, among others, data, shape, and strides attributes (see
     |      Notes below) which themselves return ctypes objects that can be used
     |      as arguments to a shared library.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      c : Python object
     |          Possessing attributes data, shape, strides, etc.
     |      
     |      See Also
     |      --------
     |      numpy.ctypeslib
     |      
     |      Notes
     |      -----
     |      Below are the public attributes of this object which were documented
     |      in "Guide to NumPy" (we have omitted undocumented public attributes,
     |      as well as documented private attributes):
     |      
     |      * data: A pointer to the memory area of the array as a Python integer.
     |        This memory area may contain data that is not aligned, or not in correct
     |        byte-order. The memory area may not even be writeable. The array
     |        flags and data-type of this array should be respected when passing this
     |        attribute to arbitrary C-code to avoid trouble that can include Python
     |        crashing. User Beware! The value of this attribute is exactly the same
     |        as self._array_interface_['data'][0].
     |      
     |      * shape (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the C-integer corresponding to dtype('p') on this
     |        platform. This base-type could be c_int, c_long, or c_longlong
     |        depending on the platform. The c_intp type is defined accordingly in
     |        numpy.ctypeslib. The ctypes array contains the shape of the underlying
     |        array.
     |      
     |      * strides (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the same as for the shape attribute. This ctypes array
     |        contains the strides information from the underlying array. This strides
     |        information is important for showing how many bytes must be jumped to
     |        get to the next element in the array.
     |      
     |      * data_as(obj): Return the data pointer cast to a particular c-types object.
     |        For example, calling self._as_parameter_ is equivalent to
     |        self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
     |        pointer to a ctypes array of floating-point data:
     |        self.data_as(ctypes.POINTER(ctypes.c_double)).
     |      
     |      * shape_as(obj): Return the shape tuple as an array of some other c-types
     |        type. For example: self.shape_as(ctypes.c_short).
     |      
     |      * strides_as(obj): Return the strides tuple as an array of some other
     |        c-types type. For example: self.strides_as(ctypes.c_longlong).
     |      
     |      Be careful using the ctypes attribute - especially on temporary
     |      arrays or arrays constructed on the fly. For example, calling
     |      ``(a+b).ctypes.data_as(ctypes.c_void_p)`` returns a pointer to memory
     |      that is invalid because the array created as (a+b) is deallocated
     |      before the next Python statement. You can avoid this problem using
     |      either ``c=a+b`` or ``ct=(a+b).ctypes``. In the latter case, ct will
     |      hold a reference to the array until ct is deleted or re-assigned.
     |      
     |      If the ctypes module is not available, then the ctypes attribute
     |      of array objects still returns something useful, but ctypes objects
     |      are not returned and errors may be raised instead. In particular,
     |      the object will still have the as parameter attribute which will
     |      return an integer equal to the data attribute.
     |      
     |      Examples
     |      --------
     |      >>> import ctypes
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.ctypes.data
     |      30439712
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))
     |      <ctypes.LP_c_long object at 0x01F01300>
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents
     |      c_long(0)
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents
     |      c_longlong(4294967296L)
     |      >>> x.ctypes.shape
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FFD580>
     |      >>> x.ctypes.shape_as(ctypes.c_long)
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides_as(ctypes.c_longlong)
     |      <numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>
     |  
     |  ddttyyppee
     |      Data-type of the array's elements.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      d : numpy dtype object
     |      
     |      See Also
     |      --------
     |      numpy.dtype
     |      
     |      Examples
     |      --------
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.dtype
     |      dtype('int32')
     |      >>> type(x.dtype)
     |      <type 'numpy.dtype'>
     |  
     |  ffllaaggss
     |      Information about the memory layout of the array.
     |      
     |      Attributes
     |      ----------
     |      C_CONTIGUOUS (C)
     |          The data is in a single, C-style contiguous segment.
     |      F_CONTIGUOUS (F)
     |          The data is in a single, Fortran-style contiguous segment.
     |      OWNDATA (O)
     |          The array owns the memory it uses or borrows it from another object.
     |      WRITEABLE (W)
     |          The data area can be written to.  Setting this to False locks
     |          the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
     |          from its base array at creation time, but a view of a writeable
     |          array may be subsequently locked while the base array remains writeable.
     |          (The opposite is not true, in that a view of a locked array may not
     |          be made writeable.  However, currently, locking a base object does not
     |          lock any views that already reference it, so under that circumstance it
     |          is possible to alter the contents of a locked array via a previously
     |          created writeable view onto it.)  Attempting to change a non-writeable
     |          array raises a RuntimeError exception.
     |      ALIGNED (A)
     |          The data and all elements are aligned appropriately for the hardware.
     |      UPDATEIFCOPY (U)
     |          This array is a copy of some other array. When this array is
     |          deallocated, the base array will be updated with the contents of
     |          this array.
     |      FNC
     |          F_CONTIGUOUS and not C_CONTIGUOUS.
     |      FORC
     |          F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
     |      BEHAVED (B)
     |          ALIGNED and WRITEABLE.
     |      CARRAY (CA)
     |          BEHAVED and C_CONTIGUOUS.
     |      FARRAY (FA)
     |          BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.
     |      
     |      Notes
     |      -----
     |      The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
     |      or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
     |      names are only supported in dictionary access.
     |      
     |      Only the UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by
     |      the user, via direct assignment to the attribute or dictionary entry,
     |      or by calling `ndarray.setflags`.
     |      
     |      The array flags cannot be set arbitrarily:
     |      
     |      - UPDATEIFCOPY can only be set ``False``.
     |      - ALIGNED can only be set ``True`` if the data is truly aligned.
     |      - WRITEABLE can only be set ``True`` if the array owns its own memory
     |        or the ultimate owner of the memory exposes a writeable buffer
     |        interface or is a string.
     |      
     |      Arrays can be both C-style and Fortran-style contiguous simultaneously.
     |      This is clear for 1-dimensional arrays, but can also be true for higher
     |      dimensional arrays.
     |      
     |      Even for contiguous arrays a stride for a given dimension
     |      ``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``
     |      or the array has no elements.
     |      It does *not* generally hold that ``self.strides[-1] == self.itemsize``
     |      for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for
     |      Fortran-style contiguous arrays is true.
     |  
     |  iitteemmssiizzee
     |      Length of one array element in bytes.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1,2,3], dtype=np.float64)
     |      >>> x.itemsize
     |      8
     |      >>> x = np.array([1,2,3], dtype=np.complex128)
     |      >>> x.itemsize
     |      16
     |  
     |  nnbbyytteess
     |      Total bytes consumed by the elements of the array.
     |      
     |      Notes
     |      -----
     |      Does not include memory consumed by non-element attributes of the
     |      array object.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3,5,2), dtype=np.complex128)
     |      >>> x.nbytes
     |      480
     |      >>> np.prod(x.shape) * x.itemsize
     |      480
     |  
     |  nnddiimm
     |      Number of array dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3])
     |      >>> x.ndim
     |      1
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.ndim
     |      3
     |  
     |  sshhaappee
     |      Tuple of array dimensions.
     |      
     |      Notes
     |      -----
     |      May be used to "reshape" the array, as long as this would not
     |      require a change in the total number of elements
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3, 4])
     |      >>> x.shape
     |      (4,)
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.shape
     |      (2, 3, 4)
     |      >>> y.shape = (3, 8)
     |      >>> y
     |      array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
     |      >>> y.shape = (3, 6)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: total size of new array must be unchanged
     |  
     |  ssiizzee
     |      Number of elements in the array.
     |      
     |      Equivalent to ``np.prod(a.shape)``, i.e., the product of the array's
     |      dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3, 5, 2), dtype=np.complex128)
     |      >>> x.size
     |      30
     |      >>> np.prod(x.shape)
     |      30
     |  
     |  ssttrriiddeess
     |      Tuple of bytes to step in each dimension when traversing an array.
     |      
     |      The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
     |      is::
     |      
     |          offset = sum(np.array(i) * a.strides)
     |      
     |      A more detailed explanation of strides can be found in the
     |      "ndarray.rst" file in the NumPy reference guide.
     |      
     |      Notes
     |      -----
     |      Imagine an array of 32-bit integers (each 4 bytes)::
     |      
     |        x = np.array([[0, 1, 2, 3, 4],
     |                      [5, 6, 7, 8, 9]], dtype=np.int32)
     |      
     |      This array is stored in memory as 40 bytes, one after the other
     |      (known as a contiguous block of memory).  The strides of an array tell
     |      us how many bytes we have to skip in memory to move to the next position
     |      along a certain axis.  For example, we have to skip 4 bytes (1 value) to
     |      move to the next column, but 20 bytes (5 values) to get to the same
     |      position in the next row.  As such, the strides for the array `x` will be
     |      ``(20, 4)``.
     |      
     |      See Also
     |      --------
     |      numpy.lib.stride_tricks.as_strided
     |      
     |      Examples
     |      --------
     |      >>> y = np.reshape(np.arange(2*3*4), (2,3,4))
     |      >>> y
     |      array([[[ 0,  1,  2,  3],
     |              [ 4,  5,  6,  7],
     |              [ 8,  9, 10, 11]],
     |             [[12, 13, 14, 15],
     |              [16, 17, 18, 19],
     |              [20, 21, 22, 23]]])
     |      >>> y.strides
     |      (48, 16, 4)
     |      >>> y[1,1,1]
     |      17
     |      >>> offset=sum(y.strides * np.array((1,1,1)))
     |      >>> offset/y.itemsize
     |      17
     |      
     |      >>> x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)
     |      >>> x.strides
     |      (32, 4, 224, 1344)
     |      >>> i = np.array([3,5,2,2])
     |      >>> offset = sum(i * x.strides)
     |      >>> x[3,5,2,2]
     |      813
     |      >>> offset / x.itemsize
     |      813

FFUUNNCCTTIIOONNSS
    aallllcclloossee(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)
        Returns True if two arrays are element-wise equal within a tolerance.
        
        This function is equivalent to `allclose` except that masked values
        are treated as equal (default) or unequal, depending on the `masked_equal`
        argument.
        
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        masked_equal : bool, optional
            Whether masked values in `a` and `b` are considered equal (True) or not
            (False). They are considered equal by default.
        rtol : float, optional
            Relative tolerance. The relative difference is equal to ``rtol * b``.
            Default is 1e-5.
        atol : float, optional
            Absolute tolerance. The absolute difference is equal to `atol`.
            Default is 1e-8.
        
        Returns
        -------
        y : bool
            Returns True if the two arrays are equal within the given
            tolerance, False otherwise. If either array contains NaN, then
            False is returned.
        
        See Also
        --------
        all, any
        numpy.allclose : the non-masked `allclose`.
        
        Notes
        -----
        If the following equation is element-wise True, then `allclose` returns
        True::
        
          absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
        
        Return True if all elements of `a` and `b` are equal subject to
        given tolerances.
        
        Examples
        --------
        >>> a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
        >>> a
        masked_array(data = [10000000000.0 1e-07 --],
                     mask = [False False  True],
               fill_value = 1e+20)
        >>> b = ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
        >>> ma.allclose(a, b)
        False
        
        >>> a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
        >>> b = ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
        >>> ma.allclose(a, b)
        True
        >>> ma.allclose(a, b, masked_equal=False)
        False
        
        Masked values are not compared directly.
        
        >>> a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
        >>> b = ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
        >>> ma.allclose(a, b)
        True
        >>> ma.allclose(a, b, masked_equal=False)
        False
    
    aalllleeqquuaall(a, b, fill_value=True)
        Return True if all entries of a and b are equal, using
        fill_value as a truth value where either or both are masked.
        
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        fill_value : bool, optional
            Whether masked values in a or b are considered equal (True) or not
            (False).
        
        Returns
        -------
        y : bool
            Returns True if the two arrays are equal within the given
            tolerance, False otherwise. If either array contains NaN,
            then False is returned.
        
        See Also
        --------
        all, any
        numpy.ma.allclose
        
        Examples
        --------
        >>> a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
        >>> a
        masked_array(data = [10000000000.0 1e-07 --],
              mask = [False False  True],
              fill_value=1e+20)
        
        >>> b = array([1e10, 1e-7, -42.0])
        >>> b
        array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
        >>> ma.allequal(a, b, fill_value=False)
        False
        >>> ma.allequal(a, b)
        True
    
    aallllttrruuee = reduce(target, axis=0, dtype=None) method of numpy.ma.core._MaskedBinaryOperation instance
        Reduce `target` along the given `axis`.
    
    aammaaxx(a, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
        Return the maximum of an array or maximum along an axis.
        
        Parameters
        ----------
        a : array_like
            Input data.
        axis : None or int or tuple of ints, optional
            Axis or axes along which to operate.  By default, flattened input is
            used.
        
            .. versionadded:: 1.7.0
        
            If this is a tuple of ints, the maximum is selected over multiple axes,
            instead of a single axis or all the axes as before.
        out : ndarray, optional
            Alternative output array in which to place the result.  Must
            be of the same shape and buffer length as the expected output.
            See `doc.ufuncs` (Section "Output arguments") for more details.
        
        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left
            in the result as dimensions with size one. With this option,
            the result will broadcast correctly against the input array.
        
            If the default value is passed, then `keepdims` will not be
            passed through to the `amax` method of sub-classes of
            `ndarray`, however any non-default value will be.  If the
            sub-classes `sum` method does not implement `keepdims` any
            exceptions will be raised.
        
        Returns
        -------
        amax : ndarray or scalar
            Maximum of `a`. If `axis` is None, the result is a scalar value.
            If `axis` is given, the result is an array of dimension
            ``a.ndim - 1``.
        
        See Also
        --------
        amin :
            The minimum value of an array along a given axis, propagating any NaNs.
        nanmax :
            The maximum value of an array along a given axis, ignoring any NaNs.
        maximum :
            Element-wise maximum of two arrays, propagating any NaNs.
        fmax :
            Element-wise maximum of two arrays, ignoring any NaNs.
        argmax :
            Return the indices of the maximum values.
        
        nanmin, minimum, fmin
        
        Notes
        -----
        NaN values are propagated, that is if at least one item is NaN, the
        corresponding max value will be NaN as well. To ignore NaN values
        (MATLAB behavior), please use nanmax.
        
        Don't use `amax` for element-wise comparison of 2 arrays; when
        ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
        ``amax(a, axis=0)``.
        
        Examples
        --------
        >>> a = np.arange(4).reshape((2,2))
        >>> a
        array([[0, 1],
               [2, 3]])
        >>> np.amax(a)           # Maximum of the flattened array
        3
        >>> np.amax(a, axis=0)   # Maxima along the first axis
        array([2, 3])
        >>> np.amax(a, axis=1)   # Maxima along the second axis
        array([1, 3])
        
        >>> b = np.arange(5, dtype=np.float)
        >>> b[2] = np.NaN
        >>> np.amax(b)
        nan
        >>> np.nanmax(b)
        4.0
    
    aammiinn(a, axis=None, out=None, keepdims=<class 'numpy._globals._NoValue'>)
        Return the minimum of an array or minimum along an axis.
        
        Parameters
        ----------
        a : array_like
            Input data.
        axis : None or int or tuple of ints, optional
            Axis or axes along which to operate.  By default, flattened input is
            used.
        
            .. versionadded:: 1.7.0
        
            If this is a tuple of ints, the minimum is selected over multiple axes,
            instead of a single axis or all the axes as before.
        out : ndarray, optional
            Alternative output array in which to place the result.  Must
            be of the same shape and buffer length as the expected output.
            See `doc.ufuncs` (Section "Output arguments") for more details.
        
        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left
            in the result as dimensions with size one. With this option,
            the result will broadcast correctly against the input array.
        
            If the default value is passed, then `keepdims` will not be
            passed through to the `amin` method of sub-classes of
            `ndarray`, however any non-default value will be.  If the
            sub-classes `sum` method does not implement `keepdims` any
            exceptions will be raised.
        
        Returns
        -------
        amin : ndarray or scalar
            Minimum of `a`. If `axis` is None, the result is a scalar value.
            If `axis` is given, the result is an array of dimension
            ``a.ndim - 1``.
        
        See Also
        --------
        amax :
            The maximum value of an array along a given axis, propagating any NaNs.
        nanmin :
            The minimum value of an array along a given axis, ignoring any NaNs.
        minimum :
            Element-wise minimum of two arrays, propagating any NaNs.
        fmin :
            Element-wise minimum of two arrays, ignoring any NaNs.
        argmin :
            Return the indices of the minimum values.
        
        nanmax, maximum, fmax
        
        Notes
        -----
        NaN values are propagated, that is if at least one item is NaN, the
        corresponding min value will be NaN as well. To ignore NaN values
        (MATLAB behavior), please use nanmin.
        
        Don't use `amin` for element-wise comparison of 2 arrays; when
        ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
        ``amin(a, axis=0)``.
        
        Examples
        --------
        >>> a = np.arange(4).reshape((2,2))
        >>> a
        array([[0, 1],
               [2, 3]])
        >>> np.amin(a)           # Minimum of the flattened array
        0
        >>> np.amin(a, axis=0)   # Minima along the first axis
        array([0, 1])
        >>> np.amin(a, axis=1)   # Minima along the second axis
        array([0, 2])
        
        >>> b = np.arange(5, dtype=np.float)
        >>> b[2] = np.NaN
        >>> np.amin(b)
        nan
        >>> np.nanmin(b)
        0.0
    
    aappppeenndd(a, b, axis=None)
        Append values to the end of an array.
        
        .. versionadded:: 1.9.0
        
        Parameters
        ----------
        a : array_like
            Values are appended to a copy of this array.
        b : array_like
            These values are appended to a copy of `a`.  It must be of the
            correct shape (the same shape as `a`, excluding `axis`).  If `axis`
            is not specified, `b` can be any shape and will be flattened
            before use.
        axis : int, optional
            The axis along which `v` are appended.  If `axis` is not given,
            both `a` and `b` are flattened before use.
        
        Returns
        -------
        append : MaskedArray
            A copy of `a` with `b` appended to `axis`.  Note that `append`
            does not occur in-place: a new array is allocated and filled.  If
            `axis` is None, the result is a flattened array.
        
        See Also
        --------
        numpy.append : Equivalent function in the top-level NumPy module.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.masked_values([1, 2, 3], 2)
        >>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
        >>> print(ma.append(a, b))
        [1 -- 3 4 5 6 -- 8 9]
    
    aappppllyy__aalloonngg__aaxxiiss(func1d, axis, arr, *args, **kwargs)
        Apply a function to 1-D slices along the given axis.
        
        Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
        is a 1-D slice of `arr` along `axis`.
        
        Parameters
        ----------
        func1d : function
            This function should accept 1-D arrays. It is applied to 1-D
            slices of `arr` along the specified axis.
        axis : integer
            Axis along which `arr` is sliced.
        arr : ndarray
            Input array.
        args : any
            Additional arguments to `func1d`.
        kwargs : any
            Additional named arguments to `func1d`.
        
            .. versionadded:: 1.9.0
        
        
        Returns
        -------
        apply_along_axis : ndarray
            The output array. The shape of `outarr` is identical to the shape of
            `arr`, except along the `axis` dimension. This axis is removed, and
            replaced with new dimensions equal to the shape of the return value
            of `func1d`. So if `func1d` returns a scalar `outarr` will have one
            fewer dimensions than `arr`.
        
        See Also
        --------
        apply_over_axes : Apply a function repeatedly over multiple axes.
        
        Examples
        --------
        >>> def my_func(a):
        ...     """Average first and last element of a 1-D array"""
        ...     return (a[0] + a[-1]) * 0.5
        >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
        >>> np.apply_along_axis(my_func, 0, b)
        array([ 4.,  5.,  6.])
        >>> np.apply_along_axis(my_func, 1, b)
        array([ 2.,  5.,  8.])
        
        For a function that returns a 1D array, the number of dimensions in
        `outarr` is the same as `arr`.
        
        >>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
        >>> np.apply_along_axis(sorted, 1, b)
        array([[1, 7, 8],
               [3, 4, 9],
               [2, 5, 6]])
        
        For a function that returns a higher dimensional array, those dimensions
        are inserted in place of the `axis` dimension.
        
        >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
        >>> np.apply_along_axis(np.diag, -1, b)
        array([[[1, 0, 0],
                [0, 2, 0],
                [0, 0, 3]],
        
               [[4, 0, 0],
                [0, 5, 0],
                [0, 0, 6]],
        
               [[7, 0, 0],
                [0, 8, 0],
                [0, 0, 9]]])
    
    aappppllyy__oovveerr__aaxxeess(func, a, axes)
        Apply a function repeatedly over multiple axes.
        
        `func` is called as `res = func(a, axis)`, where `axis` is the first
        element of `axes`.  The result `res` of the function call must have
        either the same dimensions as `a` or one less dimension.  If `res`
        has one less dimension than `a`, a dimension is inserted before
        `axis`.  The call to `func` is then repeated for each axis in `axes`,
        with `res` as the first argument.
        
        Parameters
        ----------
        func : function
            This function must take two arguments, `func(a, axis)`.
        a : array_like
            Input array.
        axes : array_like
            Axes over which `func` is applied; the elements must be integers.
        
        Returns
        -------
        apply_over_axis : ndarray
            The output array.  The number of dimensions is the same as `a`,
            but the shape can be different.  This depends on whether `func`
            changes the shape of its output with respect to its input.
        
        See Also
        --------
        apply_along_axis :
            Apply a function to 1-D slices of an array along the given axis.
        
        Examples
        --------
        >>> a = ma.arange(24).reshape(2,3,4)
        >>> a[:,0,1] = ma.masked
        >>> a[:,1,:] = ma.masked
        >>> print(a)
        [[[0 -- 2 3]
          [-- -- -- --]
          [8 9 10 11]]
        
         [[12 -- 14 15]
          [-- -- -- --]
          [20 21 22 23]]]
        >>> print(ma.apply_over_axes(ma.sum, a, [0,2]))
        [[[46]
          [--]
          [124]]]
        
        Tuple axis arguments to ufuncs are equivalent:
        
        >>> print(ma.sum(a, axis=(0,2)).reshape((1,-1,1)))
        [[[46]
          [--]
          [124]]]
    
    aarrggssoorrtt(a, axis=<class 'numpy._globals._NoValue'>, kind='quicksort', order=None, endwith=True, fill_value=None)
        Return an ndarray of indices that sort the array along the
        specified axis.  Masked values are filled beforehand to
        `fill_value`.
        
        Parameters
        ----------
        axis : int, optional
            Axis along which to sort. If None, the default, the flattened array
            is used.
        
            ..  versionchanged:: 1.13.0
                Previously, the default was documented to be -1, but that was
                in error. At some future date, the default will change to -1, as
                originally intended.
                Until then, the axis should be given explicitly when
                ``arr.ndim > 1``, to avoid a FutureWarning.
        kind : {'quicksort', 'mergesort', 'heapsort'}, optional
            Sorting algorithm.
        order : list, optional
            When `a` is an array with fields defined, this argument specifies
            which fields to compare first, second, etc.  Not all fields need be
            specified.
        endwith : {True, False}, optional
            Whether missing values (if any) should be treated as the largest values
            (True) or the smallest values (False)
            When the array contains unmasked values at the same extremes of the
            datatype, the ordering of these values and the masked values is
            undefined.
        fill_value : {var}, optional
            Value used internally for the masked values.
            If ``fill_value`` is not None, it supersedes ``endwith``.
        
        Returns
        -------
        index_array : ndarray, int
            Array of indices that sort `a` along the specified axis.
            In other words, ``a[index_array]`` yields a sorted `a`.
        
        See Also
        --------
        MaskedArray.sort : Describes sorting algorithms used.
        lexsort : Indirect stable sort with multiple keys.
        ndarray.sort : Inplace sort.
        
        Notes
        -----
        See `sort` for notes on the different sorting algorithms.
        
        Examples
        --------
        >>> a = np.ma.array([3,2,1], mask=[False, False, True])
        >>> a
        masked_array(data = [3 2 --],
                     mask = [False False  True],
               fill_value = 999999)
        >>> a.argsort()
        array([1, 0, 2])
    
    aarrrraayy(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)
        An array class with possibly masked values.
        
        Masked values of True exclude the corresponding element from any
        computation.
        
        Construction::
        
          x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                          ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                          shrink=True, order=None)
        
        Parameters
        ----------
        data : array_like
            Input data.
        mask : sequence, optional
            Mask. Must be convertible to an array of booleans with the same
            shape as `data`. True indicates a masked (i.e. invalid) data.
        dtype : dtype, optional
            Data type of the output.
            If `dtype` is None, the type of the data argument (``data.dtype``)
            is used. If `dtype` is not None and different from ``data.dtype``,
            a copy is performed.
        copy : bool, optional
            Whether to copy the input data (True), or to use a reference instead.
            Default is False.
        subok : bool, optional
            Whether to return a subclass of `MaskedArray` if possible (True) or a
            plain `MaskedArray`. Default is True.
        ndmin : int, optional
            Minimum number of dimensions. Default is 0.
        fill_value : scalar, optional
            Value used to fill in the masked values when necessary.
            If None, a default based on the data-type is used.
        keep_mask : bool, optional
            Whether to combine `mask` with the mask of the input data, if any
            (True), or to use only `mask` for the output (False). Default is True.
        hard_mask : bool, optional
            Whether to use a hard mask or not. With a hard mask, masked values
            cannot be unmasked. Default is False.
        shrink : bool, optional
            Whether to force compression of an empty mask. Default is True.
        order : {'C', 'F', 'A'}, optional
            Specify the order of the array.  If order is 'C', then the array
            will be in C-contiguous order (last-index varies the fastest).
            If order is 'F', then the returned array will be in
            Fortran-contiguous order (first-index varies the fastest).
            If order is 'A' (default), then the returned array may be
            in any order (either C-, Fortran-contiguous, or even discontiguous),
            unless a copy is required, in which case it will be C-contiguous.
    
    aassaannyyaarrrraayy(a, dtype=None)
        Convert the input to a masked array, conserving subclasses.
        
        If `a` is a subclass of `MaskedArray`, its class is conserved.
        No copy is performed if the input is already an `ndarray`.
        
        Parameters
        ----------
        a : array_like
            Input data, in any form that can be converted to an array.
        dtype : dtype, optional
            By default, the data-type is inferred from the input data.
        order : {'C', 'F'}, optional
            Whether to use row-major ('C') or column-major ('FORTRAN') memory
            representation.  Default is 'C'.
        
        Returns
        -------
        out : MaskedArray
            MaskedArray interpretation of `a`.
        
        See Also
        --------
        asarray : Similar to `asanyarray`, but does not conserve subclass.
        
        Examples
        --------
        >>> x = np.arange(10.).reshape(2, 5)
        >>> x
        array([[ 0.,  1.,  2.,  3.,  4.],
               [ 5.,  6.,  7.,  8.,  9.]])
        >>> np.ma.asanyarray(x)
        masked_array(data =
         [[ 0.  1.  2.  3.  4.]
         [ 5.  6.  7.  8.  9.]],
                     mask =
         False,
               fill_value = 1e+20)
        >>> type(np.ma.asanyarray(x))
        <class 'numpy.ma.core.MaskedArray'>
    
    aassaarrrraayy(a, dtype=None, order=None)
        Convert the input to a masked array of the given data-type.
        
        No copy is performed if the input is already an `ndarray`. If `a` is
        a subclass of `MaskedArray`, a base class `MaskedArray` is returned.
        
        Parameters
        ----------
        a : array_like
            Input data, in any form that can be converted to a masked array. This
            includes lists, lists of tuples, tuples, tuples of tuples, tuples
            of lists, ndarrays and masked arrays.
        dtype : dtype, optional
            By default, the data-type is inferred from the input data.
        order : {'C', 'F'}, optional
            Whether to use row-major ('C') or column-major ('FORTRAN') memory
            representation.  Default is 'C'.
        
        Returns
        -------
        out : MaskedArray
            Masked array interpretation of `a`.
        
        See Also
        --------
        asanyarray : Similar to `asarray`, but conserves subclasses.
        
        Examples
        --------
        >>> x = np.arange(10.).reshape(2, 5)
        >>> x
        array([[ 0.,  1.,  2.,  3.,  4.],
               [ 5.,  6.,  7.,  8.,  9.]])
        >>> np.ma.asarray(x)
        masked_array(data =
         [[ 0.  1.  2.  3.  4.]
         [ 5.  6.  7.  8.  9.]],
                     mask =
         False,
               fill_value = 1e+20)
        >>> type(np.ma.asarray(x))
        <class 'numpy.ma.core.MaskedArray'>
    
    aavveerraaggee(a, axis=None, weights=None, returned=False)
        Return the weighted average of array over the given axis.
        
        Parameters
        ----------
        a : array_like
            Data to be averaged.
            Masked entries are not taken into account in the computation.
        axis : int, optional
            Axis along which to average `a`. If `None`, averaging is done over
            the flattened array.
        weights : array_like, optional
            The importance that each element has in the computation of the average.
            The weights array can either be 1-D (in which case its length must be
            the size of `a` along the given axis) or of the same shape as `a`.
            If ``weights=None``, then all data in `a` are assumed to have a
            weight equal to one.   If `weights` is complex, the imaginary parts
            are ignored.
        returned : bool, optional
            Flag indicating whether a tuple ``(result, sum of weights)``
            should be returned as output (True), or just the result (False).
            Default is False.
        
        Returns
        -------
        average, [sum_of_weights] : (tuple of) scalar or MaskedArray
            The average along the specified axis. When returned is `True`,
            return a tuple with the average as the first element and the sum
            of the weights as the second element. The return type is `np.float64`
            if `a` is of integer type and floats smaller than `float64`, or the
            input data-type, otherwise. If returned, `sum_of_weights` is always
            `float64`.
        
        Examples
        --------
        >>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
        >>> np.ma.average(a, weights=[3, 1, 0, 0])
        1.25
        
        >>> x = np.ma.arange(6.).reshape(3, 2)
        >>> print(x)
        [[ 0.  1.]
         [ 2.  3.]
         [ 4.  5.]]
        >>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
        ...                                 returned=True)
        >>> print(avg)
        [2.66666666667 3.66666666667]
    
    cchhoooossee(indices, choices, out=None, mode='raise')
        Use an index array to construct a new array from a set of choices.
        
        Given an array of integers and a set of n choice arrays, this method
        will create a new array that merges each of the choice arrays.  Where a
        value in `a` is i, the new array will have the value that choices[i]
        contains in the same place.
        
        Parameters
        ----------
        a : ndarray of ints
            This array must contain integers in ``[0, n-1]``, where n is the
            number of choices.
        choices : sequence of arrays
            Choice arrays. The index array and all of the choices should be
            broadcastable to the same shape.
        out : array, optional
            If provided, the result will be inserted into this array. It should
            be of the appropriate shape and `dtype`.
        mode : {'raise', 'wrap', 'clip'}, optional
            Specifies how out-of-bounds indices will behave.
        
            * 'raise' : raise an error
            * 'wrap' : wrap around
            * 'clip' : clip to the range
        
        Returns
        -------
        merged_array : array
        
        See Also
        --------
        choose : equivalent function
        
        Examples
        --------
        >>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
        >>> a = np.array([2, 1, 0])
        >>> np.ma.choose(a, choice)
        masked_array(data = [3 2 1],
              mask = False,
              fill_value=999999)
    
    cclliipp(a, a_min, a_max, out=None)
        Clip (limit) the values in an array.
        
        Given an interval, values outside the interval are clipped to
        the interval edges.  For example, if an interval of ``[0, 1]``
        is specified, values smaller than 0 become 0, and values larger
        than 1 become 1.
        
        Parameters
        ----------
        a : array_like
            Array containing elements to clip.
        a_min : scalar or array_like or `None`
            Minimum value. If `None`, clipping is not performed on lower
            interval edge. Not more than one of `a_min` and `a_max` may be
            `None`.
        a_max : scalar or array_like or `None`
            Maximum value. If `None`, clipping is not performed on upper
            interval edge. Not more than one of `a_min` and `a_max` may be
            `None`. If `a_min` or `a_max` are array_like, then the three
            arrays will be broadcasted to match their shapes.
        out : ndarray, optional
            The results will be placed in this array. It may be the input
            array for in-place clipping.  `out` must be of the right shape
            to hold the output.  Its type is preserved.
        
        Returns
        -------
        clipped_array : ndarray
            An array with the elements of `a`, but where values
            < `a_min` are replaced with `a_min`, and those > `a_max`
            with `a_max`.
        
        See Also
        --------
        numpy.doc.ufuncs : Section "Output arguments"
        
        Examples
        --------
        >>> a = np.arange(10)
        >>> np.clip(a, 1, 8)
        array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
        >>> a
        array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
        >>> np.clip(a, 3, 6, out=a)
        array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
        >>> a = np.arange(10)
        >>> a
        array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
        >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
        array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
    
    cclluummpp__mmaasskkeedd(a)
        Returns a list of slices corresponding to the masked clumps of a 1-D array.
        (A "clump" is defined as a contiguous region of the array).
        
        Parameters
        ----------
        a : ndarray
            A one-dimensional masked array.
        
        Returns
        -------
        slices : list of slice
            The list of slices, one for each continuous region of masked elements
            in `a`.
        
        Notes
        -----
        .. versionadded:: 1.4.0
        
        See Also
        --------
        flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
        notmasked_contiguous, clump_unmasked
        
        Examples
        --------
        >>> a = np.ma.masked_array(np.arange(10))
        >>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
        >>> np.ma.clump_masked(a)
        [slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]
    
    cclluummpp__uunnmmaasskkeedd(a)
        Return list of slices corresponding to the unmasked clumps of a 1-D array.
        (A "clump" is defined as a contiguous region of the array).
        
        Parameters
        ----------
        a : ndarray
            A one-dimensional masked array.
        
        Returns
        -------
        slices : list of slice
            The list of slices, one for each continuous region of unmasked
            elements in `a`.
        
        Notes
        -----
        .. versionadded:: 1.4.0
        
        See Also
        --------
        flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
        notmasked_contiguous, clump_masked
        
        Examples
        --------
        >>> a = np.ma.masked_array(np.arange(10))
        >>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
        >>> np.ma.clump_unmasked(a)
        [slice(3, 6, None), slice(7, 8, None)]
    
    ccoommmmoonn__ffiillll__vvaalluuee(a, b)
        Return the common filling value of two masked arrays, if any.
        
        If ``a.fill_value == b.fill_value``, return the fill value,
        otherwise return None.
        
        Parameters
        ----------
        a, b : MaskedArray
            The masked arrays for which to compare fill values.
        
        Returns
        -------
        fill_value : scalar or None
            The common fill value, or None.
        
        Examples
        --------
        >>> x = np.ma.array([0, 1.], fill_value=3)
        >>> y = np.ma.array([0, 1.], fill_value=3)
        >>> np.ma.common_fill_value(x, y)
        3.0
    
    ccoommpprreessss__ccoollss(a)
        Suppress whole columns of a 2-D array that contain masked values.
        
        This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
        `extras.compress_rowcols` for details.
        
        See Also
        --------
        extras.compress_rowcols
    
    ccoommpprreessss__nndd(x, axis=None)
        Suppress slices from multiple dimensions which contain masked values.
        
        Parameters
        ----------
        x : array_like, MaskedArray
            The array to operate on. If not a MaskedArray instance (or if no array
            elements are masked, `x` is interpreted as a MaskedArray with `mask`
            set to `nomask`.
        axis : tuple of ints or int, optional
            Which dimensions to suppress slices from can be configured with this
            parameter.
            - If axis is a tuple of ints, those are the axes to suppress slices from.
            - If axis is an int, then that is the only axis to suppress slices from.
            - If axis is None, all axis are selected.
        
        Returns
        -------
        compress_array : ndarray
            The compressed array.
    
    ccoommpprreessss__rroowwccoollss(x, axis=None)
        Suppress the rows and/or columns of a 2-D array that contain
        masked values.
        
        The suppression behavior is selected with the `axis` parameter.
        
        - If axis is None, both rows and columns are suppressed.
        - If axis is 0, only rows are suppressed.
        - If axis is 1 or -1, only columns are suppressed.
        
        Parameters
        ----------
        x : array_like, MaskedArray
            The array to operate on.  If not a MaskedArray instance (or if no array
            elements are masked), `x` is interpreted as a MaskedArray with
            `mask` set to `nomask`. Must be a 2D array.
        axis : int, optional
            Axis along which to perform the operation. Default is None.
        
        Returns
        -------
        compressed_array : ndarray
            The compressed array.
        
        Examples
        --------
        >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
        ...                                                   [1, 0, 0],
        ...                                                   [0, 0, 0]])
        >>> x
        masked_array(data =
         [[-- 1 2]
         [-- 4 5]
         [6 7 8]],
                     mask =
         [[ True False False]
         [ True False False]
         [False False False]],
               fill_value = 999999)
        
        >>> np.ma.compress_rowcols(x)
        array([[7, 8]])
        >>> np.ma.compress_rowcols(x, 0)
        array([[6, 7, 8]])
        >>> np.ma.compress_rowcols(x, 1)
        array([[1, 2],
               [4, 5],
               [7, 8]])
    
    ccoommpprreessss__rroowwss(a)
        Suppress whole rows of a 2-D array that contain masked values.
        
        This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
        `extras.compress_rowcols` for details.
        
        See Also
        --------
        extras.compress_rowcols
    
    ccoommpprreesssseedd(x)
        Return all the non-masked data as a 1-D array.
        
        This function is equivalent to calling the "compressed" method of a
        `MaskedArray`, see `MaskedArray.compressed` for details.
        
        See Also
        --------
        MaskedArray.compressed
            Equivalent method.
    
    ccoonnccaatteennaattee(arrays, axis=0)
        Concatenate a sequence of arrays along the given axis.
        
        Parameters
        ----------
        arrays : sequence of array_like
            The arrays must have the same shape, except in the dimension
            corresponding to `axis` (the first, by default).
        axis : int, optional
            The axis along which the arrays will be joined. Default is 0.
        
        Returns
        -------
        result : MaskedArray
            The concatenated array with any masked entries preserved.
        
        See Also
        --------
        numpy.concatenate : Equivalent function in the top-level NumPy module.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.arange(3)
        >>> a[1] = ma.masked
        >>> b = ma.arange(2, 5)
        >>> a
        masked_array(data = [0 -- 2],
                     mask = [False  True False],
               fill_value = 999999)
        >>> b
        masked_array(data = [2 3 4],
                     mask = False,
               fill_value = 999999)
        >>> ma.concatenate([a, b])
        masked_array(data = [0 -- 2 2 3 4],
                     mask = [False  True False False False False],
               fill_value = 999999)
    
    ccoonnvvoollvvee(a, v, mode='full', propagate_mask=True)
        Returns the discrete, linear convolution of two one-dimensional sequences.
        
        Parameters
        ----------
        a, v : array_like
            Input sequences.
        mode : {'valid', 'same', 'full'}, optional
            Refer to the `np.convolve` docstring.
        propagate_mask : bool
            If True, then if any masked element is included in the sum for a result
            element, then the result is masked.
            If False, then the result element is only masked if no non-masked cells
            contribute towards it
        
        Returns
        -------
        out : MaskedArray
            Discrete, linear convolution of `a` and `v`.
        
        See Also
        --------
        numpy.convolve : Equivalent function in the top-level NumPy module.
    
    ccoorrrrccooeeff(x, y=None, rowvar=True, bias=<class 'numpy._globals._NoValue'>, allow_masked=True, ddof=<class 'numpy._globals._NoValue'>)
        Return Pearson product-moment correlation coefficients.
        
        Except for the handling of missing data this function does the same as
        `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.
        
        Parameters
        ----------
        x : array_like
            A 1-D or 2-D array containing multiple variables and observations.
            Each row of `x` represents a variable, and each column a single
            observation of all those variables. Also see `rowvar` below.
        y : array_like, optional
            An additional set of variables and observations. `y` has the same
            shape as `x`.
        rowvar : bool, optional
            If `rowvar` is True (default), then each row represents a
            variable, with observations in the columns. Otherwise, the relationship
            is transposed: each column represents a variable, while the rows
            contain observations.
        bias : _NoValue, optional
            Has no effect, do not use.
        
            .. deprecated:: 1.10.0
        allow_masked : bool, optional
            If True, masked values are propagated pair-wise: if a value is masked
            in `x`, the corresponding value is masked in `y`.
            If False, raises an exception.  Because `bias` is deprecated, this
            argument needs to be treated as keyword only to avoid a warning.
        ddof : _NoValue, optional
            Has no effect, do not use.
        
            .. deprecated:: 1.10.0
        
        See Also
        --------
        numpy.corrcoef : Equivalent function in top-level NumPy module.
        cov : Estimate the covariance matrix.
        
        Notes
        -----
        This function accepts but discards arguments `bias` and `ddof`.  This is
        for backwards compatibility with previous versions of this function.  These
        arguments had no effect on the return values of the function and can be
        safely ignored in this and previous versions of numpy.
    
    ccoorrrreellaattee(a, v, mode='valid', propagate_mask=True)
        Cross-correlation of two 1-dimensional sequences.
        
        Parameters
        ----------
        a, v : array_like
            Input sequences.
        mode : {'valid', 'same', 'full'}, optional
            Refer to the `np.convolve` docstring.  Note that the default
            is 'valid', unlike `convolve`, which uses 'full'.
        propagate_mask : bool
            If True, then a result element is masked if any masked element contributes towards it.
            If False, then a result element is only masked if no non-masked element
            contribute towards it
        
        Returns
        -------
        out : MaskedArray
            Discrete cross-correlation of `a` and `v`.
        
        See Also
        --------
        numpy.correlate : Equivalent function in the top-level NumPy module.
    
    ccoouunntt__mmaasskkeedd(arr, axis=None)
        Count the number of masked elements along the given axis.
        
        Parameters
        ----------
        arr : array_like
            An array with (possibly) masked elements.
        axis : int, optional
            Axis along which to count. If None (default), a flattened
            version of the array is used.
        
        Returns
        -------
        count : int, ndarray
            The total number of masked elements (axis=None) or the number
            of masked elements along each slice of the given axis.
        
        See Also
        --------
        MaskedArray.count : Count non-masked elements.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(9).reshape((3,3))
        >>> a = ma.array(a)
        >>> a[1, 0] = ma.masked
        >>> a[1, 2] = ma.masked
        >>> a[2, 1] = ma.masked
        >>> a
        masked_array(data =
         [[0 1 2]
         [-- 4 --]
         [6 -- 8]],
              mask =
         [[False False False]
         [ True False  True]
         [False  True False]],
              fill_value=999999)
        >>> ma.count_masked(a)
        3
        
        When the `axis` keyword is used an array is returned.
        
        >>> ma.count_masked(a, axis=0)
        array([1, 1, 1])
        >>> ma.count_masked(a, axis=1)
        array([0, 2, 1])
    
    ccoovv(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)
        Estimate the covariance matrix.
        
        Except for the handling of missing data this function does the same as
        `numpy.cov`. For more details and examples, see `numpy.cov`.
        
        By default, masked values are recognized as such. If `x` and `y` have the
        same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
        ``y[i,j]`` will also be masked.
        Setting `allow_masked` to False will raise an exception if values are
        missing in either of the input arrays.
        
        Parameters
        ----------
        x : array_like
            A 1-D or 2-D array containing multiple variables and observations.
            Each row of `x` represents a variable, and each column a single
            observation of all those variables. Also see `rowvar` below.
        y : array_like, optional
            An additional set of variables and observations. `y` has the same
            form as `x`.
        rowvar : bool, optional
            If `rowvar` is True (default), then each row represents a
            variable, with observations in the columns. Otherwise, the relationship
            is transposed: each column represents a variable, while the rows
            contain observations.
        bias : bool, optional
            Default normalization (False) is by ``(N-1)``, where ``N`` is the
            number of observations given (unbiased estimate). If `bias` is True,
            then normalization is by ``N``. This keyword can be overridden by
            the keyword ``ddof`` in numpy versions >= 1.5.
        allow_masked : bool, optional
            If True, masked values are propagated pair-wise: if a value is masked
            in `x`, the corresponding value is masked in `y`.
            If False, raises a `ValueError` exception when some values are missing.
        ddof : {None, int}, optional
            If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
            the number of observations; this overrides the value implied by
            ``bias``. The default value is ``None``.
        
            .. versionadded:: 1.5
        
        Raises
        ------
        ValueError
            Raised if some values are missing and `allow_masked` is False.
        
        See Also
        --------
        numpy.cov
    
    ddeeffaauulltt__ffiillll__vvaalluuee(obj)
        Return the default fill value for the argument object.
        
        The default filling value depends on the datatype of the input
        array or the type of the input scalar:
        
           ========  ========
           datatype  default
           ========  ========
           bool      True
           int       999999
           float     1.e20
           complex   1.e20+0j
           object    '?'
           string    'N/A'
           ========  ========
        
        
        Parameters
        ----------
        obj : ndarray, dtype or scalar
            The array data-type or scalar for which the default fill value
            is returned.
        
        Returns
        -------
        fill_value : scalar
            The default fill value.
        
        Examples
        --------
        >>> np.ma.default_fill_value(1)
        999999
        >>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
        1e+20
        >>> np.ma.default_fill_value(np.dtype(complex))
        (1e+20+0j)
    
    ddiiaagg(v, k=0)
        Extract a diagonal or construct a diagonal array.
        
        This function is the equivalent of `numpy.diag` that takes masked
        values into account, see `numpy.diag` for details.
        
        See Also
        --------
        numpy.diag : Equivalent function for ndarrays.
    
    ddiiffff(a, n=1, axis=-1)
        Calculate the n-th discrete difference along given axis.
        
        The first difference is given by ``out[n] = a[n+1] - a[n]`` along
        the given axis, higher differences are calculated by using `diff`
        recursively.
        
        Parameters
        ----------
        a : array_like
            Input array
        n : int, optional
            The number of times values are differenced.
        axis : int, optional
            The axis along which the difference is taken, default is the last axis.
        
        Returns
        -------
        diff : ndarray
            The n-th differences. The shape of the output is the same as `a`
            except along `axis` where the dimension is smaller by `n`. The
            type of the output is the same as that of the input.
        
        See Also
        --------
        gradient, ediff1d, cumsum
        
        Notes
        -----
        For boolean arrays, the preservation of type means that the result
        will contain `False` when consecutive elements are the same and
        `True` when they differ.
        
        For unsigned integer arrays, the results will also be unsigned. This should
        not be surprising, as the result is consistent with calculating the
        difference directly:
        
        >>> u8_arr = np.array([1, 0], dtype=np.uint8)
        >>> np.diff(u8_arr)
        array([255], dtype=uint8)
        >>> u8_arr[1,...] - u8_arr[0,...]
        array(255, np.uint8)
        
        If this is not desirable, then the array should be cast to a larger integer
        type first:
        
        >>> i16_arr = u8_arr.astype(np.int16)
        >>> np.diff(i16_arr)
        array([-1], dtype=int16)
        
        Examples
        --------
        >>> x = np.array([1, 2, 4, 7, 0])
        >>> np.diff(x)
        array([ 1,  2,  3, -7])
        >>> np.diff(x, n=2)
        array([  1,   1, -10])
        
        >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
        >>> np.diff(x)
        array([[2, 3, 4],
               [5, 1, 2]])
        >>> np.diff(x, axis=0)
        array([[-1,  2,  0, -2]])
    
    ddoott(a, b, strict=False, out=None)
        Return the dot product of two arrays.
        
        This function is the equivalent of `numpy.dot` that takes masked values
        into account. Note that `strict` and `out` are in different position
        than in the method version. In order to maintain compatibility with the
        corresponding method, it is recommended that the optional arguments be
        treated as keyword only.  At some point that may be mandatory.
        
        .. note::
          Works only with 2-D arrays at the moment.
        
        
        Parameters
        ----------
        a, b : masked_array_like
            Inputs arrays.
        strict : bool, optional
            Whether masked data are propagated (True) or set to 0 (False) for
            the computation. Default is False.  Propagating the mask means that
            if a masked value appears in a row or column, the whole row or
            column is considered masked.
        out : masked_array, optional
            Output argument. This must have the exact kind that would be returned
            if it was not used. In particular, it must have the right type, must be
            C-contiguous, and its dtype must be the dtype that would be returned
            for `dot(a,b)`. This is a performance feature. Therefore, if these
            conditions are not met, an exception is raised, instead of attempting
            to be flexible.
        
            .. versionadded:: 1.10.2
        
        See Also
        --------
        numpy.dot : Equivalent function for ndarrays.
        
        Examples
        --------
        >>> a = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
        >>> b = ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
        >>> np.ma.dot(a, b)
        masked_array(data =
         [[21 26]
         [45 64]],
                     mask =
         [[False False]
         [False False]],
               fill_value = 999999)
        >>> np.ma.dot(a, b, strict=True)
        masked_array(data =
         [[-- --]
         [-- 64]],
                     mask =
         [[ True  True]
         [ True False]],
               fill_value = 999999)
    
    dduummpp(a, F)
        Pickle a masked array to a file.
        
        This is a wrapper around ``cPickle.dump``.
        
        Parameters
        ----------
        a : MaskedArray
            The array to be pickled.
        F : str or file-like object
            The file to pickle `a` to. If a string, the full path to the file.
    
    dduummppss(a)
        Return a string corresponding to the pickling of a masked array.
        
        This is a wrapper around ``cPickle.dumps``.
        
        Parameters
        ----------
        a : MaskedArray
            The array for which the string representation of the pickle is
            returned.
    
    eeddiiffff11dd(arr, to_end=None, to_begin=None)
        Compute the differences between consecutive elements of an array.
        
        This function is the equivalent of `numpy.ediff1d` that takes masked
        values into account, see `numpy.ediff1d` for details.
        
        See Also
        --------
        numpy.ediff1d : Equivalent function for ndarrays.
    
    eexxppaanndd__ddiimmss(x, axis)
        Expand the shape of an array.
        
        Expands the shape of the array by including a new axis before the one
        specified by the `axis` parameter. This function behaves the same as
        `numpy.expand_dims` but preserves masked elements.
        
        See Also
        --------
        numpy.expand_dims : Equivalent function in top-level NumPy module.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = ma.array([1, 2, 4])
        >>> x[1] = ma.masked
        >>> x
        masked_array(data = [1 -- 4],
                     mask = [False  True False],
               fill_value = 999999)
        >>> np.expand_dims(x, axis=0)
        array([[1, 2, 4]])
        >>> ma.expand_dims(x, axis=0)
        masked_array(data =
         [[1 -- 4]],
                     mask =
         [[False  True False]],
               fill_value = 999999)
        
        The same result can be achieved using slicing syntax with `np.newaxis`.
        
        >>> x[np.newaxis, :]
        masked_array(data =
         [[1 -- 4]],
                     mask =
         [[False  True False]],
               fill_value = 999999)
    
    ffiilllleedd(a, fill_value=None)
        Return input as an array with masked data replaced by a fill value.
        
        If `a` is not a `MaskedArray`, `a` itself is returned.
        If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
        ``a.fill_value``.
        
        Parameters
        ----------
        a : MaskedArray or array_like
            An input object.
        fill_value : scalar, optional
            Filling value. Default is None.
        
        Returns
        -------
        a : ndarray
            The filled array.
        
        See Also
        --------
        compressed
        
        Examples
        --------
        >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
        ...                                                   [1, 0, 0],
        ...                                                   [0, 0, 0]])
        >>> x.filled()
        array([[999999,      1,      2],
               [999999,      4,      5],
               [     6,      7,      8]])
    
    ffiixx__iinnvvaalliidd(a, mask=False, copy=True, fill_value=None)
        Return input with invalid data masked and replaced by a fill value.
        
        Invalid data means values of `nan`, `inf`, etc.
        
        Parameters
        ----------
        a : array_like
            Input array, a (subclass of) ndarray.
        mask : sequence, optional
            Mask. Must be convertible to an array of booleans with the same
            shape as `data`. True indicates a masked (i.e. invalid) data.
        copy : bool, optional
            Whether to use a copy of `a` (True) or to fix `a` in place (False).
            Default is True.
        fill_value : scalar, optional
            Value used for fixing invalid data. Default is None, in which case
            the ``a.fill_value`` is used.
        
        Returns
        -------
        b : MaskedArray
            The input array with invalid entries fixed.
        
        Notes
        -----
        A copy is performed by default.
        
        Examples
        --------
        >>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
        >>> x
        masked_array(data = [-- -1.0 nan inf],
                     mask = [ True False False False],
               fill_value = 1e+20)
        >>> np.ma.fix_invalid(x)
        masked_array(data = [-- -1.0 -- --],
                     mask = [ True False  True  True],
               fill_value = 1e+20)
        
        >>> fixed = np.ma.fix_invalid(x)
        >>> fixed.data
        array([  1.00000000e+00,  -1.00000000e+00,   1.00000000e+20,
                 1.00000000e+20])
        >>> x.data
        array([  1.,  -1.,  NaN,  Inf])
    
    ffllaattnnoottmmaasskkeedd__ccoonnttiigguuoouuss(a)
        Find contiguous unmasked data in a masked array along the given axis.
        
        Parameters
        ----------
        a : narray
            The input array.
        
        Returns
        -------
        slice_list : list
            A sorted sequence of slices (start index, end index).
        
        See Also
        --------
        flatnotmasked_edges, notmasked_contiguous, notmasked_edges,
        clump_masked, clump_unmasked
        
        Notes
        -----
        Only accepts 2-D arrays at most.
        
        Examples
        --------
        >>> a = np.ma.arange(10)
        >>> np.ma.flatnotmasked_contiguous(a)
        slice(0, 10, None)
        
        >>> mask = (a < 3) | (a > 8) | (a == 5)
        >>> a[mask] = np.ma.masked
        >>> np.array(a[~a.mask])
        array([3, 4, 6, 7, 8])
        
        >>> np.ma.flatnotmasked_contiguous(a)
        [slice(3, 5, None), slice(6, 9, None)]
        >>> a[:] = np.ma.masked
        >>> print(np.ma.flatnotmasked_edges(a))
        None
    
    ffllaattnnoottmmaasskkeedd__eeddggeess(a)
        Find the indices of the first and last unmasked values.
        
        Expects a 1-D `MaskedArray`, returns None if all values are masked.
        
        Parameters
        ----------
        a : array_like
            Input 1-D `MaskedArray`
        
        Returns
        -------
        edges : ndarray or None
            The indices of first and last non-masked value in the array.
            Returns None if all values are masked.
        
        See Also
        --------
        flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges,
        clump_masked, clump_unmasked
        
        Notes
        -----
        Only accepts 1-D arrays.
        
        Examples
        --------
        >>> a = np.ma.arange(10)
        >>> flatnotmasked_edges(a)
        [0,-1]
        
        >>> mask = (a < 3) | (a > 8) | (a == 5)
        >>> a[mask] = np.ma.masked
        >>> np.array(a[~a.mask])
        array([3, 4, 6, 7, 8])
        
        >>> flatnotmasked_edges(a)
        array([3, 8])
        
        >>> a[:] = np.ma.masked
        >>> print(flatnotmasked_edges(ma))
        None
    
    ffllaatttteenn__mmaasskk(mask)
        Returns a completely flattened version of the mask, where nested fields
        are collapsed.
        
        Parameters
        ----------
        mask : array_like
            Input array, which will be interpreted as booleans.
        
        Returns
        -------
        flattened_mask : ndarray of bools
            The flattened input.
        
        Examples
        --------
        >>> mask = np.array([0, 0, 1], dtype=np.bool)
        >>> flatten_mask(mask)
        array([False, False,  True], dtype=bool)
        
        >>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
        >>> flatten_mask(mask)
        array([False, False, False,  True], dtype=bool)
        
        >>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
        >>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
        >>> flatten_mask(mask)
        array([False, False, False, False, False,  True], dtype=bool)
    
    ffllaatttteenn__ssttrruuccttuurreedd__aarrrraayy(a)
        Flatten a structured array.
        
        The data type of the output is chosen such that it can represent all of the
        (nested) fields.
        
        Parameters
        ----------
        a : structured array
        
        Returns
        -------
        output : masked array or ndarray
            A flattened masked array if the input is a masked array, otherwise a
            standard ndarray.
        
        Examples
        --------
        >>> ndtype = [('a', int), ('b', float)]
        >>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
        >>> flatten_structured_array(a)
        array([[1., 1.],
               [2., 2.]])
    
    ffrroommfflleexx(fxarray)
        Build a masked array from a suitable flexible-type array.
        
        The input array has to have a data-type with ``_data`` and ``_mask``
        fields. This type of array is output by `MaskedArray.toflex`.
        
        Parameters
        ----------
        fxarray : ndarray
            The structured input array, containing ``_data`` and ``_mask``
            fields. If present, other fields are discarded.
        
        Returns
        -------
        result : MaskedArray
            The constructed masked array.
        
        See Also
        --------
        MaskedArray.toflex : Build a flexible-type array from a masked array.
        
        Examples
        --------
        >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
        >>> rec = x.toflex()
        >>> rec
        array([[(0, False), (1, True), (2, False)],
               [(3, True), (4, False), (5, True)],
               [(6, False), (7, True), (8, False)]],
              dtype=[('_data', '<i4'), ('_mask', '|b1')])
        >>> x2 = np.ma.fromflex(rec)
        >>> x2
        masked_array(data =
         [[0 -- 2]
         [-- 4 --]
         [6 -- 8]],
                     mask =
         [[False  True False]
         [ True False  True]
         [False  True False]],
               fill_value = 999999)
        
        Extra fields can be present in the structured array but are discarded:
        
        >>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
        >>> rec2 = np.zeros((2, 2), dtype=dt)
        >>> rec2
        array([[(0, False, 0.0), (0, False, 0.0)],
               [(0, False, 0.0), (0, False, 0.0)]],
              dtype=[('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')])
        >>> y = np.ma.fromflex(rec2)
        >>> y
        masked_array(data =
         [[0 0]
         [0 0]],
                     mask =
         [[False False]
         [False False]],
               fill_value = 999999)
    
    ggeettddaattaa(a, subok=True)
        Return the data of a masked array as an ndarray.
        
        Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
        else return `a` as a ndarray or subclass (depending on `subok`) if not.
        
        Parameters
        ----------
        a : array_like
            Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
        subok : bool
            Whether to force the output to be a `pure` ndarray (False) or to
            return a subclass of ndarray if appropriate (True, default).
        
        See Also
        --------
        getmask : Return the mask of a masked array, or nomask.
        getmaskarray : Return the mask of a masked array, or full array of False.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.masked_equal([[1,2],[3,4]], 2)
        >>> a
        masked_array(data =
         [[1 --]
         [3 4]],
              mask =
         [[False  True]
         [False False]],
              fill_value=999999)
        >>> ma.getdata(a)
        array([[1, 2],
               [3, 4]])
        
        Equivalently use the ``MaskedArray`` `data` attribute.
        
        >>> a.data
        array([[1, 2],
               [3, 4]])
    
    ggeettmmaasskk(a)
        Return the mask of a masked array, or nomask.
        
        Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
        mask is not `nomask`, else return `nomask`. To guarantee a full array
        of booleans of the same shape as a, use `getmaskarray`.
        
        Parameters
        ----------
        a : array_like
            Input `MaskedArray` for which the mask is required.
        
        See Also
        --------
        getdata : Return the data of a masked array as an ndarray.
        getmaskarray : Return the mask of a masked array, or full array of False.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.masked_equal([[1,2],[3,4]], 2)
        >>> a
        masked_array(data =
         [[1 --]
         [3 4]],
              mask =
         [[False  True]
         [False False]],
              fill_value=999999)
        >>> ma.getmask(a)
        array([[False,  True],
               [False, False]], dtype=bool)
        
        Equivalently use the `MaskedArray` `mask` attribute.
        
        >>> a.mask
        array([[False,  True],
               [False, False]], dtype=bool)
        
        Result when mask == `nomask`
        
        >>> b = ma.masked_array([[1,2],[3,4]])
        >>> b
        masked_array(data =
         [[1 2]
         [3 4]],
              mask =
         False,
              fill_value=999999)
        >>> ma.nomask
        False
        >>> ma.getmask(b) == ma.nomask
        True
        >>> b.mask == ma.nomask
        True
    
    ggeettmmaasskkaarrrraayy(arr)
        Return the mask of a masked array, or full boolean array of False.
        
        Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
        the mask is not `nomask`, else return a full boolean array of False of
        the same shape as `arr`.
        
        Parameters
        ----------
        arr : array_like
            Input `MaskedArray` for which the mask is required.
        
        See Also
        --------
        getmask : Return the mask of a masked array, or nomask.
        getdata : Return the data of a masked array as an ndarray.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.masked_equal([[1,2],[3,4]], 2)
        >>> a
        masked_array(data =
         [[1 --]
         [3 4]],
              mask =
         [[False  True]
         [False False]],
              fill_value=999999)
        >>> ma.getmaskarray(a)
        array([[False,  True],
               [False, False]], dtype=bool)
        
        Result when mask == ``nomask``
        
        >>> b = ma.masked_array([[1,2],[3,4]])
        >>> b
        masked_array(data =
         [[1 2]
         [3 4]],
              mask =
         False,
              fill_value=999999)
        >>> >ma.getmaskarray(b)
        array([[False, False],
               [False, False]], dtype=bool)
    
    iinn11dd(ar1, ar2, assume_unique=False, invert=False)
        Test whether each element of an array is also present in a second
        array.
        
        The output is always a masked array. See `numpy.in1d` for more details.
        
        We recommend using :func:`isin` instead of `in1d` for new code.
        
        See Also
        --------
        isin       : Version of this function that preserves the shape of ar1.
        numpy.in1d : Equivalent function for ndarrays.
        
        Notes
        -----
        .. versionadded:: 1.4.0
    
    iinnddiicceess(dimensions, dtype=<class 'int'>)
        Return an array representing the indices of a grid.
        
        Compute an array where the subarrays contain index values 0,1,...
        varying only along the corresponding axis.
        
        Parameters
        ----------
        dimensions : sequence of ints
            The shape of the grid.
        dtype : dtype, optional
            Data type of the result.
        
        Returns
        -------
        grid : ndarray
            The array of grid indices,
            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
        
        See Also
        --------
        mgrid, meshgrid
        
        Notes
        -----
        The output shape is obtained by prepending the number of dimensions
        in front of the tuple of dimensions, i.e. if `dimensions` is a tuple
        ``(r0, ..., rN-1)`` of length ``N``, the output shape is
        ``(N,r0,...,rN-1)``.
        
        The subarrays ``grid[k]`` contains the N-D array of indices along the
        ``k-th`` axis. Explicitly::
        
            grid[k,i0,i1,...,iN-1] = ik
        
        Examples
        --------
        >>> grid = np.indices((2, 3))
        >>> grid.shape
        (2, 2, 3)
        >>> grid[0]        # row indices
        array([[0, 0, 0],
               [1, 1, 1]])
        >>> grid[1]        # column indices
        array([[0, 1, 2],
               [0, 1, 2]])
        
        The indices can be used as an index into an array.
        
        >>> x = np.arange(20).reshape(5, 4)
        >>> row, col = np.indices((2, 3))
        >>> x[row, col]
        array([[0, 1, 2],
               [4, 5, 6]])
        
        Note that it would be more straightforward in the above example to
        extract the required elements directly with ``x[:2, :3]``.
    
    iinnnneerr(a, b)
        inner(a, b)
        
        Inner product of two arrays.
        
        Ordinary inner product of vectors for 1-D arrays (without complex
        conjugation), in higher dimensions a sum product over the last axes.
        
        Parameters
        ----------
        a, b : array_like
            If `a` and `b` are nonscalar, their last dimensions must match.
        
        Returns
        -------
        out : ndarray
            `out.shape = a.shape[:-1] + b.shape[:-1]`
        
        Raises
        ------
        ValueError
            If the last dimension of `a` and `b` has different size.
        
        See Also
        --------
        tensordot : Sum products over arbitrary axes.
        dot : Generalised matrix product, using second last dimension of `b`.
        einsum : Einstein summation convention.
        
        Notes
        -----
        For vectors (1-D arrays) it computes the ordinary inner-product::
        
            np.inner(a, b) = sum(a[:]*b[:])
        
        More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::
        
            np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
        
        or explicitly::
        
            np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
                 = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])
        
        In addition `a` or `b` may be scalars, in which case::
        
           np.inner(a,b) = a*b
        
        Examples
        --------
        Ordinary inner product for vectors:
        
        >>> a = np.array([1,2,3])
        >>> b = np.array([0,1,0])
        >>> np.inner(a, b)
        2
        
        A multidimensional example:
        
        >>> a = np.arange(24).reshape((2,3,4))
        >>> b = np.arange(4)
        >>> np.inner(a, b)
        array([[ 14,  38,  62],
               [ 86, 110, 134]])
        
        An example where `b` is a scalar:
        
        >>> np.inner(np.eye(2), 7)
        array([[ 7.,  0.],
               [ 0.,  7.]])
        
        Notes
        -----
        Masked values are replaced by 0.
    
    iinnnneerrpprroodduucctt = inner(a, b)
        inner(a, b)
        
        Inner product of two arrays.
        
        Ordinary inner product of vectors for 1-D arrays (without complex
        conjugation), in higher dimensions a sum product over the last axes.
        
        Parameters
        ----------
        a, b : array_like
            If `a` and `b` are nonscalar, their last dimensions must match.
        
        Returns
        -------
        out : ndarray
            `out.shape = a.shape[:-1] + b.shape[:-1]`
        
        Raises
        ------
        ValueError
            If the last dimension of `a` and `b` has different size.
        
        See Also
        --------
        tensordot : Sum products over arbitrary axes.
        dot : Generalised matrix product, using second last dimension of `b`.
        einsum : Einstein summation convention.
        
        Notes
        -----
        For vectors (1-D arrays) it computes the ordinary inner-product::
        
            np.inner(a, b) = sum(a[:]*b[:])
        
        More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::
        
            np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
        
        or explicitly::
        
            np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
                 = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])
        
        In addition `a` or `b` may be scalars, in which case::
        
           np.inner(a,b) = a*b
        
        Examples
        --------
        Ordinary inner product for vectors:
        
        >>> a = np.array([1,2,3])
        >>> b = np.array([0,1,0])
        >>> np.inner(a, b)
        2
        
        A multidimensional example:
        
        >>> a = np.arange(24).reshape((2,3,4))
        >>> b = np.arange(4)
        >>> np.inner(a, b)
        array([[ 14,  38,  62],
               [ 86, 110, 134]])
        
        An example where `b` is a scalar:
        
        >>> np.inner(np.eye(2), 7)
        array([[ 7.,  0.],
               [ 0.,  7.]])
        
        Notes
        -----
        Masked values are replaced by 0.
    
    iinntteerrsseecctt11dd(ar1, ar2, assume_unique=False)
        Returns the unique elements common to both arrays.
        
        Masked values are considered equal one to the other.
        The output is always a masked array.
        
        See `numpy.intersect1d` for more details.
        
        See Also
        --------
        numpy.intersect1d : Equivalent function for ndarrays.
        
        Examples
        --------
        >>> x = array([1, 3, 3, 3], mask=[0, 0, 0, 1])
        >>> y = array([3, 1, 1, 1], mask=[0, 0, 0, 1])
        >>> intersect1d(x, y)
        masked_array(data = [1 3 --],
                     mask = [False False  True],
               fill_value = 999999)
    
    iissMMAA = isMaskedArray(x)
        Test whether input is an instance of MaskedArray.
        
        This function returns True if `x` is an instance of MaskedArray
        and returns False otherwise.  Any object is accepted as input.
        
        Parameters
        ----------
        x : object
            Object to test.
        
        Returns
        -------
        result : bool
            True if `x` is a MaskedArray.
        
        See Also
        --------
        isMA : Alias to isMaskedArray.
        isarray : Alias to isMaskedArray.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.eye(3, 3)
        >>> a
        array([[ 1.,  0.,  0.],
               [ 0.,  1.,  0.],
               [ 0.,  0.,  1.]])
        >>> m = ma.masked_values(a, 0)
        >>> m
        masked_array(data =
         [[1.0 -- --]
         [-- 1.0 --]
         [-- -- 1.0]],
              mask =
         [[False  True  True]
         [ True False  True]
         [ True  True False]],
              fill_value=0.0)
        >>> ma.isMaskedArray(a)
        False
        >>> ma.isMaskedArray(m)
        True
        >>> ma.isMaskedArray([0, 1, 2])
        False
    
    iissMMaasskkeeddAArrrraayy(x)
        Test whether input is an instance of MaskedArray.
        
        This function returns True if `x` is an instance of MaskedArray
        and returns False otherwise.  Any object is accepted as input.
        
        Parameters
        ----------
        x : object
            Object to test.
        
        Returns
        -------
        result : bool
            True if `x` is a MaskedArray.
        
        See Also
        --------
        isMA : Alias to isMaskedArray.
        isarray : Alias to isMaskedArray.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.eye(3, 3)
        >>> a
        array([[ 1.,  0.,  0.],
               [ 0.,  1.,  0.],
               [ 0.,  0.,  1.]])
        >>> m = ma.masked_values(a, 0)
        >>> m
        masked_array(data =
         [[1.0 -- --]
         [-- 1.0 --]
         [-- -- 1.0]],
              mask =
         [[False  True  True]
         [ True False  True]
         [ True  True False]],
              fill_value=0.0)
        >>> ma.isMaskedArray(a)
        False
        >>> ma.isMaskedArray(m)
        True
        >>> ma.isMaskedArray([0, 1, 2])
        False
    
    iiss__mmaasskk(m)
        Return True if m is a valid, standard mask.
        
        This function does not check the contents of the input, only that the
        type is MaskType. In particular, this function returns False if the
        mask has a flexible dtype.
        
        Parameters
        ----------
        m : array_like
            Array to test.
        
        Returns
        -------
        result : bool
            True if `m.dtype.type` is MaskType, False otherwise.
        
        See Also
        --------
        isMaskedArray : Test whether input is an instance of MaskedArray.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
        >>> m
        masked_array(data = [-- 1 -- 2 3],
              mask = [ True False  True False False],
              fill_value=999999)
        >>> ma.is_mask(m)
        False
        >>> ma.is_mask(m.mask)
        True
        
        Input must be an ndarray (or have similar attributes)
        for it to be considered a valid mask.
        
        >>> m = [False, True, False]
        >>> ma.is_mask(m)
        False
        >>> m = np.array([False, True, False])
        >>> m
        array([False,  True, False], dtype=bool)
        >>> ma.is_mask(m)
        True
        
        Arrays with complex dtypes don't return True.
        
        >>> dtype = np.dtype({'names':['monty', 'pithon'],
                              'formats':[np.bool, np.bool]})
        >>> dtype
        dtype([('monty', '|b1'), ('pithon', '|b1')])
        >>> m = np.array([(True, False), (False, True), (True, False)],
                         dtype=dtype)
        >>> m
        array([(True, False), (False, True), (True, False)],
              dtype=[('monty', '|b1'), ('pithon', '|b1')])
        >>> ma.is_mask(m)
        False
    
    iiss__mmaasskkeedd(x)
        Determine whether input has masked values.
        
        Accepts any object as input, but always returns False unless the
        input is a MaskedArray containing masked values.
        
        Parameters
        ----------
        x : array_like
            Array to check for masked values.
        
        Returns
        -------
        result : bool
            True if `x` is a MaskedArray with masked values, False otherwise.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
        >>> x
        masked_array(data = [-- 1 -- 2 3],
              mask = [ True False  True False False],
              fill_value=999999)
        >>> ma.is_masked(x)
        True
        >>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
        >>> x
        masked_array(data = [0 1 0 2 3],
              mask = False,
              fill_value=999999)
        >>> ma.is_masked(x)
        False
        
        Always returns False if `x` isn't a MaskedArray.
        
        >>> x = [False, True, False]
        >>> ma.is_masked(x)
        False
        >>> x = 'a string'
        >>> ma.is_masked(x)
        False
    
    iissaarrrraayy = isMaskedArray(x)
        Test whether input is an instance of MaskedArray.
        
        This function returns True if `x` is an instance of MaskedArray
        and returns False otherwise.  Any object is accepted as input.
        
        Parameters
        ----------
        x : object
            Object to test.
        
        Returns
        -------
        result : bool
            True if `x` is a MaskedArray.
        
        See Also
        --------
        isMA : Alias to isMaskedArray.
        isarray : Alias to isMaskedArray.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.eye(3, 3)
        >>> a
        array([[ 1.,  0.,  0.],
               [ 0.,  1.,  0.],
               [ 0.,  0.,  1.]])
        >>> m = ma.masked_values(a, 0)
        >>> m
        masked_array(data =
         [[1.0 -- --]
         [-- 1.0 --]
         [-- -- 1.0]],
              mask =
         [[False  True  True]
         [ True False  True]
         [ True  True False]],
              fill_value=0.0)
        >>> ma.isMaskedArray(a)
        False
        >>> ma.isMaskedArray(m)
        True
        >>> ma.isMaskedArray([0, 1, 2])
        False
    
    iissiinn(element, test_elements, assume_unique=False, invert=False)
        Calculates `element in test_elements`, broadcasting over
        `element` only.
        
        The output is always a masked array of the same shape as `element`.
        See `numpy.isin` for more details.
        
        See Also
        --------
        in1d       : Flattened version of this function.
        numpy.isin : Equivalent function for ndarrays.
        
        Notes
        -----
        .. versionadded:: 1.13.0
    
    lleefftt__sshhiifftt(a, n)
        Shift the bits of an integer to the left.
        
        This is the masked array version of `numpy.left_shift`, for details
        see that function.
        
        See Also
        --------
        numpy.left_shift
    
    llooaadd(F)
        Wrapper around ``cPickle.load`` which accepts either a file-like object
        or a filename.
        
        Parameters
        ----------
        F : str or file
            The file or file name to load.
        
        See Also
        --------
        dump : Pickle an array
        
        Notes
        -----
        This is different from `numpy.load`, which does not use cPickle but loads
        the NumPy binary .npy format.
    
    llooaaddss(strg)
        Load a pickle from the current string.
        
        The result of ``cPickle.loads(strg)`` is returned.
        
        Parameters
        ----------
        strg : str
            The string to load.
        
        See Also
        --------
        dumps : Return a string corresponding to the pickling of a masked array.
    
    mmaakkee__mmaasskk(m, copy=False, shrink=True, dtype=<class 'numpy.bool_'>)
        Create a boolean mask from an array.
        
        Return `m` as a boolean mask, creating a copy if necessary or requested.
        The function can accept any sequence that is convertible to integers,
        or ``nomask``.  Does not require that contents must be 0s and 1s, values
        of 0 are interepreted as False, everything else as True.
        
        Parameters
        ----------
        m : array_like
            Potential mask.
        copy : bool, optional
            Whether to return a copy of `m` (True) or `m` itself (False).
        shrink : bool, optional
            Whether to shrink `m` to ``nomask`` if all its values are False.
        dtype : dtype, optional
            Data-type of the output mask. By default, the output mask has a
            dtype of MaskType (bool). If the dtype is flexible, each field has
            a boolean dtype. This is ignored when `m` is ``nomask``, in which
            case ``nomask`` is always returned.
        
        Returns
        -------
        result : ndarray
            A boolean mask derived from `m`.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> m = [True, False, True, True]
        >>> ma.make_mask(m)
        array([ True, False,  True,  True], dtype=bool)
        >>> m = [1, 0, 1, 1]
        >>> ma.make_mask(m)
        array([ True, False,  True,  True], dtype=bool)
        >>> m = [1, 0, 2, -3]
        >>> ma.make_mask(m)
        array([ True, False,  True,  True], dtype=bool)
        
        Effect of the `shrink` parameter.
        
        >>> m = np.zeros(4)
        >>> m
        array([ 0.,  0.,  0.,  0.])
        >>> ma.make_mask(m)
        False
        >>> ma.make_mask(m, shrink=False)
        array([False, False, False, False], dtype=bool)
        
        Using a flexible `dtype`.
        
        >>> m = [1, 0, 1, 1]
        >>> n = [0, 1, 0, 0]
        >>> arr = []
        >>> for man, mouse in zip(m, n):
        ...     arr.append((man, mouse))
        >>> arr
        [(1, 0), (0, 1), (1, 0), (1, 0)]
        >>> dtype = np.dtype({'names':['man', 'mouse'],
                              'formats':[np.int, np.int]})
        >>> arr = np.array(arr, dtype=dtype)
        >>> arr
        array([(1, 0), (0, 1), (1, 0), (1, 0)],
              dtype=[('man', '<i4'), ('mouse', '<i4')])
        >>> ma.make_mask(arr, dtype=dtype)
        array([(True, False), (False, True), (True, False), (True, False)],
              dtype=[('man', '|b1'), ('mouse', '|b1')])
    
    mmaakkee__mmaasskk__ddeessccrr(ndtype)
        Construct a dtype description list from a given dtype.
        
        Returns a new dtype object, with the type of all fields in `ndtype` to a
        boolean type. Field names are not altered.
        
        Parameters
        ----------
        ndtype : dtype
            The dtype to convert.
        
        Returns
        -------
        result : dtype
            A dtype that looks like `ndtype`, the type of all fields is boolean.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> dtype = np.dtype({'names':['foo', 'bar'],
                              'formats':[np.float32, np.int]})
        >>> dtype
        dtype([('foo', '<f4'), ('bar', '<i4')])
        >>> ma.make_mask_descr(dtype)
        dtype([('foo', '|b1'), ('bar', '|b1')])
        >>> ma.make_mask_descr(np.float32)
        dtype('bool')
    
    mmaakkee__mmaasskk__nnoonnee(newshape, dtype=None)
        Return a boolean mask of the given shape, filled with False.
        
        This function returns a boolean ndarray with all entries False, that can
        be used in common mask manipulations. If a complex dtype is specified, the
        type of each field is converted to a boolean type.
        
        Parameters
        ----------
        newshape : tuple
            A tuple indicating the shape of the mask.
        dtype : {None, dtype}, optional
            If None, use a MaskType instance. Otherwise, use a new datatype with
            the same fields as `dtype`, converted to boolean types.
        
        Returns
        -------
        result : ndarray
            An ndarray of appropriate shape and dtype, filled with False.
        
        See Also
        --------
        make_mask : Create a boolean mask from an array.
        make_mask_descr : Construct a dtype description list from a given dtype.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> ma.make_mask_none((3,))
        array([False, False, False], dtype=bool)
        
        Defining a more complex dtype.
        
        >>> dtype = np.dtype({'names':['foo', 'bar'],
                              'formats':[np.float32, np.int]})
        >>> dtype
        dtype([('foo', '<f4'), ('bar', '<i4')])
        >>> ma.make_mask_none((3,), dtype=dtype)
        array([(False, False), (False, False), (False, False)],
              dtype=[('foo', '|b1'), ('bar', '|b1')])
    
    mmaasskk__ccoollss(a, axis=None)
        Mask columns of a 2D array that contain masked values.
        
        This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.
        
        See Also
        --------
        mask_rowcols : Mask rows and/or columns of a 2D array.
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.zeros((3, 3), dtype=np.int)
        >>> a[1, 1] = 1
        >>> a
        array([[0, 0, 0],
               [0, 1, 0],
               [0, 0, 0]])
        >>> a = ma.masked_equal(a, 1)
        >>> a
        masked_array(data =
         [[0 0 0]
         [0 -- 0]
         [0 0 0]],
              mask =
         [[False False False]
         [False  True False]
         [False False False]],
              fill_value=999999)
        >>> ma.mask_cols(a)
        masked_array(data =
         [[0 -- 0]
         [0 -- 0]
         [0 -- 0]],
              mask =
         [[False  True False]
         [False  True False]
         [False  True False]],
              fill_value=999999)
    
    mmaasskk__oorr(m1, m2, copy=False, shrink=True)
        Combine two masks with the ``logical_or`` operator.
        
        The result may be a view on `m1` or `m2` if the other is `nomask`
        (i.e. False).
        
        Parameters
        ----------
        m1, m2 : array_like
            Input masks.
        copy : bool, optional
            If copy is False and one of the inputs is `nomask`, return a view
            of the other input mask. Defaults to False.
        shrink : bool, optional
            Whether to shrink the output to `nomask` if all its values are
            False. Defaults to True.
        
        Returns
        -------
        mask : output mask
            The result masks values that are masked in either `m1` or `m2`.
        
        Raises
        ------
        ValueError
            If `m1` and `m2` have different flexible dtypes.
        
        Examples
        --------
        >>> m1 = np.ma.make_mask([0, 1, 1, 0])
        >>> m2 = np.ma.make_mask([1, 0, 0, 0])
        >>> np.ma.mask_or(m1, m2)
        array([ True,  True,  True, False], dtype=bool)
    
    mmaasskk__rroowwccoollss(a, axis=None)
        Mask rows and/or columns of a 2D array that contain masked values.
        
        Mask whole rows and/or columns of a 2D array that contain
        masked values.  The masking behavior is selected using the
        `axis` parameter.
        
          - If `axis` is None, rows *and* columns are masked.
          - If `axis` is 0, only rows are masked.
          - If `axis` is 1 or -1, only columns are masked.
        
        Parameters
        ----------
        a : array_like, MaskedArray
            The array to mask.  If not a MaskedArray instance (or if no array
            elements are masked).  The result is a MaskedArray with `mask` set
            to `nomask` (False). Must be a 2D array.
        axis : int, optional
            Axis along which to perform the operation. If None, applies to a
            flattened version of the array.
        
        Returns
        -------
        a : MaskedArray
            A modified version of the input array, masked depending on the value
            of the `axis` parameter.
        
        Raises
        ------
        NotImplementedError
            If input array `a` is not 2D.
        
        See Also
        --------
        mask_rows : Mask rows of a 2D array that contain masked values.
        mask_cols : Mask cols of a 2D array that contain masked values.
        masked_where : Mask where a condition is met.
        
        Notes
        -----
        The input array's mask is modified by this function.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.zeros((3, 3), dtype=np.int)
        >>> a[1, 1] = 1
        >>> a
        array([[0, 0, 0],
               [0, 1, 0],
               [0, 0, 0]])
        >>> a = ma.masked_equal(a, 1)
        >>> a
        masked_array(data =
         [[0 0 0]
         [0 -- 0]
         [0 0 0]],
              mask =
         [[False False False]
         [False  True False]
         [False False False]],
              fill_value=999999)
        >>> ma.mask_rowcols(a)
        masked_array(data =
         [[0 -- 0]
         [-- -- --]
         [0 -- 0]],
              mask =
         [[False  True False]
         [ True  True  True]
         [False  True False]],
              fill_value=999999)
    
    mmaasskk__rroowwss(a, axis=None)
        Mask rows of a 2D array that contain masked values.
        
        This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.
        
        See Also
        --------
        mask_rowcols : Mask rows and/or columns of a 2D array.
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.zeros((3, 3), dtype=np.int)
        >>> a[1, 1] = 1
        >>> a
        array([[0, 0, 0],
               [0, 1, 0],
               [0, 0, 0]])
        >>> a = ma.masked_equal(a, 1)
        >>> a
        masked_array(data =
         [[0 0 0]
         [0 -- 0]
         [0 0 0]],
              mask =
         [[False False False]
         [False  True False]
         [False False False]],
              fill_value=999999)
        >>> ma.mask_rows(a)
        masked_array(data =
         [[0 0 0]
         [-- -- --]
         [0 0 0]],
              mask =
         [[False False False]
         [ True  True  True]
         [False False False]],
              fill_value=999999)
    
    mmaasskkeedd__aallll(shape, dtype=<class 'float'>)
        Empty masked array with all elements masked.
        
        Return an empty masked array of the given shape and dtype, where all the
        data are masked.
        
        Parameters
        ----------
        shape : tuple
            Shape of the required MaskedArray.
        dtype : dtype, optional
            Data type of the output.
        
        Returns
        -------
        a : MaskedArray
            A masked array with all data masked.
        
        See Also
        --------
        masked_all_like : Empty masked array modelled on an existing array.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> ma.masked_all((3, 3))
        masked_array(data =
         [[-- -- --]
         [-- -- --]
         [-- -- --]],
              mask =
         [[ True  True  True]
         [ True  True  True]
         [ True  True  True]],
              fill_value=1e+20)
        
        The `dtype` parameter defines the underlying data type.
        
        >>> a = ma.masked_all((3, 3))
        >>> a.dtype
        dtype('float64')
        >>> a = ma.masked_all((3, 3), dtype=np.int32)
        >>> a.dtype
        dtype('int32')
    
    mmaasskkeedd__aallll__lliikkee(arr)
        Empty masked array with the properties of an existing array.
        
        Return an empty masked array of the same shape and dtype as
        the array `arr`, where all the data are masked.
        
        Parameters
        ----------
        arr : ndarray
            An array describing the shape and dtype of the required MaskedArray.
        
        Returns
        -------
        a : MaskedArray
            A masked array with all data masked.
        
        Raises
        ------
        AttributeError
            If `arr` doesn't have a shape attribute (i.e. not an ndarray)
        
        See Also
        --------
        masked_all : Empty masked array with all elements masked.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> arr = np.zeros((2, 3), dtype=np.float32)
        >>> arr
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  0.]], dtype=float32)
        >>> ma.masked_all_like(arr)
        masked_array(data =
         [[-- -- --]
         [-- -- --]],
              mask =
         [[ True  True  True]
         [ True  True  True]],
              fill_value=1e+20)
        
        The dtype of the masked array matches the dtype of `arr`.
        
        >>> arr.dtype
        dtype('float32')
        >>> ma.masked_all_like(arr).dtype
        dtype('float32')
    
    mmaasskkeedd__eeqquuaall(x, value, copy=True)
        Mask an array where equal to a given value.
        
        This function is a shortcut to ``masked_where``, with
        `condition` = (x == value).  For floating point arrays,
        consider using ``masked_values(x, value)``.
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        masked_values : Mask using floating point equality.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_equal(a, 2)
        masked_array(data = [0 1 -- 3],
              mask = [False False  True False],
              fill_value=999999)
    
    mmaasskkeedd__ggrreeaatteerr(x, value, copy=True)
        Mask an array where greater than a given value.
        
        This function is a shortcut to ``masked_where``, with
        `condition` = (x > value).
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_greater(a, 2)
        masked_array(data = [0 1 2 --],
              mask = [False False False  True],
              fill_value=999999)
    
    mmaasskkeedd__ggrreeaatteerr__eeqquuaall(x, value, copy=True)
        Mask an array where greater than or equal to a given value.
        
        This function is a shortcut to ``masked_where``, with
        `condition` = (x >= value).
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_greater_equal(a, 2)
        masked_array(data = [0 1 -- --],
              mask = [False False  True  True],
              fill_value=999999)
    
    mmaasskkeedd__iinnssiiddee(x, v1, v2, copy=True)
        Mask an array inside a given interval.
        
        Shortcut to ``masked_where``, where `condition` is True for `x` inside
        the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`
        can be given in either order.
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Notes
        -----
        The array `x` is prefilled with its filling value.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
        >>> ma.masked_inside(x, -0.3, 0.3)
        masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],
              mask = [False False  True  True False False],
              fill_value=1e+20)
        
        The order of `v1` and `v2` doesn't matter.
        
        >>> ma.masked_inside(x, 0.3, -0.3)
        masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],
              mask = [False False  True  True False False],
              fill_value=1e+20)
    
    mmaasskkeedd__iinnvvaalliidd(a, copy=True)
        Mask an array where invalid values occur (NaNs or infs).
        
        This function is a shortcut to ``masked_where``, with
        `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
        Only applies to arrays with a dtype where NaNs or infs make sense
        (i.e. floating point types), but accepts any array_like object.
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(5, dtype=np.float)
        >>> a[2] = np.NaN
        >>> a[3] = np.PINF
        >>> a
        array([  0.,   1.,  NaN,  Inf,   4.])
        >>> ma.masked_invalid(a)
        masked_array(data = [0.0 1.0 -- -- 4.0],
              mask = [False False  True  True False],
              fill_value=1e+20)
    
    mmaasskkeedd__lleessss(x, value, copy=True)
        Mask an array where less than a given value.
        
        This function is a shortcut to ``masked_where``, with
        `condition` = (x < value).
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_less(a, 2)
        masked_array(data = [-- -- 2 3],
              mask = [ True  True False False],
              fill_value=999999)
    
    mmaasskkeedd__lleessss__eeqquuaall(x, value, copy=True)
        Mask an array where less than or equal to a given value.
        
        This function is a shortcut to ``masked_where``, with
        `condition` = (x <= value).
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_less_equal(a, 2)
        masked_array(data = [-- -- -- 3],
              mask = [ True  True  True False],
              fill_value=999999)
    
    mmaasskkeedd__nnoott__eeqquuaall(x, value, copy=True)
        Mask an array where `not` equal to a given value.
        
        This function is a shortcut to ``masked_where``, with
        `condition` = (x != value).
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_not_equal(a, 2)
        masked_array(data = [-- -- 2 --],
              mask = [ True  True False  True],
              fill_value=999999)
    
    mmaasskkeedd__oobbjjeecctt(x, value, copy=True, shrink=True)
        Mask the array `x` where the data are exactly equal to value.
        
        This function is similar to `masked_values`, but only suitable
        for object arrays: for floating point, use `masked_values` instead.
        
        Parameters
        ----------
        x : array_like
            Array to mask
        value : object
            Comparison value
        copy : {True, False}, optional
            Whether to return a copy of `x`.
        shrink : {True, False}, optional
            Whether to collapse a mask full of False to nomask
        
        Returns
        -------
        result : MaskedArray
            The result of masking `x` where equal to `value`.
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        masked_equal : Mask where equal to a given value (integers).
        masked_values : Mask using floating point equality.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> food = np.array(['green_eggs', 'ham'], dtype=object)
        >>> # don't eat spoiled food
        >>> eat = ma.masked_object(food, 'green_eggs')
        >>> print(eat)
        [-- ham]
        >>> # plain ol` ham is boring
        >>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
        >>> eat = ma.masked_object(fresh_food, 'green_eggs')
        >>> print(eat)
        [cheese ham pineapple]
        
        Note that `mask` is set to ``nomask`` if possible.
        
        >>> eat
        masked_array(data = [cheese ham pineapple],
              mask = False,
              fill_value=?)
    
    mmaasskkeedd__oouuttssiiddee(x, v1, v2, copy=True)
        Mask an array outside a given interval.
        
        Shortcut to ``masked_where``, where `condition` is True for `x` outside
        the interval [v1,v2] (x < v1)|(x > v2).
        The boundaries `v1` and `v2` can be given in either order.
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        
        Notes
        -----
        The array `x` is prefilled with its filling value.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
        >>> ma.masked_outside(x, -0.3, 0.3)
        masked_array(data = [-- -- 0.01 0.2 -- --],
              mask = [ True  True False False  True  True],
              fill_value=1e+20)
        
        The order of `v1` and `v2` doesn't matter.
        
        >>> ma.masked_outside(x, 0.3, -0.3)
        masked_array(data = [-- -- 0.01 0.2 -- --],
              mask = [ True  True False False  True  True],
              fill_value=1e+20)
    
    mmaasskkeedd__vvaalluueess(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)
        Mask using floating point equality.
        
        Return a MaskedArray, masked where the data in array `x` are approximately
        equal to `value`, i.e. where the following condition is True
        
        (abs(x - value) <= atol+rtol*abs(value))
        
        The fill_value is set to `value` and the mask is set to ``nomask`` if
        possible.  For integers, consider using ``masked_equal``.
        
        Parameters
        ----------
        x : array_like
            Array to mask.
        value : float
            Masking value.
        rtol : float, optional
            Tolerance parameter.
        atol : float, optional
            Tolerance parameter (1e-8).
        copy : bool, optional
            Whether to return a copy of `x`.
        shrink : bool, optional
            Whether to collapse a mask full of False to ``nomask``.
        
        Returns
        -------
        result : MaskedArray
            The result of masking `x` where approximately equal to `value`.
        
        See Also
        --------
        masked_where : Mask where a condition is met.
        masked_equal : Mask where equal to a given value (integers).
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = np.array([1, 1.1, 2, 1.1, 3])
        >>> ma.masked_values(x, 1.1)
        masked_array(data = [1.0 -- 2.0 -- 3.0],
              mask = [False  True False  True False],
              fill_value=1.1)
        
        Note that `mask` is set to ``nomask`` if possible.
        
        >>> ma.masked_values(x, 1.5)
        masked_array(data = [ 1.   1.1  2.   1.1  3. ],
              mask = False,
              fill_value=1.5)
        
        For integers, the fill value will be different in general to the
        result of ``masked_equal``.
        
        >>> x = np.arange(5)
        >>> x
        array([0, 1, 2, 3, 4])
        >>> ma.masked_values(x, 2)
        masked_array(data = [0 1 -- 3 4],
              mask = [False False  True False False],
              fill_value=2)
        >>> ma.masked_equal(x, 2)
        masked_array(data = [0 1 -- 3 4],
              mask = [False False  True False False],
              fill_value=999999)
    
    mmaasskkeedd__wwhheerree(condition, a, copy=True)
        Mask an array where a condition is met.
        
        Return `a` as an array masked where `condition` is True.
        Any masked values of `a` or `condition` are also masked in the output.
        
        Parameters
        ----------
        condition : array_like
            Masking condition.  When `condition` tests floating point values for
            equality, consider using ``masked_values`` instead.
        a : array_like
            Array to mask.
        copy : bool
            If True (default) make a copy of `a` in the result.  If False modify
            `a` in place and return a view.
        
        Returns
        -------
        result : MaskedArray
            The result of masking `a` where `condition` is True.
        
        See Also
        --------
        masked_values : Mask using floating point equality.
        masked_equal : Mask where equal to a given value.
        masked_not_equal : Mask where `not` equal to a given value.
        masked_less_equal : Mask where less than or equal to a given value.
        masked_greater_equal : Mask where greater than or equal to a given value.
        masked_less : Mask where less than a given value.
        masked_greater : Mask where greater than a given value.
        masked_inside : Mask inside a given interval.
        masked_outside : Mask outside a given interval.
        masked_invalid : Mask invalid values (NaNs or infs).
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(4)
        >>> a
        array([0, 1, 2, 3])
        >>> ma.masked_where(a <= 2, a)
        masked_array(data = [-- -- -- 3],
              mask = [ True  True  True False],
              fill_value=999999)
        
        Mask array `b` conditional on `a`.
        
        >>> b = ['a', 'b', 'c', 'd']
        >>> ma.masked_where(a == 2, b)
        masked_array(data = [a b -- d],
              mask = [False False  True False],
              fill_value=N/A)
        
        Effect of the `copy` argument.
        
        >>> c = ma.masked_where(a <= 2, a)
        >>> c
        masked_array(data = [-- -- -- 3],
              mask = [ True  True  True False],
              fill_value=999999)
        >>> c[0] = 99
        >>> c
        masked_array(data = [99 -- -- 3],
              mask = [False  True  True False],
              fill_value=999999)
        >>> a
        array([0, 1, 2, 3])
        >>> c = ma.masked_where(a <= 2, a, copy=False)
        >>> c[0] = 99
        >>> c
        masked_array(data = [99 -- -- 3],
              mask = [False  True  True False],
              fill_value=999999)
        >>> a
        array([99,  1,  2,  3])
        
        When `condition` or `a` contain masked values.
        
        >>> a = np.arange(4)
        >>> a = ma.masked_where(a == 2, a)
        >>> a
        masked_array(data = [0 1 -- 3],
              mask = [False False  True False],
              fill_value=999999)
        >>> b = np.arange(4)
        >>> b = ma.masked_where(b == 0, b)
        >>> b
        masked_array(data = [-- 1 2 3],
              mask = [ True False False False],
              fill_value=999999)
        >>> ma.masked_where(a == 3, b)
        masked_array(data = [-- 1 -- --],
              mask = [ True False  True  True],
              fill_value=999999)
    
    mmaaxx(obj, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
        Return the maximum along a given axis.
        
        Parameters
        ----------
        axis : {None, int}, optional
            Axis along which to operate.  By default, ``axis`` is None and the
            flattened input is used.
        out : array_like, optional
            Alternative output array in which to place the result.  Must
            be of the same shape and buffer length as the expected output.
        fill_value : {var}, optional
            Value used to fill in the masked values.
            If None, use the output of maximum_fill_value().
        
        Returns
        -------
        amax : array_like
            New array holding the result.
            If ``out`` was specified, ``out`` is returned.
        
        See Also
        --------
        maximum_fill_value
            Returns the maximum filling value for a given datatype.
    
    mmaaxxiimmuumm__ffiillll__vvaalluuee(obj)
        Return the minimum value that can be represented by the dtype of an object.
        
        This function is useful for calculating a fill value suitable for
        taking the maximum of an array with a given dtype.
        
        Parameters
        ----------
        obj : {ndarray, dtype}
            An object that can be queried for it's numeric type.
        
        Returns
        -------
        val : scalar
            The minimum representable value.
        
        Raises
        ------
        TypeError
            If `obj` isn't a suitable numeric type.
        
        See Also
        --------
        minimum_fill_value : The inverse function.
        set_fill_value : Set the filling value of a masked array.
        MaskedArray.fill_value : Return current fill value.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.int8()
        >>> ma.maximum_fill_value(a)
        -128
        >>> a = np.int32()
        >>> ma.maximum_fill_value(a)
        -2147483648
        
        An array of numeric data can also be passed.
        
        >>> a = np.array([1, 2, 3], dtype=np.int8)
        >>> ma.maximum_fill_value(a)
        -128
        >>> a = np.array([1, 2, 3], dtype=np.float32)
        >>> ma.maximum_fill_value(a)
        -inf
    
    mmeeddiiaann(a, axis=None, out=None, overwrite_input=False, keepdims=False)
        Compute the median along the specified axis.
        
        Returns the median of the array elements.
        
        Parameters
        ----------
        a : array_like
            Input array or object that can be converted to an array.
        axis : int, optional
            Axis along which the medians are computed. The default (None) is
            to compute the median along a flattened version of the array.
        out : ndarray, optional
            Alternative output array in which to place the result. It must
            have the same shape and buffer length as the expected output
            but the type will be cast if necessary.
        overwrite_input : bool, optional
            If True, then allow use of memory of input array (a) for
            calculations. The input array will be modified by the call to
            median. This will save memory when you do not need to preserve
            the contents of the input array. Treat the input as undefined,
            but it will probably be fully or partially sorted. Default is
            False. Note that, if `overwrite_input` is True, and the input
            is not already an `ndarray`, an error will be raised.
        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left
            in the result as dimensions with size one. With this option,
            the result will broadcast correctly against the input array.
        
            .. versionadded:: 1.10.0
        
        Returns
        -------
        median : ndarray
            A new array holding the result is returned unless out is
            specified, in which case a reference to out is returned.
            Return data-type is `float64` for integers and floats smaller than
            `float64`, or the input data-type, otherwise.
        
        See Also
        --------
        mean
        
        Notes
        -----
        Given a vector ``V`` with ``N`` non masked values, the median of ``V``
        is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
        ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
        when ``N`` is even.
        
        Examples
        --------
        >>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
        >>> np.ma.median(x)
        1.5
        
        >>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
        >>> np.ma.median(x)
        2.5
        >>> np.ma.median(x, axis=-1, overwrite_input=True)
        masked_array(data = [ 2.  5.],
                     mask = False,
               fill_value = 1e+20)
    
    mmiinn(obj, axis=None, out=None, fill_value=None, keepdims=<class 'numpy._globals._NoValue'>)
        Return the minimum along a given axis.
        
        Parameters
        ----------
        axis : {None, int}, optional
            Axis along which to operate.  By default, ``axis`` is None and the
            flattened input is used.
        out : array_like, optional
            Alternative output array in which to place the result.  Must be of
            the same shape and buffer length as the expected output.
        fill_value : {var}, optional
            Value used to fill in the masked values.
            If None, use the output of `minimum_fill_value`.
        
        Returns
        -------
        amin : array_like
            New array holding the result.
            If ``out`` was specified, ``out`` is returned.
        
        See Also
        --------
        minimum_fill_value
            Returns the minimum filling value for a given datatype.
    
    mmiinniimmuumm__ffiillll__vvaalluuee(obj)
        Return the maximum value that can be represented by the dtype of an object.
        
        This function is useful for calculating a fill value suitable for
        taking the minimum of an array with a given dtype.
        
        Parameters
        ----------
        obj : ndarray or dtype
            An object that can be queried for it's numeric type.
        
        Returns
        -------
        val : scalar
            The maximum representable value.
        
        Raises
        ------
        TypeError
            If `obj` isn't a suitable numeric type.
        
        See Also
        --------
        maximum_fill_value : The inverse function.
        set_fill_value : Set the filling value of a masked array.
        MaskedArray.fill_value : Return current fill value.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.int8()
        >>> ma.minimum_fill_value(a)
        127
        >>> a = np.int32()
        >>> ma.minimum_fill_value(a)
        2147483647
        
        An array of numeric data can also be passed.
        
        >>> a = np.array([1, 2, 3], dtype=np.int8)
        >>> ma.minimum_fill_value(a)
        127
        >>> a = np.array([1, 2, 3], dtype=np.float32)
        >>> ma.minimum_fill_value(a)
        inf
    
    nnddiimm(obj)
        Return the number of dimensions of an array.
        
        Parameters
        ----------
        a : array_like
            Input array.  If it is not already an ndarray, a conversion is
            attempted.
        
        Returns
        -------
        number_of_dimensions : int
            The number of dimensions in `a`.  Scalars are zero-dimensional.
        
        See Also
        --------
        ndarray.ndim : equivalent method
        shape : dimensions of array
        ndarray.shape : dimensions of array
        
        Examples
        --------
        >>> np.ndim([[1,2,3],[4,5,6]])
        2
        >>> np.ndim(np.array([[1,2,3],[4,5,6]]))
        2
        >>> np.ndim(1)
        0
    
    nnoottmmaasskkeedd__ccoonnttiigguuoouuss(a, axis=None)
        Find contiguous unmasked data in a masked array along the given axis.
        
        Parameters
        ----------
        a : array_like
            The input array.
        axis : int, optional
            Axis along which to perform the operation.
            If None (default), applies to a flattened version of the array.
        
        Returns
        -------
        endpoints : list
            A list of slices (start and end indexes) of unmasked indexes
            in the array.
        
        See Also
        --------
        flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
        clump_masked, clump_unmasked
        
        Notes
        -----
        Only accepts 2-D arrays at most.
        
        Examples
        --------
        >>> a = np.arange(9).reshape((3, 3))
        >>> mask = np.zeros_like(a)
        >>> mask[1:, 1:] = 1
        
        >>> ma = np.ma.array(a, mask=mask)
        >>> np.array(ma[~ma.mask])
        array([0, 1, 2, 3, 6])
        
        >>> np.ma.notmasked_contiguous(ma)
        [slice(0, 4, None), slice(6, 7, None)]
    
    nnoottmmaasskkeedd__eeddggeess(a, axis=None)
        Find the indices of the first and last unmasked values along an axis.
        
        If all values are masked, return None.  Otherwise, return a list
        of two tuples, corresponding to the indices of the first and last
        unmasked values respectively.
        
        Parameters
        ----------
        a : array_like
            The input array.
        axis : int, optional
            Axis along which to perform the operation.
            If None (default), applies to a flattened version of the array.
        
        Returns
        -------
        edges : ndarray or list
            An array of start and end indexes if there are any masked data in
            the array. If there are no masked data in the array, `edges` is a
            list of the first and last index.
        
        See Also
        --------
        flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous,
        clump_masked, clump_unmasked
        
        Examples
        --------
        >>> a = np.arange(9).reshape((3, 3))
        >>> m = np.zeros_like(a)
        >>> m[1:, 1:] = 1
        
        >>> am = np.ma.array(a, mask=m)
        >>> np.array(am[~am.mask])
        array([0, 1, 2, 3, 6])
        
        >>> np.ma.notmasked_edges(ma)
        array([0, 6])
    
    oouutteerr(a, b)
        Compute the outer product of two vectors.
        
        Given two vectors, ``a = [a0, a1, ..., aM]`` and
        ``b = [b0, b1, ..., bN]``,
        the outer product [1]_ is::
        
          [[a0*b0  a0*b1 ... a0*bN ]
           [a1*b0    .
           [ ...          .
           [aM*b0            aM*bN ]]
        
        Parameters
        ----------
        a : (M,) array_like
            First input vector.  Input is flattened if
            not already 1-dimensional.
        b : (N,) array_like
            Second input vector.  Input is flattened if
            not already 1-dimensional.
        out : (M, N) ndarray, optional
            A location where the result is stored
        
            .. versionadded:: 1.9.0
        
        Returns
        -------
        out : (M, N) ndarray
            ``out[i, j] = a[i] * b[j]``
        
        See also
        --------
        inner, einsum
        
        References
        ----------
        .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd
                 ed., Baltimore, MD, Johns Hopkins University Press, 1996,
                 pg. 8.
        
        Examples
        --------
        Make a (*very* coarse) grid for computing a Mandelbrot set:
        
        >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
        >>> rl
        array([[-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.]])
        >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
        >>> im
        array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
               [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
               [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
               [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
               [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
        >>> grid = rl + im
        >>> grid
        array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
               [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
               [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
               [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
               [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
        
        An example using a "vector" of letters:
        
        >>> x = np.array(['a', 'b', 'c'], dtype=object)
        >>> np.outer(x, [1, 2, 3])
        array([[a, aa, aaa],
               [b, bb, bbb],
               [c, cc, ccc]], dtype=object)
        
        
        
        Notes
        -----
        Masked values are replaced by 0.
    
    oouutteerrpprroodduucctt = outer(a, b)
        Compute the outer product of two vectors.
        
        Given two vectors, ``a = [a0, a1, ..., aM]`` and
        ``b = [b0, b1, ..., bN]``,
        the outer product [1]_ is::
        
          [[a0*b0  a0*b1 ... a0*bN ]
           [a1*b0    .
           [ ...          .
           [aM*b0            aM*bN ]]
        
        Parameters
        ----------
        a : (M,) array_like
            First input vector.  Input is flattened if
            not already 1-dimensional.
        b : (N,) array_like
            Second input vector.  Input is flattened if
            not already 1-dimensional.
        out : (M, N) ndarray, optional
            A location where the result is stored
        
            .. versionadded:: 1.9.0
        
        Returns
        -------
        out : (M, N) ndarray
            ``out[i, j] = a[i] * b[j]``
        
        See also
        --------
        inner, einsum
        
        References
        ----------
        .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd
                 ed., Baltimore, MD, Johns Hopkins University Press, 1996,
                 pg. 8.
        
        Examples
        --------
        Make a (*very* coarse) grid for computing a Mandelbrot set:
        
        >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
        >>> rl
        array([[-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.],
               [-2., -1.,  0.,  1.,  2.]])
        >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
        >>> im
        array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
               [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
               [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
               [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
               [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
        >>> grid = rl + im
        >>> grid
        array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
               [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
               [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
               [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
               [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
        
        An example using a "vector" of letters:
        
        >>> x = np.array(['a', 'b', 'c'], dtype=object)
        >>> np.outer(x, [1, 2, 3])
        array([[a, aa, aaa],
               [b, bb, bbb],
               [c, cc, ccc]], dtype=object)
        
        
        
        Notes
        -----
        Masked values are replaced by 0.
    
    ppoollyyffiitt(x, y, deg, rcond=None, full=False, w=None, cov=False)
        Least squares polynomial fit.
        
        Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
        to points `(x, y)`. Returns a vector of coefficients `p` that minimises
        the squared error.
        
        Parameters
        ----------
        x : array_like, shape (M,)
            x-coordinates of the M sample points ``(x[i], y[i])``.
        y : array_like, shape (M,) or (M, K)
            y-coordinates of the sample points. Several data sets of sample
            points sharing the same x-coordinates can be fitted at once by
            passing in a 2D-array that contains one dataset per column.
        deg : int
            Degree of the fitting polynomial
        rcond : float, optional
            Relative condition number of the fit. Singular values smaller than
            this relative to the largest singular value will be ignored. The
            default value is len(x)*eps, where eps is the relative precision of
            the float type, about 2e-16 in most cases.
        full : bool, optional
            Switch determining nature of return value. When it is False (the
            default) just the coefficients are returned, when True diagnostic
            information from the singular value decomposition is also returned.
        w : array_like, shape (M,), optional
            Weights to apply to the y-coordinates of the sample points. For
            gaussian uncertainties, use 1/sigma (not 1/sigma**2).
        cov : bool, optional
            Return the estimate and the covariance matrix of the estimate
            If full is True, then cov is not returned.
        
        Returns
        -------
        p : ndarray, shape (deg + 1,) or (deg + 1, K)
            Polynomial coefficients, highest power first.  If `y` was 2-D, the
            coefficients for `k`-th data set are in ``p[:,k]``.
        
        residuals, rank, singular_values, rcond
            Present only if `full` = True.  Residuals of the least-squares fit,
            the effective rank of the scaled Vandermonde coefficient matrix,
            its singular values, and the specified value of `rcond`. For more
            details, see `linalg.lstsq`.
        
        V : ndarray, shape (M,M) or (M,M,K)
            Present only if `full` = False and `cov`=True.  The covariance
            matrix of the polynomial coefficient estimates.  The diagonal of
            this matrix are the variance estimates for each coefficient.  If y
            is a 2-D array, then the covariance matrix for the `k`-th data set
            are in ``V[:,:,k]``
        
        
        Warns
        -----
        RankWarning
            The rank of the coefficient matrix in the least-squares fit is
            deficient. The warning is only raised if `full` = False.
        
            The warnings can be turned off by
        
            >>> import warnings
            >>> warnings.simplefilter('ignore', np.RankWarning)
        
        See Also
        --------
        polyval : Compute polynomial values.
        linalg.lstsq : Computes a least-squares fit.
        scipy.interpolate.UnivariateSpline : Computes spline fits.
        
        Notes
        -----
        The solution minimizes the squared error
        
        .. math ::
            E = \sum_{j=0}^k |p(x_j) - y_j|^2
        
        in the equations::
        
            x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
            x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
            ...
            x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]
        
        The coefficient matrix of the coefficients `p` is a Vandermonde matrix.
        
        `polyfit` issues a `RankWarning` when the least-squares fit is badly
        conditioned. This implies that the best fit is not well-defined due
        to numerical error. The results may be improved by lowering the polynomial
        degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
        can also be set to a value smaller than its default, but the resulting
        fit may be spurious: including contributions from the small singular
        values can add numerical noise to the result.
        
        Note that fitting polynomial coefficients is inherently badly conditioned
        when the degree of the polynomial is large or the interval of sample points
        is badly centered. The quality of the fit should always be checked in these
        cases. When polynomial fits are not satisfactory, splines may be a good
        alternative.
        
        References
        ----------
        .. [1] Wikipedia, "Curve fitting",
               http://en.wikipedia.org/wiki/Curve_fitting
        .. [2] Wikipedia, "Polynomial interpolation",
               http://en.wikipedia.org/wiki/Polynomial_interpolation
        
        Examples
        --------
        >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
        >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
        >>> z = np.polyfit(x, y, 3)
        >>> z
        array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])
        
        It is convenient to use `poly1d` objects for dealing with polynomials:
        
        >>> p = np.poly1d(z)
        >>> p(0.5)
        0.6143849206349179
        >>> p(3.5)
        -0.34732142857143039
        >>> p(10)
        22.579365079365115
        
        High-order polynomials may oscillate wildly:
        
        >>> p30 = np.poly1d(np.polyfit(x, y, 30))
        /... RankWarning: Polyfit may be poorly conditioned...
        >>> p30(4)
        -0.80000000000000204
        >>> p30(5)
        -0.99999999999999445
        >>> p30(4.5)
        -0.10547061179440398
        
        Illustration:
        
        >>> import matplotlib.pyplot as plt
        >>> xp = np.linspace(-2, 6, 100)
        >>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
        >>> plt.ylim(-2,2)
        (-2, 2)
        >>> plt.show()
        
        
        
        Notes
        -----
        
        Any masked values in x is propagated in y, and vice-versa.
    
    ppoowweerr(a, b, third=None)
        Returns element-wise base array raised to power from second array.
        
        This is the masked array version of `numpy.power`. For details see
        `numpy.power`.
        
        See Also
        --------
        numpy.power
        
        Notes
        -----
        The *out* argument to `numpy.power` is not supported, `third` has to be
        None.
    
    ppttpp(obj, axis=None, out=None, fill_value=None)
        Return (maximum - minimum) along the given dimension
        (i.e. peak-to-peak value).
        
        Parameters
        ----------
        axis : {None, int}, optional
            Axis along which to find the peaks.  If None (default) the
            flattened array is used.
        out : {None, array_like}, optional
            Alternative output array in which to place the result. It must
            have the same shape and buffer length as the expected output
            but the type will be cast if necessary.
        fill_value : {var}, optional
            Value used to fill in the masked values.
        
        Returns
        -------
        ptp : ndarray.
            A new array holding the result, unless ``out`` was
            specified, in which case a reference to ``out`` is returned.
    
    ppuutt(a, indices, values, mode='raise')
        Set storage-indexed locations to corresponding values.
        
        This function is equivalent to `MaskedArray.put`, see that method
        for details.
        
        See Also
        --------
        MaskedArray.put
    
    ppuuttmmaasskk(a, mask, values)
        Changes elements of an array based on conditional and input values.
        
        This is the masked array version of `numpy.putmask`, for details see
        `numpy.putmask`.
        
        See Also
        --------
        numpy.putmask
        
        Notes
        -----
        Using a masked array as `values` will **not** transform a `ndarray` into
        a `MaskedArray`.
    
    rraannkk(obj)
        Return the number of dimensions of an array.
        
        If `a` is not already an array, a conversion is attempted.
        Scalars are zero dimensional.
        
        .. note::
            This function is deprecated in NumPy 1.9 to avoid confusion with
            `numpy.linalg.matrix_rank`. The ``ndim`` attribute or function
            should be used instead.
        
        Parameters
        ----------
        a : array_like
            Array whose number of dimensions is desired. If `a` is not an array,
            a conversion is attempted.
        
        Returns
        -------
        number_of_dimensions : int
            The number of dimensions in the array.
        
        See Also
        --------
        ndim : equivalent function
        ndarray.ndim : equivalent property
        shape : dimensions of array
        ndarray.shape : dimensions of array
        
        Notes
        -----
        In the old Numeric package, `rank` was the term used for the number of
        dimensions, but in NumPy `ndim` is used instead.
        
        Examples
        --------
        >>> np.rank([1,2,3])
        1
        >>> np.rank(np.array([[1,2,3],[4,5,6]]))
        2
        >>> np.rank(1)
        0
    
    rreesshhaappee(a, new_shape, order='C')
        Returns an array containing the same data with a new shape.
        
        Refer to `MaskedArray.reshape` for full documentation.
        
        See Also
        --------
        MaskedArray.reshape : equivalent function
    
    rreessiizzee(x, new_shape)
        Return a new masked array with the specified size and shape.
        
        This is the masked equivalent of the `numpy.resize` function. The new
        array is filled with repeated copies of `x` (in the order that the
        data are stored in memory). If `x` is masked, the new array will be
        masked, and the new mask will be a repetition of the old one.
        
        See Also
        --------
        numpy.resize : Equivalent function in the top level NumPy module.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.array([[1, 2] ,[3, 4]])
        >>> a[0, 1] = ma.masked
        >>> a
        masked_array(data =
         [[1 --]
         [3 4]],
                     mask =
         [[False  True]
         [False False]],
               fill_value = 999999)
        >>> np.resize(a, (3, 3))
        array([[1, 2, 3],
               [4, 1, 2],
               [3, 4, 1]])
        >>> ma.resize(a, (3, 3))
        masked_array(data =
         [[1 -- 3]
         [4 1 --]
         [3 4 1]],
                     mask =
         [[False  True False]
         [False False  True]
         [False False False]],
               fill_value = 999999)
        
        A MaskedArray is always returned, regardless of the input type.
        
        >>> a = np.array([[1, 2] ,[3, 4]])
        >>> ma.resize(a, (3, 3))
        masked_array(data =
         [[1 2 3]
         [4 1 2]
         [3 4 1]],
                     mask =
         False,
               fill_value = 999999)
    
    rriigghhtt__sshhiifftt(a, n)
        Shift the bits of an integer to the right.
        
        This is the masked array version of `numpy.right_shift`, for details
        see that function.
        
        See Also
        --------
        numpy.right_shift
    
    rroouunndd = round_(a, decimals=0, out=None)
        Return a copy of a, rounded to 'decimals' places.
        
        When 'decimals' is negative, it specifies the number of positions
        to the left of the decimal point.  The real and imaginary parts of
        complex numbers are rounded separately. Nothing is done if the
        array is not of float type and 'decimals' is greater than or equal
        to 0.
        
        Parameters
        ----------
        decimals : int
            Number of decimals to round to. May be negative.
        out : array_like
            Existing array to use for output.
            If not given, returns a default copy of a.
        
        Notes
        -----
        If out is given and does not have a mask attribute, the mask of a
        is lost!
    
    rroouunndd__(a, decimals=0, out=None)
        Return a copy of a, rounded to 'decimals' places.
        
        When 'decimals' is negative, it specifies the number of positions
        to the left of the decimal point.  The real and imaginary parts of
        complex numbers are rounded separately. Nothing is done if the
        array is not of float type and 'decimals' is greater than or equal
        to 0.
        
        Parameters
        ----------
        decimals : int
            Number of decimals to round to. May be negative.
        out : array_like
            Existing array to use for output.
            If not given, returns a default copy of a.
        
        Notes
        -----
        If out is given and does not have a mask attribute, the mask of a
        is lost!
    
    sseett__ffiillll__vvaalluuee(a, fill_value)
        Set the filling value of a, if a is a masked array.
        
        This function changes the fill value of the masked array `a` in place.
        If `a` is not a masked array, the function returns silently, without
        doing anything.
        
        Parameters
        ----------
        a : array_like
            Input array.
        fill_value : dtype
            Filling value. A consistency test is performed to make sure
            the value is compatible with the dtype of `a`.
        
        Returns
        -------
        None
            Nothing returned by this function.
        
        See Also
        --------
        maximum_fill_value : Return the default fill value for a dtype.
        MaskedArray.fill_value : Return current fill value.
        MaskedArray.set_fill_value : Equivalent method.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = np.arange(5)
        >>> a
        array([0, 1, 2, 3, 4])
        >>> a = ma.masked_where(a < 3, a)
        >>> a
        masked_array(data = [-- -- -- 3 4],
              mask = [ True  True  True False False],
              fill_value=999999)
        >>> ma.set_fill_value(a, -999)
        >>> a
        masked_array(data = [-- -- -- 3 4],
              mask = [ True  True  True False False],
              fill_value=-999)
        
        Nothing happens if `a` is not a masked array.
        
        >>> a = range(5)
        >>> a
        [0, 1, 2, 3, 4]
        >>> ma.set_fill_value(a, 100)
        >>> a
        [0, 1, 2, 3, 4]
        >>> a = np.arange(5)
        >>> a
        array([0, 1, 2, 3, 4])
        >>> ma.set_fill_value(a, 100)
        >>> a
        array([0, 1, 2, 3, 4])
    
    sseettddiiffff11dd(ar1, ar2, assume_unique=False)
        Set difference of 1D arrays with unique elements.
        
        The output is always a masked array. See `numpy.setdiff1d` for more
        details.
        
        See Also
        --------
        numpy.setdiff1d : Equivalent function for ndarrays.
        
        Examples
        --------
        >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
        >>> np.ma.setdiff1d(x, [1, 2])
        masked_array(data = [3 --],
                     mask = [False  True],
               fill_value = 999999)
    
    sseettxxoorr11dd(ar1, ar2, assume_unique=False)
        Set exclusive-or of 1-D arrays with unique elements.
        
        The output is always a masked array. See `numpy.setxor1d` for more details.
        
        See Also
        --------
        numpy.setxor1d : Equivalent function for ndarrays.
    
    sshhaappee(obj)
        Return the shape of an array.
        
        Parameters
        ----------
        a : array_like
            Input array.
        
        Returns
        -------
        shape : tuple of ints
            The elements of the shape tuple give the lengths of the
            corresponding array dimensions.
        
        See Also
        --------
        alen
        ndarray.shape : Equivalent array method.
        
        Examples
        --------
        >>> np.shape(np.eye(3))
        (3, 3)
        >>> np.shape([[1, 2]])
        (1, 2)
        >>> np.shape([0])
        (1,)
        >>> np.shape(0)
        ()
        
        >>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
        >>> np.shape(a)
        (2,)
        >>> a.shape
        (2,)
    
    ssiizzee(obj, axis=None)
        Return the number of elements along a given axis.
        
        Parameters
        ----------
        a : array_like
            Input data.
        axis : int, optional
            Axis along which the elements are counted.  By default, give
            the total number of elements.
        
        Returns
        -------
        element_count : int
            Number of elements along the specified axis.
        
        See Also
        --------
        shape : dimensions of array
        ndarray.shape : dimensions of array
        ndarray.size : number of elements in array
        
        Examples
        --------
        >>> a = np.array([[1,2,3],[4,5,6]])
        >>> np.size(a)
        6
        >>> np.size(a,1)
        3
        >>> np.size(a,0)
        2
    
    ssoommeettrruuee = reduce(target, axis=0, dtype=None) method of numpy.ma.core._MaskedBinaryOperation instance
        Reduce `target` along the given `axis`.
    
    ssoorrtt(a, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None)
        Sort the array, in-place
        
        Parameters
        ----------
        a : array_like
            Array to be sorted.
        axis : int, optional
            Axis along which to sort. If None, the array is flattened before
            sorting. The default is -1, which sorts along the last axis.
        kind : {'quicksort', 'mergesort', 'heapsort'}, optional
            Sorting algorithm. Default is 'quicksort'.
        order : list, optional
            When `a` is a structured array, this argument specifies which fields
            to compare first, second, and so on.  This list does not need to
            include all of the fields.
        endwith : {True, False}, optional
            Whether missing values (if any) should be treated as the largest values
            (True) or the smallest values (False)
            When the array contains unmasked values at the same extremes of the
            datatype, the ordering of these values and the masked values is
            undefined.
        fill_value : {var}, optional
            Value used internally for the masked values.
            If ``fill_value`` is not None, it supersedes ``endwith``.
        
        Returns
        -------
        sorted_array : ndarray
            Array of the same type and shape as `a`.
        
        See Also
        --------
        ndarray.sort : Method to sort an array in-place.
        argsort : Indirect sort.
        lexsort : Indirect stable sort on multiple keys.
        searchsorted : Find elements in a sorted array.
        
        Notes
        -----
        See ``sort`` for notes on the different sorting algorithms.
        
        Examples
        --------
        >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
        >>> # Default
        >>> a.sort()
        >>> print(a)
        [1 3 5 -- --]
        
        >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
        >>> # Put missing values in the front
        >>> a.sort(endwith=False)
        >>> print(a)
        [-- -- 1 3 5]
        
        >>> a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
        >>> # fill_value takes over endwith
        >>> a.sort(endwith=False, fill_value=3)
        >>> print(a)
        [1 -- -- 3 5]
    
    ssqquueeeezzee(a, axis=None)
        Remove single-dimensional entries from the shape of an array.
        
        Parameters
        ----------
        a : array_like
            Input data.
        axis : None or int or tuple of ints, optional
            .. versionadded:: 1.7.0
        
            Selects a subset of the single-dimensional entries in the
            shape. If an axis is selected with shape entry greater than
            one, an error is raised.
        
        Returns
        -------
        squeezed : ndarray
            The input array, but with all or a subset of the
            dimensions of length 1 removed. This is always `a` itself
            or a view into `a`.
        
        Raises
        ------
        ValueError
            If `axis` is not `None`, and an axis being squeezed is not of length 1
        
        See Also
        --------
        expand_dims : The inverse operation, adding singleton dimensions
        reshape : Insert, remove, and combine dimensions, and resize existing ones
        
        Examples
        --------
        >>> x = np.array([[[0], [1], [2]]])
        >>> x.shape
        (1, 3, 1)
        >>> np.squeeze(x).shape
        (3,)
        >>> np.squeeze(x, axis=0).shape
        (3, 1)
        >>> np.squeeze(x, axis=1).shape
        Traceback (most recent call last):
        ...
        ValueError: cannot select an axis to squeeze out which has size not equal to one
        >>> np.squeeze(x, axis=2).shape
        (1, 3)
    
    ttaakkee(a, indices, axis=None, out=None, mode='raise')
    
    ttrraannssppoossee(a, axes=None)
        Permute the dimensions of an array.
        
        This function is exactly equivalent to `numpy.transpose`.
        
        See Also
        --------
        numpy.transpose : Equivalent function in top-level NumPy module.
        
        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = ma.arange(4).reshape((2,2))
        >>> x[1, 1] = ma.masked
        >>>> x
        masked_array(data =
         [[0 1]
         [2 --]],
                     mask =
         [[False False]
         [False  True]],
               fill_value = 999999)
        >>> ma.transpose(x)
        masked_array(data =
         [[0 2]
         [1 --]],
                     mask =
         [[False False]
         [False  True]],
               fill_value = 999999)
    
    uunniioonn11dd(ar1, ar2)
        Union of two arrays.
        
        The output is always a masked array. See `numpy.union1d` for more details.
        
        See also
        --------
        numpy.union1d : Equivalent function for ndarrays.
    
    uunniiqquuee(ar1, return_index=False, return_inverse=False)
        Finds the unique elements of an array.
        
        Masked values are considered the same element (masked). The output array
        is always a masked array. See `numpy.unique` for more details.
        
        See Also
        --------
        numpy.unique : Equivalent function for ndarrays.
    
    vvaannddeerr(x, n=None)
        Generate a Vandermonde matrix.
        
        The columns of the output matrix are powers of the input vector. The
        order of the powers is determined by the `increasing` boolean argument.
        Specifically, when `increasing` is False, the `i`-th output column is
        the input vector raised element-wise to the power of ``N - i - 1``. Such
        a matrix with a geometric progression in each row is named for Alexandre-
        Theophile Vandermonde.
        
        Parameters
        ----------
        x : array_like
            1-D input array.
        N : int, optional
            Number of columns in the output.  If `N` is not specified, a square
            array is returned (``N = len(x)``).
        increasing : bool, optional
            Order of the powers of the columns.  If True, the powers increase
            from left to right, if False (the default) they are reversed.
        
            .. versionadded:: 1.9.0
        
        Returns
        -------
        out : ndarray
            Vandermonde matrix.  If `increasing` is False, the first column is
            ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
            True, the columns are ``x^0, x^1, ..., x^(N-1)``.
        
        See Also
        --------
        polynomial.polynomial.polyvander
        
        Examples
        --------
        >>> x = np.array([1, 2, 3, 5])
        >>> N = 3
        >>> np.vander(x, N)
        array([[ 1,  1,  1],
               [ 4,  2,  1],
               [ 9,  3,  1],
               [25,  5,  1]])
        
        >>> np.column_stack([x**(N-1-i) for i in range(N)])
        array([[ 1,  1,  1],
               [ 4,  2,  1],
               [ 9,  3,  1],
               [25,  5,  1]])
        
        >>> x = np.array([1, 2, 3, 5])
        >>> np.vander(x)
        array([[  1,   1,   1,   1],
               [  8,   4,   2,   1],
               [ 27,   9,   3,   1],
               [125,  25,   5,   1]])
        >>> np.vander(x, increasing=True)
        array([[  1,   1,   1,   1],
               [  1,   2,   4,   8],
               [  1,   3,   9,  27],
               [  1,   5,  25, 125]])
        
        The determinant of a square Vandermonde matrix is the product
        of the differences between the values of the input vector:
        
        >>> np.linalg.det(np.vander(x))
        48.000000000000043
        >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
        48
        
        
        
        Notes
        -----
        
        Masked values in the input array result in rows of zeros.
    
    wwhheerree(condition, x=<class 'numpy._globals._NoValue'>, y=<class 'numpy._globals._NoValue'>)
        Return a masked array with elements from x or y, depending on condition.
        
        Returns a masked array, shaped like condition, where the elements
        are from `x` when `condition` is True, and from `y` otherwise.
        If neither `x` nor `y` are given, the function returns a tuple of
        indices where `condition` is True (the result of
        ``condition.nonzero()``).
        
        Parameters
        ----------
        condition : array_like, bool
            The condition to meet. For each True element, yield the corresponding
            element from `x`, otherwise from `y`.
        x, y : array_like, optional
            Values from which to choose. `x`, `y` and `condition` need to be
            broadcastable to some shape.
        
        Returns
        -------
        out : MaskedArray or tuple of ndarrays
            The resulting masked array if `x` and `y` were given, otherwise
            the result of ``condition.nonzero()``.
        
        See Also
        --------
        numpy.where : Equivalent function in the top-level NumPy module.
        
        Examples
        --------
        >>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
        ...                                                    [1, 0, 1],
        ...                                                    [0, 1, 0]])
        >>> print(x)
        [[0.0 -- 2.0]
         [-- 4.0 --]
         [6.0 -- 8.0]]
        >>> np.ma.where(x > 5)    # return the indices where x > 5
        (array([2, 2]), array([0, 2]))
        
        >>> print(np.ma.where(x > 5, x, -3.1416))
        [[-3.1416 -- -3.1416]
         [-- -3.1416 --]
         [6.0 -- 8.0]]

DDAATTAA
    ____aallll____ = ['core', 'extras', 'MAError', 'MaskError', 'MaskType', 'Mask...
    aabbss = <numpy.ma.core._MaskedUnaryOperation object>
    aabbssoolluuttee = <numpy.ma.core._MaskedUnaryOperation object>
    aadddd = <numpy.ma.core._MaskedBinaryOperation object>
    aallll = <numpy.ma.core._frommethod object>
    aannggllee = <numpy.ma.core._MaskedUnaryOperation object>
    aannoomm = <numpy.ma.core._frommethod object>
    aannoommaalliieess = <numpy.ma.core._frommethod object>
    aannyy = <numpy.ma.core._frommethod object>
    aarraannggee = <numpy.ma.core._convert2ma object>
    aarrccccooss = <numpy.ma.core._MaskedUnaryOperation object>
    aarrccccoosshh = <numpy.ma.core._MaskedUnaryOperation object>
    aarrccssiinn = <numpy.ma.core._MaskedUnaryOperation object>
    aarrccssiinnhh = <numpy.ma.core._MaskedUnaryOperation object>
    aarrccttaann = <numpy.ma.core._MaskedUnaryOperation object>
    aarrccttaann22 = <numpy.ma.core._MaskedBinaryOperation object>
    aarrccttaannhh = <numpy.ma.core._MaskedUnaryOperation object>
    aarrggmmaaxx = <numpy.ma.core._frommethod object>
    aarrggmmiinn = <numpy.ma.core._frommethod object>
    aarroouunndd = <numpy.ma.core._MaskedUnaryOperation object>
    aattlleeaasstt__11dd = <numpy.ma.extras._fromnxfunction_allargs object>
    aattlleeaasstt__22dd = <numpy.ma.extras._fromnxfunction_allargs object>
    aattlleeaasstt__33dd = <numpy.ma.extras._fromnxfunction_allargs object>
    bbiittwwiissee__aanndd = <numpy.ma.core._MaskedBinaryOperation object>
    bbiittwwiissee__oorr = <numpy.ma.core._MaskedBinaryOperation object>
    bbiittwwiissee__xxoorr = <numpy.ma.core._MaskedBinaryOperation object>
    cceeiill = <numpy.ma.core._MaskedUnaryOperation object>
    ccoolluummnn__ssttaacckk = <numpy.ma.extras._fromnxfunction_seq object>
    ccoommpprreessss = <numpy.ma.core._frommethod object>
    ccoonnjjuuggaattee = <numpy.ma.core._MaskedUnaryOperation object>
    ccooppyy = <numpy.ma.core._frommethod object>
    ccooss = <numpy.ma.core._MaskedUnaryOperation object>
    ccoosshh = <numpy.ma.core._MaskedUnaryOperation object>
    ccoouunntt = <numpy.ma.core._frommethod object>
    ccuummpprroodd = <numpy.ma.core._frommethod object>
    ccuummssuumm = <numpy.ma.core._frommethod object>
    ddiiaaggffllaatt = <numpy.ma.extras._fromnxfunction_single object>
    ddiiaaggoonnaall = <numpy.ma.core._frommethod object>
    ddiivviiddee = <numpy.ma.core._DomainedBinaryOperation object>
    ddssttaacckk = <numpy.ma.extras._fromnxfunction_seq object>
    eemmppttyy = <numpy.ma.core._convert2ma object>
    eemmppttyy__lliikkee = <numpy.ma.core._convert2ma object>
    eeqquuaall = <numpy.ma.core._MaskedBinaryOperation object>
    eexxpp = <numpy.ma.core._MaskedUnaryOperation object>
    ffaabbss = <numpy.ma.core._MaskedUnaryOperation object>
    fflloooorr = <numpy.ma.core._MaskedUnaryOperation object>
    fflloooorr__ddiivviiddee = <numpy.ma.core._DomainedBinaryOperation object>
    ffmmoodd = <numpy.ma.core._DomainedBinaryOperation object>
    ffrroommbbuuffffeerr = <numpy.ma.core._convert2ma object>
    ffrroommffuunnccttiioonn = <numpy.ma.core._convert2ma object>
    ggrreeaatteerr = <numpy.ma.core._MaskedBinaryOperation object>
    ggrreeaatteerr__eeqquuaall = <numpy.ma.core._MaskedBinaryOperation object>
    hhaarrddeenn__mmaasskk = <numpy.ma.core._frommethod object>
    hhsspplliitt = <numpy.ma.extras._fromnxfunction_single object>
    hhssttaacckk = <numpy.ma.extras._fromnxfunction_seq object>
    hhyyppoott = <numpy.ma.core._MaskedBinaryOperation object>
    iiddeennttiittyy = <numpy.ma.core._convert2ma object>
    iiddss = <numpy.ma.core._frommethod object>
    lleessss = <numpy.ma.core._MaskedBinaryOperation object>
    lleessss__eeqquuaall = <numpy.ma.core._MaskedBinaryOperation object>
    lloogg = <numpy.ma.core._MaskedUnaryOperation object>
    lloogg1100 = <numpy.ma.core._MaskedUnaryOperation object>
    lloogg22 = <numpy.ma.core._MaskedUnaryOperation object>
    llooggiiccaall__aanndd = <numpy.ma.core._MaskedBinaryOperation object>
    llooggiiccaall__nnoott = <numpy.ma.core._MaskedUnaryOperation object>
    llooggiiccaall__oorr = <numpy.ma.core._MaskedBinaryOperation object>
    llooggiiccaall__xxoorr = <numpy.ma.core._MaskedBinaryOperation object>
    mmaasskkeedd = masked
    mmaasskkeedd__pprriinntt__ooppttiioonn = --
    mmaasskkeedd__ssiinngglleettoonn = masked
    mmaaxxiimmuumm = <numpy.ma.core._extrema_operation object>
    mmeeaann = <numpy.ma.core._frommethod object>
    mmiinniimmuumm = <numpy.ma.core._extrema_operation object>
    mmoodd = <numpy.ma.core._DomainedBinaryOperation object>
    mmrr__ = <numpy.ma.extras.mr_class object>
    mmuullttiippllyy = <numpy.ma.core._MaskedBinaryOperation object>
    nneeggaattiivvee = <numpy.ma.core._MaskedUnaryOperation object>
    nnoommaasskk = False
    nnoonnzzeerroo = <numpy.ma.core._frommethod object>
    nnoott__eeqquuaall = <numpy.ma.core._MaskedBinaryOperation object>
    oonneess = <numpy.ma.core._convert2ma object>
    pprroodd = <numpy.ma.core._frommethod object>
    pprroodduucctt = <numpy.ma.core._frommethod object>
    rraavveell = <numpy.ma.core._frommethod object>
    rreemmaaiinnddeerr = <numpy.ma.core._DomainedBinaryOperation object>
    rreeppeeaatt = <numpy.ma.core._frommethod object>
    rrooww__ssttaacckk = <numpy.ma.extras._fromnxfunction_seq object>
    ssiinn = <numpy.ma.core._MaskedUnaryOperation object>
    ssiinnhh = <numpy.ma.core._MaskedUnaryOperation object>
    ssoofftteenn__mmaasskk = <numpy.ma.core._frommethod object>
    ssqqrrtt = <numpy.ma.core._MaskedUnaryOperation object>
    ssttdd = <numpy.ma.core._frommethod object>
    ssuubbttrraacctt = <numpy.ma.core._MaskedBinaryOperation object>
    ssuumm = <numpy.ma.core._frommethod object>
    sswwaappaaxxeess = <numpy.ma.core._frommethod object>
    ttaann = <numpy.ma.core._MaskedUnaryOperation object>
    ttaannhh = <numpy.ma.core._MaskedUnaryOperation object>
    ttrraaccee = <numpy.ma.core._frommethod object>
    ttrruuee__ddiivviiddee = <numpy.ma.core._DomainedBinaryOperation object>
    vvaarr = <numpy.ma.core._frommethod object>
    vvssttaacckk = <numpy.ma.extras._fromnxfunction_seq object>
    zzeerrooss = <numpy.ma.core._convert2ma object>

FFIILLEE
    /usr/lib/python3/dist-packages/numpy/ma/__init__.py

